[{"title":"DOM编程艺术：重回图片库","date":"2017-06-28T01:39:51.000Z","path":"2017/06/28/DOM编程艺术：重回图片库/","text":"1234567891011121314151617&lt;h1&gt;Snapshots&lt;/h1&gt;&lt;ul id=\"imagegallery\"&gt; &lt;li&gt; &lt;a href=\"images/fireworks.gif\" title=\"A fireworks display\"; &gt;&lt;img src=\"images/fireworks.gif\" alt=\"Fire\"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/coffee.gif\" title=\"A cup of black coffee\" &gt;&lt;img src=\"images/coffee.gif\" alt=\"coffee\"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/rose.gif\" title=\"A red rose\" &gt;Rose&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/bigben.gif\" title=\"The famous clock\" &gt;Big Ben&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;img src=\"images/hello.gif\" id=\"placeholder\" alt=\"my image gallery\"&gt;&lt;p id=\"description\"&gt;Choose an image!&lt;/p&gt; 这个 HTML 文件中有一个图片和一段文字仅仅是为 showPic 脚本服务的。若能被结构和行为彻底分离开那就再好不过了。既然这些元素的存在只是为了让 DOM 方法处理他们，那么用 DOM 方法来创建他们才是最合适的选择。 1234567891011121314151617// html&lt;h1&gt;Snapshots&lt;/h1&gt;&lt;ul id=\"imagegallery\"&gt; &lt;li&gt; &lt;a href=\"images/fireworks.gif\" title=\"A fireworks display\"; &gt;&lt;img src=\"images/fireworks.gif\" alt=\"Fire\"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/coffee.gif\" title=\"A cup of black coffee\" &gt;&lt;img src=\"images/coffee.gif\" alt=\"coffee\"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/rose.gif\" title=\"A red rose\" &gt;Rose&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/bigben.gif\" title=\"The famous clock\" &gt;Big Ben&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// js&lt;script type=\"text/javascript\"&gt;window.onload = addLoadEvent();function showPic(whichpic)&#123; if(!document.getElementById('placeholder')) return false; var source = whichpic.getAttribute(\"href\"); var placeholder = document.getElementById('placeholder'); if(placeholder.nodeName != 'IMG') return false; placeholder.setAttribute(\"src\",source); if(!document.getElementById('description')) return false; var text = whichpic.getAttribute('title') ? whichpic.getAttribute('title') : \"\"; var description = document.getElementById('description'); if (description.firstChild.nodeType == 3) &#123; description.firstChild .nodeValue = text; &#125; // 阻止 a 连接的默认事件，防止其在新的窗口打开 return false;&#125;function prepareGallery() &#123; if(!document.getElementsByTagName) return false; if(!document.getElementById) return false; if(!document.getElementById('imagegallery')) return false; var gallery = document.getElementById('imagegallery'); var links = gallery.getElementsByTagName('a'); for(var i=0; i&lt;links.length; i++) &#123; links[i].onclick = function() &#123; return showPic(this); // return !showPic(this); // 等价于 // if (showPic(this)) &#123; // return false; // &#125; else &#123; // return true; // &#125; // 等价于 // return showPic(this) ? false : true; &#125; &#125;&#125;function addLoadEvent(func) &#123; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = func; &#125; else &#123; window.onload = function() &#123; oldonload(); func(); &#125; &#125;&#125;function insertAfter(newElement, targetElement) &#123; var parent = targetElement.parentNode; if (parent.lastChild == targetElement) &#123; parent.appendChild(newElement); &#125; else &#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125;&#125; function preparePlaceholder() &#123; if (!document.createElement) return false; if (!document.createTextNode) return false; if (!document.getElementById) return false; if (!document.getElementById('imagegallery')) return false; var placeholder = document.createElement('img'); placeholder.setAttribute('id','placeholder'); placeholder.setAttribute('src','images/hello.gif'); placeholder.setAttribute('alt','my image gallery'); var description = document.createElement('p'); description.setAttribute('id','description'); var desctext = document.createTextNode('choose an image!'); description.appendChild(desctext); var gallery = document.getElementById('imagegallery'); insertAfter(placeholder,gallery); insertAfter(description,placeholder); &#125; addLoadEvent(preparePlaceholder);addLoadEvent(prepareGallery);&lt;/script&gt; 现在，图片的行为结构、样式和行为已经彻底分离了。 源代码效果展示","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ijiangnanbei.com/tags/性能优化/"}]},{"title":"DOM 初级知识点总结","date":"2017-06-28T01:12:57.000Z","path":"2017/06/28/DOM-初级知识点总结/","text":"setAttributesetAttribute 可以改变 DOM 节点树上的某个属性节点，相关文档在浏览器里的呈现就会发生相应的变化。不过，setAttribute 方法并未改变文档的物理内容，如果用文本编辑器而不是浏览器去打开这个文档，我们将看不到任何变化。 一旦明白了这个道理，以动态方式实时创建标记就不那么难以理解了。你并不是在创建标记，而是在改变 DOM 节点树。 insertBefore()insertBefore() 把一个新元素插入到一个现有元素的前面。在调用此方法时，你必须告诉它三件事： 1.新元素：你想插入的元素（newElement）2.目标元素：你想把这个元素插入到哪个元素之前（targetElement）3.父元素：目标元素的父元素（parentElement） 123parentElement.insertBefore(newElement,targetElement);targetElement.parentNode.insertBefore(newElement,targetElement); 编写 insertAfter() 函数12345678function insertAfter(newElement, targetElement) &#123; var parent = targetElement.parentNode; if (parent.lastChild == targetElement) &#123; parent.appendChild(newElement); &#125; else &#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125;&#125;","tags":[{"name":"DOM","slug":"DOM","permalink":"http://ijiangnanbei.com/tags/DOM/"}]},{"title":"document.wirte() 和 innerHTML属性","date":"2017-06-28T01:04:26.000Z","path":"2017/06/28/document-wirte-和-innerHTML属性/","text":"避免使用 document.write 方法document.write 最大的缺点就是它违背了“行为应该与样式分离”的原则。即使把 document.write 语句挪到外部函数里，也还是需要在标记的 body 部分使用 &lt;script&gt; 标签才能调用那个函数。 1234567&lt;body&gt; &lt;p&gt;this is a p&lt;/P &lt;script&gt; document.write(\"123\"); &lt;/script&gt; &lt;p&gt;this is a p&lt;/P&gt;&lt;/body&gt; 把 JS 代码和 HTML 代码混杂在一起是一种很不好的做法。这样的标记既不容易阅读和编辑，也无法享受到把行为与结构分离开来的好处。同时，这样的文档还很容易导致验证错误。 还有，MIME类型 appplication/xhtml+xml 与 document.write 不兼容，浏览器在呈现这种 XHTML 文档时根本不会执行 document.write 方法。 从某种意义上讲，使用 document.write 方法有点像使用 &lt;font&gt; 标签去设定字体和颜色。 innerHTML 属性在需要把一大段 HTML 内容插入一份文档时，innerHTML 属性可以让你又快有简单的完成这一任务。不过，innerHTML 属性不会返回任何对刚插入的内容的引用。如果想对刚插入的内容进行处理，则需要使用 DOM 提供的那些精确的方法和属性。 innerHTML 属性比 document.write 方法更值得推荐。使用 innerHTML 属性，你就可以吧 JS 代码从标记中分离出来。用不着在标记的 &lt;body&gt; 部分插入 &lt;script&gt; 标签。 类似于 document.write 方法，innerHTML 属性也是 HTML 专有属性，不能用于其他任何标记语言文档。浏览器在呈现正宗的 XHTML 文档时会直接忽略到 innerHTML 属性。 任何时候，标准的 DOM 都可以用来替代 innerHTML 。虽说这往往需要多编写一些代码才能获得同样的效果，但 DOM 同时也提供了更高的精确性和更强大的功能。","tags":[{"name":"DOM","slug":"DOM","permalink":"http://ijiangnanbei.com/tags/DOM/"}]},{"title":"DOM编程艺术：图片库改进版","date":"2017-06-28T00:10:34.000Z","path":"2017/06/28/DOM编程艺术：图片库改进版/","text":"源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//HTML&lt;h1&gt;Snapshots&lt;/h1&gt;&lt;ul id=\"imagegallery\"&gt; &lt;li&gt; &lt;!-- 此时连接上有两个行为，一个是 showPic ，另一个就是连接的默认行为，我们可以使用return false 阻止事件的默认行为 --&gt; &lt;a href=\"images/fireworks.gif\" title=\"A fireworks display\"; &gt;&lt;img src=\"images/fireworks.gif\" alt=\"Fire\"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/coffee.gif\" title=\"A cup of black coffee\" &gt;&lt;img src=\"images/coffee.gif\" alt=\"coffee\"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/rose.gif\" title=\"A red rose\" &gt;Rose&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"images/bigben.gif\" title=\"The famous clock\" &gt;Big Ben&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;img src=\"images/hello.gif\" id=\"placeholder\" alt=\"my image gallery\"&gt;&lt;p id=\"description\"&gt;Choose an image!&lt;/p&gt;//JS&lt;script type=\"text/javascript\"&gt;window.onload = addLoadEvent();function showPic(whichpic)&#123; if(!document.getElementById('placeholder')) return false; var source = whichpic.getAttribute(\"href\"); var placeholder = document.getElementById('placeholder'); if(placeholder.nodeName != 'IMG') return false; placeholder.setAttribute(\"src\",source); if(!document.getElementById('description')) &#123; var text = whichpic.getAttribute('title') ? whichpic.getAttribute('title') : \"\"; var description = document.getElementById('description'); if (description.firstChild.nodeType == 3) &#123; description.firstChild.nodeValue = text; &#125; &#125; return true;&#125;function prepareGallery() &#123; if(!document.getElementsByTagName) return false; if(!document.getElementById) return false; if(!document.getElementById('imagegallery')) return false; var gallery = document.getElementById('imagegallery'); var links = gallery.getElementsByTagName('a'); for(var i=0; i&lt;links.length; i++) &#123; links[i].onclick = function() &#123; return !showPic(this); // 等价于 // if (showPic(this)) &#123; // return false; // &#125; else &#123; // return true; // &#125; // 等价于 // return showPic(this) ? false : true; &#125; &#125;&#125;function addLoadEvent(func) &#123; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = func; &#125; else &#123; window.onload = function() &#123; oldonload(); func(); &#125; &#125;&#125;addLoadEvent(prepareGallery);addLoadEvent(showPic);&lt;/script&gt; 效果展示","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ijiangnanbei.com/tags/性能优化/"}]},{"title":"HTML Core 和 HTML-DOM","date":"2017-06-27T07:01:04.000Z","path":"2017/06/27/HTML-Core-和-HTML-DOM/","text":"getElementById getElementsByTagName getAttribute setAttribute 这些方法都是 DOM Core 的组成部分，他们并不专属于 JS，支持 DOM 的任何一种程序设计语言都可以使用他们。他们的用途也并非仅限于处理网页，他们可以用来处理任何一种标记语言，比如 XML 编写出来的文档。 在使用 JS 语言和 DOM 为 HTML 文件编写脚本时，还有许多属性可供选用。例如，我们已经使用的一个属性 onclick 。这些属性属于 HTML-DOM ，它们在 DOM Core 出现之前很久就已经为人们所熟悉了。 比如说，HTML-DOM 提供了一个 forms 对象，这个对象可以吧下面这样的语句：document.getElementsByTagName(&#39;from&#39;) 简化为 document.forms 类似的，HTML-DOM 还提供了描述各种描述 HTML 元素的属性。比如说，HTML-DOM为图片提供的 src 属性可以把下面这样的语句：element.getAttribute(&#39;src&#39;) 简化为 element.src 这些方法和属性可以相互替换。同样的操作既可只使用 DOM Core 来实现，也可以使用 HTML-DOM 来实现。正如大家看到的那样，HTML-DOM 代码通常会更短，必须提醒一下，他们只能用来处理 web 文档。如果你打算用 DOM 处理其他类型的文档，务必注意这一点。 123456789//DOM Corevar source = whichpic.getAttribute('href');//HTML-DOMvar source = whichpic.href;//DOM Coreplaceholder.setAttribute('src',source);//HTML-DOMplaceholder.src = source;","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ijiangnanbei.com/tags/性能优化/"}]},{"title":"DOM编程艺术：键盘访问","date":"2017-06-27T06:12:17.000Z","path":"2017/06/27/DOM编程艺术：键盘访问/","text":"不要忘记并非所有的用户使用的都是鼠标。比如说有实力残疾的用户往往无法看清屏幕上四处移动的鼠标指针，他们往往更喜欢使用键盘。 有个名叫 onkeypress 的事件处理函数是专门用来处理键盘事件的，按下键盘上任何一个按键都会触发这个事件。 如果想让 onkeypress 事件与 onclick 事件触发同样的行为，可以简单地把有关指令复制一份。 12345678for(var i=0; i&lt;links.length; i++) &#123; links[i].onclick = function() &#123; return !showPic(this); &#125; // 加入键盘事件 links[i].onkeypress = links[i].oncick;&#125; 小心 onkeypress最终这个程序还是没有添加 onkeypress 事件处理函数。原因是这个事件处理函数很容易出问题。用户按下每一个按键都会触发它。在某些浏览器里，甚至包括 Tab 键！这意味着如果绑定在 onkeypress 事件上的处理函数返回的是 false，那些之使用键盘访问的用户将永远无法离开当前链接。 幸运的是，onclick 事件处理函数比我们想象的更加聪明：在几乎所有的浏览器里，用 Tab 键移动到某个链接然后按下回车键的动作也会触发 onclick 事件。 有些可用性指南建议我们在处理 onclick 事件时一定要处理 onkeypress 事件。事实上，这种搭配导致的我问题永远比他们解决的多。 最好不要使用 onkeypress 事件处理函数。 onclick 事件处理函数已经能满足需要。虽然他的名字是 onclick ，但它对键盘访问的支持相当完美。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ijiangnanbei.com/tags/性能优化/"}]},{"title":"DOM编程艺术：优化","date":"2017-06-27T05:33:17.000Z","path":"2017/06/27/DOM编程艺术：优化/","text":"1234567891011121314function showPic(whichpic)&#123; if(!document.getElementById('placeholder')) return false; var source = whichpic.getAttribute('href'); var placeholder = document.getElementById('placeholder'); placeholder.setAttribute(\"src\",source); if(!document.getElementById('description')) &#123; var text = which.getAttribute('title'); var description = document.getElementById('description'); description.firstChild.nodeValue = text; &#125; return true;&#125; showPic 这个函数已经相当完善了，尽管如此，在其中仍然存在一些需要处理的假设：比如说，为了检查 title 属性是否存在，可以测试它是不是等于 null，如果不存在则设置为空字符串。 1var text = whichpic.getAttribute('title') ? whichpic.getAttribute('title') : \"\"; 如果你想做到十全十美的话，可以对任何一种情况进行检查。比如说，检查 placeholder 元素是否存在，但需要假设那是一张图片。为了验证这种情况，可以用 nodeName 属性来增加一项测试：12if(placeholder.nodeName != 'IMG') return false;//nodeName 属性总是返回一个大写的字母值，即使元素在 HTML 文档里面是小写字母 你还可以引入更过的检查。比如说：假设 description 元素的第一个子元素是一个文本节点。我应该对此检查。123if (description.firstChild.nodeType == 3) &#123; description.firstChild.nodeValue = text;&#125; 下面是引入了几项检查之后该函数的代码清单：123456789101112131415161718function showPic(whichpic)&#123; if(!document.getElementById('placeholder')) return false; var source = whichpic.getAttribute('href'); var placeholder = document.getElementById('placeholder'); if(placeholder.nodeName != 'IMG') return false; placeholder.setAttribute(\"src\",source); if(!document.getElementById('description')) &#123; var text = whichpic.getAttribute('title') ? whichpic.getAttribute('title') : \"\"; var text = which.getAttribute('title'); var description = document.getElementById('description'); if (description.firstChild.nodeType == 3) &#123; description.firstChild.nodeValue = text; &#125; &#125; return true;&#125; 在实际的工作中，你要自己决定是否真的需要这些检查。他们针对的是 HTML 文档有可能不在你控制范围之内的情况。理想情况下，你的脚本不应该对 HTML 文档的内容和结构做出太多的假设。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ijiangnanbei.com/tags/性能优化/"}]},{"title":"DOM编程艺术：不要做太多的假设","date":"2017-06-27T02:43:03.000Z","path":"2017/06/27/DOM编程艺术：不要做太多的假设/","text":"123456789101112131415161718192021222324function showPic(whichpic)&#123; var source = whichpic.getAttribute('href'); var placeholder = document.getElementById('placeholder'); placeholder.setAttribute('src',source); var text = whichpic.getAttribute('title'); var description = document.getElementById('description'); description.firstChild.nodeValue = text;&#125;function prepareGallery() &#123; if(!document.getElementsByTagName) return false; if(!document.getElementById) return false; if(!document.getElementById('imagegallery')) return false; var gallery = document.getElementById('imagegallery'); var links = gallery.getElementsByTagName('a'); for(var i=0; i&lt;links.length; i++) &#123; links[i].onclick = function() &#123; showPic(this); return false; &#125; &#125;&#125; showPic 函数里面的第一个问题是，没有进行任何测试和检查。showPic 函数将由 prepareGallery 函数调用，而后者的开头已经对 getElementById 和 getElementsByTagName 的 DOM 方法是否存在进行过检查， 所以用户的浏览器不会因为不理解这两个方法而出问题。 不过，这里还是做出了过多的假设。showPic 函数里用到了 id 属性值等于 placeholder 和 description 的元素，但是并未对这些元素是否存在做任何检查。所以需要增加一些语句来检查这些元素是否存在。 showPic 函数负责完成两件事：一是找出 id 属性值是 placeholder 的图片并修改其 src 属性；二是找出 id 属性值是 description 的元素并修改其第一个子元素的 nodeValue 属性。第一件事是这个函数必须完成的任务，第二件事只是一项锦上添花的补充。因此，你可以把检查工作分成两个步骤以获得这样一种效果：只要 placeholder 图片存在，即使 description 元素不存在，切换显示新图片的操作也将正常进行。 1234567891011121314//这部分代码用来完成函数的主要任务if(!document.getElementById('placeholder')) return false;var source = whichpic.getAttribute('href');var placeholder = document.getElementById('placeholder');placeholder.setAttribute(\"src\",source);//只有通过了这项检查，负责修改图片说明文字的代码才会得到执行if(!document.getElementById('description')) &#123; var text = which.getAttribute('title'); var description = document.getElementById('description'); description.firstChild.nodeValue = text;&#125;//将描述部分放在 if 语句里面，description 元素将是可选的。如果它存在，将被更新，否则会忽略return true; 下面是增加了检查之后的代码清单：12345678910111213function showPic(whichpic)&#123; if(!document.getElementById('placeholder')) return false; var source = whichpic.getAttribute('href'); var placeholder = document.getElementById('placeholder'); placeholder.setAttribute(\"src\",source); if(!document.getElementById('description')) &#123; var text = which.getAttribute('title'); var description = document.getElementById('description'); description.firstChild.nodeValue = text; &#125; return true;&#125; 改进后的 showPic 函数不再假设有关标记文档里肯定存在着 placeholder 图片和 description 元素。即使文档里没有 placeholder 图片，也不会发生任何 JS 错误。 但是，这里还有一个问题：如果把 placeholder 图片从标记文档里删掉并在浏览器里刷新页面，就会出现这种情况，无论我们点击 imagegellery 清单中的哪一个链接，都没有任何响应。 这意味着我们的脚本不能平稳退化。此时，应该让浏览器打开那个被点击的链接，而不是让什么事情都不发生。 问题在于 prepareGallery 函数做了一个这样的假设： showPic 肯定会正常返回。基于这一假设， prepareGallery 取消了 onclick 事件的默认行为。 但是，是否要返回一个 false 值以取消 onclick 事件的默认行为，其实应该有 showPic 函数决定，这个函数应该返回两个可能的值。如果图片切换成功，返回 true。如果图片切换不成功，返回 false。 为修正这个问题，应该在返回前验证 showPic 的返回值，以便决定是否组织默认行为。如果返回 true ，那么更新 placeholder 。在 onclick 事件处理函数中，我们可以利用 “!” 对 showpic 的返回值进行取反。12345links[i].onclick = function()&#123;//现在，如果 showPic 返回 true，我们就返回 false ，浏览器就不会打开那个连接//如果 showPic 返回 false，那么我们认为图片没有更新，于是返回 true以允许默认行为发生 return !showPic(this);&#125; 下面是完整的代码清单：123456789101112131415161718192021222324252627function showPic(whichpic)&#123; if(!document.getElementById('placeholder')) return false; var source = whichpic.getAttribute('href'); var placeholder = document.getElementById('placeholder'); placeholder.setAttribute(\"src\",source); if(!document.getElementById('description')) &#123; var text = which.getAttribute('title'); var description = document.getElementById('description'); description.firstChild.nodeValue = text; &#125; return true;&#125;function prepareGallery() &#123; if(!document.getElementsByTagName) return false; if(!document.getElementById) return false; if(!document.getElementById('imagegallery')) return false; var gallery = document.getElementById('imagegallery'); var links = gallery.getElementsByTagName('a'); for(var i=0; i&lt;links.length; i++) &#123; links[i].onclick = function() &#123; return !showPic(this); &#125; &#125;&#125;","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ijiangnanbei.com/tags/性能优化/"}]},{"title":"DOM编程艺术：共享 onload 事件","date":"2017-06-27T02:10:30.000Z","path":"2017/06/27/DOM编程艺术：共享-onload-事件/","text":"假设我有两个函数：firstFunction 和 secondFunction 。如果想让他们俩在页面加载时得到的执行，该怎么办？如果把它们逐一绑定到 onload 事件上，他们当中只有最后那个才会被实际执行： 12window.onload = fristFunction;window.onload = secondFunction; 有一种办法可以解决这一难题：可以先创建一个你们函数来容纳这两个函数，然后把那个匿名函数绑定到 onload 事件上： 1234window.onload = function()&#123; firstFunction(); secondFunction();&#125; 上面这段代码在绑定函数不是很多的场合确实可以很好的工作。 这里还有一个弹性最佳的解决方案：不管你打算在页面加载完毕时执行多少个函数，它都可以应付自如。 这个函数的名字是 addLoadEvent ，他只有一个参数：打算在页面加载完毕时执行的函数的名字。下面是这个函数将要完成的操作：123456789101112131415//1.把现有的 window.onload 事件处理函数的值存入变量 oldonload//2.如果在这个处理函数上还没有绑定任何函数，就像平时那样把新函数添加给它//3.如果在这个处理函数上已经绑定了一些函数，就把新函数追加到现有指令的末尾function addLoadEvent(func) &#123; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = func; &#125; else &#123; window.onload = function() &#123; oldonload(); func(); &#125; &#125;&#125; 这将把那些在页面加载完毕时执行的函数创建为一个队列。如果想把刚才那两个函数添加到这个队列中去，只需要写出下面两行代码即可： 12addLoadEvent(firstFunction);addLoadEvent(secondFunction); 这个函数非常实用，尤其是在代码变得越来越复杂的时候。无论在页面加载完毕时执行多少个函数，只要多写一条语句就可以安排好一切。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ijiangnanbei.com/tags/性能优化/"}]},{"title":"DOM编程艺术：预防性措施","date":"2017-06-27T02:09:38.000Z","path":"2017/06/27/DOM编程艺术：预防性措施/","text":"1if(!document.getElementById('imagegallery')) return false; 这项测试是一个预防性措施。现在我知道用这个调用 JS 函数的文档里有一个 id 属性值等于 imagegallery 的列表清单元素，但我不敢确定这在将来会不会发生变化。有了这个预防性措施，即使我决定以后从网页上删掉图片库，也用不着担心这个网页的 JS 代码会突然出错。 把 HTML 文档的内容和 JS 代码所实现的行为分离开来的重要性由此可见一斑。作为一条原则，如果想用 JS 给某个网页添加一条行为，就不应该让 JS 对这个网页的结构有任何的依赖。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ijiangnanbei.com/tags/性能优化/"}]},{"title":"结构化程序设计","date":"2017-06-27T01:35:27.000Z","path":"2017/06/27/结构化程序设计/","text":"结构化程序设计中有这样一条原则：函数应该只有一个入口和一个出口。 123456789101112131415function prepareGallery() &#123; if(!document.getElementsByTagName) return false; if(!document.getElementById) return false; if(!document.getElementById('imagegallery')) return false; var gallery = document.getElementById('imagegallery'); var links = gallery.getElementsByTagName('a'); for(var i=0; i&lt;links.length; i++) &#123; links[i].onclick = function() &#123; showPic(this); return false; &#125; &#125;&#125; 上面这个函数的做法已经违背了这条原则，函数的开头部分有多个 return false 语句，他们全都是这个函数的出口。根据结构化程序设计理论，应该把这些出口减少至一个。 理论上，是这样的，但是在实际工作中，过分拘泥于这项原则会使代码变得非常难以阅读。如果你遵循了这条原则，那么代码看起来将会是下面这样：这个函数的核心代码就会被掩埋在一层有一层的花括号里。 123456789function prepareGallery() &#123; if(!document.getElementsByTagName) &#123; if(!document.getElementById) &#123; if(!document.getElementById('imagegallery'))&#123; return false; &#125; &#125; &#125;&#125; 如果一个函数有多个出口，只要这些出口集中出现在函数的开头部分，就是可以接受的。","tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://ijiangnanbei.com/tags/前端开发/"}]},{"title":"DOM编程艺术：性能优化","date":"2017-06-27T00:13:34.000Z","path":"2017/06/27/DOM编程艺术：性能优化/","text":"尽量少访问 DOM 和 尽量减少标记不管是什么时候，只要是查询 DOM 中的某些元素，浏览器都会搜索整个 DOM 树，从中查找可能匹配的元素。 要是你有多个函数重复做同一件事。比如，要是有一个函数检查每个链接中的 popUp 类，而另外一个函数检查每个链接中的 hover 类，那么同样也会造成搜索浪费。 在多个函数取得一组类似元素的情况下，可以考虑重构代码，把搜索结果保存在一个全局变量里，或者把一组元素直接以参数的形式传递给函数。 另一个需要注意的地方，就是要尽量减少文档中的标记数量。过多不必要的元素只会增加 DOM 树的规模，进而增加遍历 DOM 树以查找特定元素的时间。 合并和放置脚本在把脚本引入到页面中时，要把多个脚本合并到一个 。这样，就可以减少加载页面时发送请求的数量。而减少请求的数量通常是在性能优化时首先要考虑的。 把脚本文件放在文档的末尾，就可以让页面变得更快。即使这样，在加载脚本时，window 对象的 load 事件依然可以执行对文档进行的各种操作。 压缩脚本多数情况下，你应该有两个版本，一个是工作副本，可以修改代码并添加注释；另一个是精简副本，用于放在站点上。通常，为了与非精简版本区分开，最好在精简副本的文件名中加上 min 字样。 下面是几个有代表性的代码压缩工具： 1.JSMin2.UI Compressor3.Closure Compiler","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ijiangnanbei.com/tags/性能优化/"}]},{"title":"DOM编程艺术：向后兼容","date":"2017-06-26T23:39:01.000Z","path":"2017/06/27/DOM编程艺术：向后兼容/","text":"即使是某位用户在访问你的网站的时候使用的是支持 JS 的浏览器，某些脚本也不一定能正常工作。 对象检测针对这一问题最简单的解决方案是：检测浏览器对 JS 的支持程度。也就是说只有浏览器理解这么多的 JS 语言才能执行这些语句。 这个方案很容易实现：只要把某个方法打包在一个 if 语句里，就可以根据这条 if 条件语句表达式的求值结果是 true 还是 false，来决定应该采取怎样的行动。这种检测称为对象检测。几乎所有的东西，包括各种方法在内，都可以被当做对象来对待，而这意味着我们可以容易的把不支持某个特定 DOM 方法的浏览器检测出来。 例如，如果有一个使用了 getElementById() 方法的函数，就可以在调用 getElementById() 方法之前检查用户所使用的浏览器是否支持这个方法。 1234if(!getElementById) return false;//如果需要测试多个属性或方法是否存在，可以使用逻辑或if(!getElementById || !getElementsByTagName) return false; 注意：在使用对象检测时，一定要删掉方法名后面的圆括号，如果不删掉，测试的将是方法的结果，无论方法是否存在。 12345678910var links = document.getElementsByTagName('a');if(!getElementsByTagName) return false;for(var i=0; i&lt;links.length; i++) &#123; if (links[i].getAttribute('class') == 'popup')&#123; links[i].onclick = function()&#123; popUp(this.getAttribute('href')); return false; &#125; &#125;&#125; 虽然只是一条简单的 if 语句，但它可以确保那些古老的浏览器不会因为我的脚本代码而出问题。这么做是为了让脚本有良好的向后兼容性。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ijiangnanbei.com/tags/性能优化/"}]},{"title":"DOM编程艺术：渐进增强","date":"2017-06-26T22:52:17.000Z","path":"2017/06/27/DOM编程艺术：渐进增强/","text":"结构与样式的分离 CSS 技术突出的优点，文档结构与文档样式的分离可以确保网页都能平稳退化。具备 CSS 支持的浏览器固然可以把网页呈现的美轮美奂，不支持或者是禁用了 CSS 的浏览器同样可以把网页的内容按照正确的结构显示出来。 渐进增强在创建网站的时候，给内容加上正确的 HTML 标记是第一个步骤，或许也是最重要的步骤，“标记良好的内容就是一切”。 再给内容加上各种标记之后，就可以使用各种 CSS 指令控制内容的显示效果。CSS 指令构成了一个表示层。这个表示层就像是一张透明的彩色薄膜，可以包裹到文档的结构上，使文档的内容呈现出各种色彩。但即使去掉这个表示层，文档的内容也依然可以访问。 所谓“渐进增强”就是用一些额外的信息去包裹原始数据。按照“渐进增强”创建出来的网页几乎都符合“平稳退化”原则。 类似于 CSS、JS 和 DOM 提供的所有功能也应该构成一个额外的指令层。显然，把 CSS 代码从 HTML 文档里分离出来可以让 CSS 更好的工作。这个适用于 CSS 表示层的结论同样适用于 JS 行为层。 分离 JS类似于使用 style 属性。如果我们使用一个“挂钩”，就像 CSS 机制中的 class 或 id 属性那样，把 JS 代码调用行为与 HTML 文档的结构和内容分离开，网页就会健壮的多。 123456789var links = document.getElementsByTagName('a');for(var i=0; i&lt;links.length; i++) &#123; if (links[i].getAttribute('class') == 'popup')&#123; links[i].onclick = function()&#123; popUp(this.getAttribute('href')); return false; &#125; &#125;&#125; 以上代码将把调用 popUp() 函数的 onclick 事件添加到有关的链接上。只要把它们存入一个外部的 JS 文件，就等于是把这些操作从 HTML 文档里分离出来了。而这就是“分离 JS” 的含义。 但是，含有一个问题需要解决：如果这段代码存入到外部 JS 文件，他们将无法正常运行。因为这段代码的第一行代码。 这条语句将在 JS 文件被加载时立刻执行。如果 JS 文件位于文档底部，就不能保证哪个文件最先加载结束，因为脚本加载时文档不完整，所以模型也不完整。没有完整的 DOM ，getElementsByTagName 就不能正常工作。 必须让这些代码在 HTML 文档全部加在到浏览器之后立马开始执行。文档将被加载到一个浏览器窗口里， documen 对象又是 window 对象的一个属性。当 window 对象触发 onload事件时，document 对象已经存在。 1234567891011121314151617window.onload = prepareLinks;function prepareLinks()&#123; var links = document.getElementsByTagName('a'); for(var i=0; i&lt;links.length; i++) &#123; if (links[i].getAttribute('class') == 'popup')&#123; links[i].onclick = function()&#123; popUp(this.getAttribute('href')); return false; &#125; &#125; &#125;&#125;function popUp(winURL)&#123; window.opwn(winURL,\"popUp\",\"width=320,heigth=480\");&#125;","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ijiangnanbei.com/tags/性能优化/"}]},{"title":"DOM编程艺术：平稳退化","date":"2017-06-26T12:14:57.000Z","path":"2017/06/26/编程艺术：平稳退化/","text":"质疑一切不管你想通过 JS 改变网页的哪个行为，都必须三思而后行。首先要确认：为这个网页增加这种额外的行为是否有必要？弹出广告窗口和内容覆盖是一个典型的滥用 JS 的例子。 如果要使用 JS，就要确认：这么做会对用户的浏览体验产生怎样的影响？还有个更重要的问题：如果用户的浏览器不支持 JS 该怎么办？ 平稳退化记住，网站的访问者完全有可能使用的是不支持 JS 的浏览器，还有一种可能是虽然浏览器支持 JS，但用户已经禁用它了。如果没有考虑到这种情况，人们在访问你的网站的时候就会遇到各种各样的麻烦。 如果正确的使用了 JS 脚本，就可以让访问者在他们的浏览器不支持 JS 的情况下仍能顺利的浏览你的网站。这就是所谓的平稳退化，就是说，虽然某些功能无法使用，但最基本的操作仍然能顺利完成。 弹出窗口的使用应该只在绝对必要的情况下才使用弹出窗口，因为这将牵涉到网页的可访问性问题，例如，用户使用的屏幕读取软件无法向用户说明弹出了窗口。因此，如果网页上的某个链接将弹出窗口，最好在这个链接本身的文字中予以说明。 实例：在新窗口打开链接123function popUp(winURL)&#123; window.open(winURL,\"popUp\",\"width=320,height=480\");&#125; open() 方法是使用 BOM 的一个好案例，它的功能对文档的内容也无任何影响，这个方法只与浏览器环境有关。 这个函数将打开一个 320 像素宽、480像素高的新窗口“popUp”。因为我在这个函数里已经为新的窗口命名，所以当把新的 URL 地址传递给此函数时，这个函数将把心窗口里的现有文档替换为新 URL 地址处的文档，而不是再去创建一个新窗口。 “javascript:”伪协议调用 popUp() 函数的一个方法是使用伪协议。伪协议是一种非标准化的协议。“javascript:”伪协议让我们通过一个连接来调用 JS 函数。 下面是“javascript:”伪协议调用 popUp() 的具体做法：1&lt;a href=\"javascript:popUp('http://www.example.com/'):\"&gt;example&lt;/a&gt; 这条语句在支持 “javascript:”伪协议的浏览器中正常运行，较老的浏览器会去尝试打开那个连接，但是会失败，支持这种协议但是禁用了 JS 功能的浏览器会什么也不做。 总之，在 HTML 文档里通过 “javascript:” 伪协议调用 JS 代码的做法非常不好。 内嵌的事件处理函数1&lt;a href=\"#\" onclick=\"popUp('http://www.example.com/'); return false;\"&gt;example&lt;/a&gt; 因为上面这条语句使用了 return false 语句，所以这个链接并不会被真正的打开，“#”符号是一个仅供内部文档使用的链接记号。在某些浏览器里，“#”链接指向当前文档的开头。把 href 的属性设置为 “#” 只是为了创建一个空链接。实际工作全部由 onclick 属性负责完成。 很遗憾，这个技巧与使用“javascript:” 伪协议调用 JS 代码的做法同样糟糕，因为他们都不能平稳退化。如果用户已经禁用了浏览器的 JS 功能，这样的链接将毫无用处。 谁关心这个？你或许会疑惑，让那些不支持或者禁用了 JS 功能的浏览器也能顺利的访问你的网站真的那么重要吗？ 如果你的用户是一个搜索机器人。搜索机器人是一种自动化程序，他们浏览 web 的目的是为了把各种网页添加到搜索引擎的数据库里。各大搜索引擎都有类似的程序。目前，只有极少数搜索引擎机器人能够理解 JS 代码。所以，如果你的 JS 网页不能平稳退化，他们在搜索引擎上的排名就可能大受损害。 具体到 popUp() 函数，为其中的 JS 代码预留出退路其实很简单：在链接里把 href 属性设置为真实存在的 URL 地址，让它成为一个有效的链接： 1&lt;a href=\"http://www.example.com/\" onclick=\"popUp(this.href);return false;\"&gt;example&lt;/a&gt; 所以，在把 href属性设置为真实才在的 URL 地址后，即使 JS 已经被禁用或者遇到了搜索机，这个链接也是可用的。虽然这个链接再功能上打了点折扣，因为他没有打开一个新的窗口，但是它并没有彻底失效。这是一个经典的平稳退化的例子。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ijiangnanbei.com/tags/性能优化/"}]},{"title":"《DOM 编程艺术 Demos》","date":"2017-06-26T11:54:35.000Z","path":"2017/06/26/《DOM-编程艺术-Demos》/","text":"案例研究：JS图片库","tags":[{"name":"Demo","slug":"Demo","permalink":"http://ijiangnanbei.com/tags/Demo/"}]},{"title":"阻止默认行为及其实现原理","date":"2017-06-26T10:48:11.000Z","path":"2017/06/26/阻止默认行为及其实现原理/","text":"阻止默认行为1&lt;a href=\"images/fireworks.gif\" target=\"_self\" onclick=\"showPic(this) ; return false;\" title=\"A fireworks display\"; &gt;Fireworks&lt;/a&gt; 此时这个链接有两个行为，一个是执行函数 showPic() 另一个是链接的默认行为，由于我们要执行的是 showPic()， 所以我们使用 return false 阻止连接的默认行为。 实现原理在给某个元素添加了事件处理函数之后，一旦事件发生，相应的 js 代码就会得到执行。被调用的 js 代码可以返回一个值，这个值将传递给那个事件处理函数。 例如，我们可以给某个链接添加一个 onclick 事件处理函数，并让这个处理函数所触发的 js 代码返回布尔值 true 或 false，如果那段 js 代码返回的是 true，onclick 事件处理函数就认为“这个链接被点击了”；反之，如果返回的是 false ，onclick 事件处理函数就会认为这个链接没有被点击。","tags":[{"name":"JS","slug":"JS","permalink":"http://ijiangnanbei.com/tags/JS/"}]},{"title":"JS 初级知识点总结","date":"2017-06-26T08:17:42.000Z","path":"2017/06/26/JS-基础知识点总结/","text":"宿主对象可以在脚本里使用一些已经预先定义好的其他对象。这些对象不是由 js 语言本身而是由它的运行环境提供的。具体到 web 应用，这个环境就是浏览器。有浏览器提供的预定义对象被称为宿主对象。 宿主对象包括 From、Image、Element 等，我们可以通过这些对象获得关于网页上的表单、图像和各种表单元素信息。其中 document 宿主对象可以用来获取网页上任何一个元素的信息。 两种方法设置元素的属性12345//第一种方法element.value = 'content';//第二种方法element.setAttribute('value','content'); 第二种方法比较好，起码你不用去记忆哪些元素的哪些属性可以用 DOM 之前的哪些方法去设置。虽然哪些老办法可以毫无问题的对文档里的图片、表单和其他的一些元素的属性进行设置，但第二种方法的优势在于他可以修改文档中任何一个元素的任何一个属性。 第二种方法法的另一个优势是可移植性更好。那些老方法只适用于 web 文档，DOM 则适用于任何一种标记语言。 第二种方法即 DOM 方法，是一种适用于多种环境和多种程序设计语言的通用 API。如果你想把你学到的 DOM 技巧运用在 web 浏览器以外的应用环境里，严格遵守“第一级 DOM ”能够让你避免与兼容性有关的任何问题。 chileNodes 属性chileNodes 返回的数组包含所有类型的节点，而不仅仅是元素节点。事实上，文档里几乎每一样东西都是一个节点，甚至连空格和换行符都会被解释为节点，而且它们也全都包含在 chileNodes 属性所返回的数组当中。 nodeType 属性nodeType 总共有 12 中可取的值，但其中仅有三种具有实用价值。 1.元素节点的 nodeType 属性值是12.属性节点的 nodeType 属性值是23.文本节点的 nodeType 属性值是3 这意味着，可以让函数值对特定类型的节点进行处理。 获取 p 标签内部的值123456&lt;p id=\"description\"&gt; message &lt;/p&gt;var desc = document.getElementById(\"description\");alert(desc.nodeValue);//nullalert(desc.childNodes[0].nodeValue);//message 注意，包含在 p 元素里面的文本是另一个节点，它是 p 元素的第一个子节点。","tags":[{"name":"JS","slug":"JS","permalink":"http://ijiangnanbei.com/tags/JS/"}]},{"title":"ie 兼容性问题","date":"2017-06-26T00:25:40.000Z","path":"2017/06/26/ie-兼容性问题/","text":"1.IE6 / IE7 不支持块属性标签的 inline-block","tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://ijiangnanbei.com/tags/前端开发/"}]},{"title":"CSS 清浮动详解","date":"2017-06-26T00:14:06.000Z","path":"2017/06/26/CSS-清浮动详解/","text":"什么是浮动？使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的元素停下来。（脱离文档流：此时浮动元素在文档中不占位置，飘了起来） 浮动的特征1.块元素在一行显示2.内联元素支持宽高3.默认内容撑开宽度4.脱离文档流5.提升层级半层（只能够放元素本身，这个元素里的内容会被挤出来） 清除浮动的方法after 伪类清浮动（主流方法）给浮动元素的父级添加12.clear&#123;*zoom:1&#125;.clear:after&#123;content:'';display:block;clear:both;&#125; overflow:hidden/auto 清除浮动 给父级元素添加问题：需要配合宽度或者 zoom:1 兼容 IE6 给父级元素加高问题：扩展性不好 父级浮动问题：页面中所有的元素都加浮动，margin 左右自动失效 给父级加 inline-block问题：margin 左右都失效 空标签请浮动12345//在浮动元素下添加&lt;div class=\"clear\"&gt;&lt;/div&gt;//然后设置样式为.clear&#123;height:0;font-size:0;clear:both;&#125; 问题：在 IE6 下高度小于 19px 的元素，会被当做 19px 来处理，可以使用 font-size:0; 来解决，但是只能处理最小 2px 的高度，再小就处理不了了。 br 清浮动12//在浮动元素下加&lt;br clear=\"all\"/&gt; 问题：不符合工作中结构、行为、样式分离的要求","tags":[{"name":"CSS","slug":"CSS","permalink":"http://ijiangnanbei.com/tags/CSS/"}]},{"title":"o(1) 时间内删除链表节点","date":"2017-06-26T00:00:11.000Z","path":"2017/06/26/o-1-时间内删除链表节点/","text":"思路：打破常规思维，当我们想删除一个节点时，并不一定要删除这个节点本身。可以先把下一个节点的内容复制出来覆盖被删除节点的内容，然后把下一个节点删除。 比如说，我们要删除节点 i，先把 i 的下一个节点 j 的内容复制到 i，然后把 i 的指针指向节点 j 的下一个节点，此时再删除节点 j，其效果刚好是把节点 i 删除了。 上述思路还有一个问题，如果要删除的节点位于链表的尾部，那么他就没有下一个节点，怎么办？ 我们仍然从链表的头结点开始，顺序遍历得到该节点的前序节点，并完成删除操作。最后需要注意的是，如果链表中只有一个节点，而我们有需要删除链表的头结点，也就是尾节点，此时在我们删除节点之后，还需要把链表的头结点设置为 null。 同时，你也要注意思维的全面性，即使你想到删除下一个节点这个办法，也未必能通过这轮面试，你应该要全面的考虑到删除的节点位于链表的尾部及输入得来链表只有一个节点这些特殊情况。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode&#123; int m_nValue; ListNode* m_pNext;&#125;;// ====================链表操作====================ListNode* CreateListNode(int value)&#123; ListNode* pNode = new ListNode(); pNode-&gt;m_nValue = value; pNode-&gt;m_pNext = NULL; return pNode;&#125;void ConnectListNodes(ListNode* pCurrent, ListNode* pNext)&#123; if(pCurrent == NULL) &#123; printf(\"Error to connect two nodes.\\n\"); exit(1); &#125; pCurrent-&gt;m_pNext = pNext;&#125;void PrintListNode(ListNode* pNode)&#123; if(pNode == NULL) &#123; printf(\"The node is NULL\\n\"); &#125; else &#123; printf(\"The key in node is %d.\\n\", pNode-&gt;m_nValue); &#125;&#125;void PrintList(ListNode* pHead)&#123; printf(\"PrintList starts.\\n\"); ListNode* pNode = pHead; while(pNode != NULL) &#123; printf(\"%d\\t\", pNode-&gt;m_nValue); pNode = pNode-&gt;m_pNext; &#125; printf(\"\\nPrintList ends.\\n\");&#125;void DestroyList(ListNode* pHead)&#123; ListNode* pNode = pHead; while(pNode != NULL) &#123; pHead = pHead-&gt;m_pNext; delete pNode; pNode = pHead; &#125;&#125;void AddToTail(ListNode** pHead, int value)&#123; ListNode* pNew = new ListNode(); pNew-&gt;m_nValue = value; pNew-&gt;m_pNext = NULL; if(*pHead == NULL) &#123; *pHead = pNew; &#125; else &#123; ListNode* pNode = *pHead; while(pNode-&gt;m_pNext != NULL) pNode = pNode-&gt;m_pNext; pNode-&gt;m_pNext = pNew; &#125;&#125;void RemoveNode(ListNode** pHead, int value)&#123; if(pHead == NULL || *pHead == NULL) return; ListNode* pToBeDeleted = NULL; if((*pHead)-&gt;m_nValue == value) &#123; pToBeDeleted = *pHead; *pHead = (*pHead)-&gt;m_pNext; &#125; else &#123; ListNode* pNode = *pHead; while(pNode-&gt;m_pNext != NULL &amp;&amp; pNode-&gt;m_pNext-&gt;m_nValue != value) pNode = pNode-&gt;m_pNext; if(pNode-&gt;m_pNext != NULL &amp;&amp; pNode-&gt;m_pNext-&gt;m_nValue == value) &#123; pToBeDeleted = pNode-&gt;m_pNext; pNode-&gt;m_pNext = pNode-&gt;m_pNext-&gt;m_pNext; &#125; &#125; if(pToBeDeleted != NULL) &#123; delete pToBeDeleted; pToBeDeleted = NULL; &#125;&#125;// ====================算法实现====================void DeleteNode(ListNode ** pListHead,ListNode * pToBeDeleted)&#123; if(!pListHead || !pToBeDeleted) return; //要删除的节点不是尾节点 if(pToBeDeleted-&gt;m_pNext != NULL) &#123; ListNode * pNext = pToBeDeleted-&gt;m_pNext; pToBeDeleted-&gt;m_nValue = pNext-&gt;m_nValue; pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext; delete pNext; pNext = NULL; &#125; //链表只有一个节点，删除头结点（也是尾节点） else if(*pListHead == pToBeDeleted) &#123; delete pToBeDeleted; pToBeDeleted = NULL; *pListHead = NULL; &#125; //链表中有多个节点，删除尾节点 else &#123; ListNode * pNode = *pListHead; while(pNode-&gt;m_pNext != pToBeDeleted) pNode = pNode-&gt;m_pNext; pNode-&gt;m_pNext = NULL; delete pToBeDeleted; pToBeDeleted = NULL; &#125;&#125;// ====================测试代码====================void Test(ListNode* pListHead, ListNode* pNode)&#123; printf(\"The original list is: \\n\"); PrintList(pListHead); printf(\"The node to be deleted is: \\n\"); PrintListNode(pNode); DeleteNode(&amp;pListHead, pNode); printf(\"The result list is: \\n\"); PrintList(pListHead);&#125;// 链表中有多个结点，删除中间的结点void Test1()&#123; ListNode* pNode1 = CreateListNode(1); ListNode* pNode2 = CreateListNode(2); ListNode* pNode3 = CreateListNode(3); ListNode* pNode4 = CreateListNode(4); ListNode* pNode5 = CreateListNode(5); ConnectListNodes(pNode1, pNode2); ConnectListNodes(pNode2, pNode3); ConnectListNodes(pNode3, pNode4); ConnectListNodes(pNode4, pNode5); Test(pNode1, pNode3); DestroyList(pNode1);&#125;// 链表中有多个结点，删除尾结点void Test2()&#123; ListNode* pNode1 = CreateListNode(1); ListNode* pNode2 = CreateListNode(2); ListNode* pNode3 = CreateListNode(3); ListNode* pNode4 = CreateListNode(4); ListNode* pNode5 = CreateListNode(5); ConnectListNodes(pNode1, pNode2); ConnectListNodes(pNode2, pNode3); ConnectListNodes(pNode3, pNode4); ConnectListNodes(pNode4, pNode5); Test(pNode1, pNode5); DestroyList(pNode1);&#125;// 链表中有多个结点，删除头结点void Test3()&#123; ListNode* pNode1 = CreateListNode(1); ListNode* pNode2 = CreateListNode(2); ListNode* pNode3 = CreateListNode(3); ListNode* pNode4 = CreateListNode(4); ListNode* pNode5 = CreateListNode(5); ConnectListNodes(pNode1, pNode2); ConnectListNodes(pNode2, pNode3); ConnectListNodes(pNode3, pNode4); ConnectListNodes(pNode4, pNode5); Test(pNode1, pNode1); DestroyList(pNode1);&#125;// 链表中只有一个结点，删除头结点void Test4()&#123; ListNode* pNode1 = CreateListNode(1); Test(pNode1, pNode1);&#125;// 链表为空void Test5()&#123; Test(NULL, NULL);&#125;int main( )&#123; Test1(); Test2(); Test3(); Test4(); Test5(); return 0;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"CSS 控制图片和文字在同一行显示且对齐","date":"2017-06-25T15:11:50.000Z","path":"2017/06/25/CSS-控制图片和文字在同一行显示且对齐/","text":"在css中给div添加上“vertical-align:middle”属性12345678910#box *&#123; vertical-align:middle; /* 居中对齐， */ font-size:14px; &#125; &lt;div id=\"box\"&gt; &lt;img src=\"xxx.jpg\"&gt; &lt;img src=\"xxx.jpg\"&gt; &lt;a href=\"#\"&gt;使用 vertical-align&lt;/a&gt; &lt;/div&gt; 把图片设置为背景图片1234567891011#box &#123; background:url(1.jpg) no-repeat left center; &#125; #bg&#123; font-size:14px; padding-left:50px;&#125; &lt;div id=\"box\"&gt; &lt;div id=\"bg\"&gt;&lt;a href=\"#\"&gt;把图片设置为背景图&lt;/a&gt;&lt;/div&gt; &lt;/div&gt;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://ijiangnanbei.com/tags/CSS/"}]},{"title":"如何找到你的人生目标？","date":"2017-06-21T16:00:05.000Z","path":"2017/06/22/如何找到你的人生目标？/","text":"TED Adam Leipzing ： 如何找到人生的目标？ 那些知道自己人生目标的人，知道这五件事： 他们是谁？他们做了什么？他们为谁而坐？那些人想要什么？需要什么？他们可以从中得到什么？结果会怎样改变？ 这听起来很难吗？事实上，你很容易就能知道自己生活的目标。很多人用尽一生的时间，寻找他们人生的目标，但是如果你只是照着计划表在考核你的人生，那不算是真正的活着。 你是谁？恩，我是王震。 你在做什么，如果你想到了很多自己喜欢的事情，那就问自己一个问题，现在哪一件事情，你自己感觉最有能力可以传授给别人的？我在做技术的同时也时刻提升自己对产品和商业的感知。 你为谁而做，想想你是为谁而做，在你脑子里想想他们的样子。我为了我的目标顾客而做，在获得商业上的成功之后，我会为了我想要去改变那一部分人而做。 他们想要什么需要什么，他们想要从你身上得到什么？他们来找你是因为你可以给他们东西。我想让他们得到更好的服务，当然我最终的目的是改变他们的思想，提升他们的认知。还有最后他们会变得如何？你的给予会让他们如何改变或者转化？他们会得到更好的产品，新的思想。 这五件事情是你必须知道的，也就是你的人生目标是什么，只有两个和你自己有关，另外三个和其他人有关，这个公式会驱使你照顾到除你之外的人们。那些有着人生目标的人清楚地知道自己为谁而做，那些人要什么，他们最后会如何改变。 你可能会注意到，无论哪个领域的成功人士都很注重，如何服务他们的对象，而不是他们自己，那些更快乐的人专注在让别人快乐，这些事情使他们感觉备受关心和照顾。生活告诉我们，如果你让别人开心，我们也会被照顾的很好。 与人谈话，其中最困难的一件事情就是，当你第一次见一个人，他可能问你这个问题，“你现在在做什么？”，当有人问你这个问题的时候，你可以这样做：只要说出你目前在做的事情就行了。比如说，你可以说“我想把这个世界变得更美好，哪怕一点点”。如此，你所说的那段话，将成为你个人的电梯演说，它会开启一个新的对话，因为你刚才的谈话对象，一定会问你：“你打算怎么改变这个世界？”，然后你接着回答他们，分享他们你的生活目标，然后你要告诉他们，他们也可以发掘自己生命的目的。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"}]},{"title":"数值的整数次方","date":"2017-06-21T11:18:06.000Z","path":"2017/06/21/数值的整数次方/","text":"题目： 实现函数double Power(double base, int exponent) 求 base 的 exponent 次方。不得使用库函数，同时不需要考虑大数问题。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;//我们使用全局变量来标识是否出错，如果出错了，则返回truebool g_InvalidInput = false;bool equal(double num1, double num2);double PowerWithUnsignedExponent(double base, unsigned int exponent); double Power(double base, int exponent)&#123; g_InvalidInput = false; if(equal(base, 0.0) &amp;&amp; exponent &lt; 0) &#123; g_InvalidInput = true; return 0.0; &#125; unsigned int absExponent = (unsigned int)(exponent); if(exponent &lt; 0) absExponent = (unsigned int)(-exponent); double result = PowerWithUnsignedExponent(base, absExponent); if(exponent &lt; 0) result = 1.0 / result; return result;&#125; double PowerWithUnsignedExponent(double base, unsigned int exponent)&#123; if(exponent == 0) return 1; if(exponent == 1) return base; //这里我们使用右移运算符代替了除以2，使用递归的方法来达到快速计算的目的 double result = PowerWithUnsignedExponent(base, exponent &gt;&gt; 1); result *= result; //这里我们使用了“与”运算代替求余运算来判断一个数时奇数还是偶数 if((exponent &amp; 0x1) == 1) result *= base; return result;&#125;bool equal(double num1, double num2)&#123; if((num1 - num2 &gt; -0.0000001) &amp;&amp; (num1 - num2 &lt; 0.0000001)) return true; else return false;&#125;// ====================测试代码====================void Test(double base, int exponent, double expectedResult, bool expectedFlag)&#123; double result = Power(base, exponent); if(abs(result - expectedResult) &lt; 0.00000001 &amp;&amp; g_InvalidInput == expectedFlag) cout &lt;&lt; \"Test passed.\\n\" &lt;&lt; endl; else cout &lt;&lt; \"Test failed.\\n\" &lt;&lt; endl;&#125;int main()&#123; // 底数、指数都为正数 cout &lt;&lt; \"Test1 begins.\\n\" &lt;&lt; endl; Test(2, 3, 8, false); // // 底数为负数、指数为正数 cout &lt;&lt; \"Test2 begins.\\n\" &lt;&lt; endl; Test(-2, 3, -8, false); // // 指数为负数 cout &lt;&lt; \"Test3 begins.\\n\" &lt;&lt; endl; Test(2, -3, 0.125, false); // // 指数为0 cout &lt;&lt; \"Test4 begins.\\n\" &lt;&lt; endl; Test(2, 0, 1, false); // // 底数、指数都为0 cout &lt;&lt; \"Test5 begins.\\n\" &lt;&lt; endl; Test(0, 0, 1, false); // // 底数为0、指数为正数 cout &lt;&lt; \"Test6 begins.\\n\" &lt;&lt; endl; Test(0, 4, 0, false); // // 底数为0、指数为负数 cout &lt;&lt; \"Test7 begins.\\n\" &lt;&lt; endl; Test(0, -4, 0, true); return 0;&#125; Tips： 1.由于计算机表示小数都有误差，我们不能直接用等号判断两个小数是否相等，如果两个小数的差的绝对值很小，比如小于 0.0000001，就可以认为他们相等。 2.用右移运算代替除法运算 3.用位“与”运算代替求余运算 4.在面试的过程中你可以主动提示这些小细节，让他知道我们对编程的细节很重视。","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"},{"name":"Confusing","slug":"Confusing","permalink":"http://ijiangnanbei.com/tags/Confusing/"}]},{"title":"什么样的人最可怕？","date":"2017-06-21T10:00:09.000Z","path":"2017/06/21/什么样的人最可怕？/","text":"什么样的人才是最可怕的呢？在我看来是具有“自我进化”和成长型思维的人才是最可怕的。 什么是“自我进化”？就是说这个人可以像一个生物一样，不管外部环境如果变化我都能及时的进化出我自己的一套“生态系统”，来适应外界任何的变化，这就是“自我进化”。 你可能会问，我长这么大怎么从来没有感受到“自我进化”，你怎么判断一个人有没有自我进化的能力呢？这个答案很简单，对于一般人，我会告诉他，如果你今天做错了一件事，在你意识到自己做错了之后你及时把它改正了，这就是你的“自我进化”。比如说有一天你忽然意识到，疯狂的追剧并不会让我变得更好，因为别人的错误惩罚自己其实是没有必要的，“不合群”其实也没什么关系… 但现实是这样的一般人占了我们生活中的大多数，能够做到“自我变化”的人已经屈指可数，更不要说“自我进化”了。 对于世道人心有起码心智的人，我会告诉他，所谓“自我进化”就是从你开始对这个世界有最起码的认知，到现在这个时刻你经历过几次“王阳明时刻”。所谓“王阳明时刻”，就是你突然意识到，我要想过的更好，我要达到更高的人格和事业目标，那不是向外求的，你要学会向内求，你自己才是一切问题的根源。想要感受的更深刻一点的话，可以看一下这句话：“未经长夜痛哭者，不足以语人生”。 从开始“懂事”到现在，我经历过三次“王阳明时刻”。第一次来自我的启蒙老师，这个改变了我一生的男人。就是他让我在 18 岁时对世道人心已经有了起码的认识，他告诉我：“你的人生可以很精彩，你可以这样度过”。 什么叫成长型思维？这个我说过很多次，听到的人很多，做到的人没有。至少目前我没有看见过。 所谓成长型思维，通俗一点的解释就是，你不要想着今天你做了多少事情看看明天会发生什么，你要学会拉长一个时间维度，跳到一个大的空间尺度，看看你持续做这件事，三年之后会发生什么，五年之后会发生什么，十年之后会发生什么，他会逐渐向前，争取未来。而不是说，保持你基于现有认知对自己的判断，从而保持一个僵化的思维，固守对自己才智的认知。 具有成长型思维的人的一个最主要的特征就是，注重过程而不是结果。一个具有成长型思维的人在一次考试失败之后，他不会沮丧，他会分析自己在备考的过程中所没有关注到的点，最重要的是他会非常享受这个过程。而不具备成长型思维的人，一次考试的失败，就会让他对自己造成否定的认知，认为自己也就这个水平了，甚至为了下次考试能够考好，他会冒险作弊。 如果你具有“自我进化”的能力和成长型思维，不要着急，时间会给你所有你想要的。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"逆向选择策略","date":"2017-06-20T15:30:18.000Z","path":"2017/06/20/逆向选择/","text":"清华总裁班：邹亚生 逆向选择策略 什么叫逆向选择？把这个概念放到企业里面就是劣质商品能够把优质商品驱逐出去，你可能会想这怎么可能呢？ 比如说，用北京的一个市场潘家园，他是北京的一个古董市场，最初建立的时候在这个市场上真品还是比较多的，今天你如果去潘家园，几乎无一例外的是赝品。这个故事的发生过程其实就是一个博弈的过程，那就是最初我们认为这个市场上的东西真品比较多，那么我作为一个买家到了这个市场上，这个市场上既然是真品，那我给你的价格就是真品的价格，但是呢，慢慢地在这个市场上出现了一些赝品，那么这个赝品我去买的时候你是把它当做真品卖给我的，那就会有一批上当的人，然后他就发生了怀疑，那么这个人下一次到这个市场上去买的时候，无论这个东西是真品还是赝品，那我再给它报价的时候，我至少不会再报一个真品的价格，这个时候我报的价格就要比真品的价格要便宜，那这个时候，卖真品的人把自己的产品拿到这个市场上来但是却卖不了一个真品的价格，那下次这个人还会带着真品过来吗？经过这几个来回，最终这个市场上剩下的就全是赝品，这就是劣质品把优质品从这个市场上驱逐出去了。 当然在这个驱逐的过程中最核心的问题仍然是信息不对称，因为这个东西到底是真品还是赝品，如果你没有相当的专业知识你是没有办法甄选出来的。 类似于这样的逆向选择经常会出现在我们企业的其他方面，这个词最早出现是因为保险公司。保险公司在制定一个保单的价格的时候，是按所有人群的平均价格给的，但是你们仔细想想谁最愿意到保险公司去主动地买这个险？至少是有着潜在风险大的人才会去买，但是身体好的人是不愿意去买的，因为这样他就替别人承了风险，那这样一来，保险公司就发生了逆向选择，也就是说保险公司如果没有建立起来一个良好的制度，那么所有买这个险的人是高风险的人，所有没有买这个保险的人是低风险的人，那么从保险公司的角度，我是最想把这个保险卖给那些不会得病的人，最不想卖给的就是那些会得病的人，但是从市场的选择来讲，是那些得病的人买了险而不得病的人不买这个险，这个时候对保险公司来讲就出现了逆向选择，劣质客户把优质客户驱逐出去了。同样，银行贷款也是这个道理。 所以为了避免出现逆向选择，保险公司和银行制定了相应的策略。保险公司的策略是什么呢？既然你是来买健康险的，你先到医院做一个体检。或者说保险公司采取一个更简单的办法，这个险种我就不对个人卖，我不卖个人险，卖团险，这个时候团体里面不生病的人把那些生病的人的损失就担起来了。 而银行采取的手段则是，凡事要到我这里贷款的，首先要提供三张报表，资产负债表，损益表和合并报表。但是有些中小企业这个时候给出了伪造的报表，那这个时候银行说，行，我不看你的三张报表了，但是我还是要看你的表，我看你的水表，我看你的电表，我看你的海关报表，这三个表不是你自己出的，这三个表是由公共机构出的，我认为这三个表是真的。逆向选择在我们的生活中也随处可见。比如说为什么你可以随便挑西瓜而不可以随便挑西红柿（如果你可以随便挑，那一定是分类过的了）。你之所以可以挑西瓜，是因为对于绝大多数人来讲，你挑和不挑是一样的，他在定西瓜的价格的时候，它是按照平均价格定的，所以这个时候，无论你怎么挑，只要你是在不打开的情况下，那么它就是一个价，没问题。 关于逆向选择，我们这里还有一个企业的案例，说当一个企业财务出现困难的时候，到底应该怎么做？你是应该裁掉一部分人呢？还是跟所有的员工来声明目前公司遇到了困难，然后我们大家能不能共渡难关？当然共渡难关就意味着所有人都要降低你的待遇。 如果是你你会选择那个呢？正确的答案是裁人。为什么会是裁人呢？用我们逆向选择的方法来讲，如果你是共渡难关，就会出现逆向选择，共渡难关就意味着所有人都要把待遇降低，那这里面就会有一部分能干的并且工作业绩显著的人，他们的劳动积极性就受到了打击，进而离开这个公司，当这些人走了之后，他还要填进来新的人。这个时候你的工资水平比别人的低，那么这个时候能够接受你的这个工资水平的人一定是在其他地方找不到工作的人，所以来的人也都是饭桶，那么这么一来，留下来的饭桶和来的饭桶结合在一起，那就是饭桶加饭桶，所以这个公司最后就只有倒闭一条路。","tags":[{"name":"商业","slug":"商业","permalink":"http://ijiangnanbei.com/tags/商业/"}]},{"title":"Tab 导航","date":"2017-06-19T15:35:26.000Z","path":"2017/06/19/Tab-导航/","text":"读书笔记：《见微知著》 广义上，在页面上能够起到指示和引导作用的元素都可以称之为导航。它就像商场中的指示牌和城市旅游地图一样，能够告诉用户“我在哪里？”还有“我该怎么去想要去的地方？”，以引导用户更好地浏览网站内容。 导航也是对网站信息架构的一种反映，体现了网站内容的分类和组织方式。没有导航的内容就像一盘散沙，用户不容易找到所需要的内容，却很容易在网站上“迷路”，失去方向感，有时只能后退或者关闭页面才能退出，这会增加用户的挫折感。 网站页面上存在很多导航元素，引导用户浏览，包括主导航、辅助导航、网站地图、搜索区、Logo和快速入口等。Logo起着网站指明灯的作用，使用户始终可以通过单击Logo返回首页；搜索区也是导航中非常重要的一个辅助元素；快捷入口通常包括登录、注册、帮助、联系方式等常用信息，用户能够快速单击链接进入目标页面。这些元素虽然也都起着导航的作用。 全局导航，指的是在网站每个页面上始终保持同一位置的导航元素，常见的包括Tab导航、树状导航、鱼眼导航等不同的导航类型。 辅助导航包括主导航下的分类筛选、面包屑导航、推荐式导航、引导性导航等，虽然其位置没有全局导航那么显眼，但却在用户浏览过程中起着不可替代的作用。 网站地图指明了一个网站结构，集合了所有链接通道，能够让用户和网络蜘蛛更加清晰地了解网站的大致结构，也起到了对搜索引擎优化的目的。 Tab 导航目前国内大部分网站，包括门户网站、电子商务网站等都采用横向导航条，显示了网站的主要栏目。横向导航的缺点在于页面横向空间有限，因此为了保证各栏目间能够区分开，往往会使网站分类栏目的数量受到限制；还有当导航需要显示二级栏目时，简单的横向导航也很难满足需求。 当分类栏目过多的时候，横向空间放不下过多的栏目，因此演变出了门户类网站常用的多行导航栏。当导航中需要显示二级栏目时，简单的横向导航已经不能体现出网站的结构，Tab导航也就应运而生了。通过切换Tab页就能够呈现出该标签页对应的二级栏目。 Amazon（亚马逊）向来被认为是Tab导航的鼻祖。 在设计 Tab 导航时需要注意的问题： 1.突出当前 Tab 页，并且对一级分类与对应的二级分类使用相同的颜色，体现其相关性。2.各分类间保持适当的距离，体现出各栏目间的分隔，增加可辨识度。3.使用不同的颜色区分不同的 Tab，增加辨识度，至少区分开当前选中分类和未选中分类。4.不要在导航上放置过多的 Tab，更不要使用两行以上的 Tab 作为导航。Tab 过于拥挤会影响用户的定位和辨识。5.增加“My Store”等个性化功能，并且分析用户的行为轨迹，使内容更加符合用户需求。6.通过 “See More Stores”链接，隐藏重要性略低的分类，避免导航过于臃肿。7.标签色彩的使用要符合网站定位，不要过于夸张。","tags":[{"name":"设计","slug":"设计","permalink":"http://ijiangnanbei.com/tags/设计/"}]},{"title":"3种错误处理的方法","date":"2017-06-16T23:57:03.000Z","path":"2017/06/17/3种错误处理的方法/","text":"通常我们的有三种方式把错误信息传递给函数的调用者。 1.函数用返回值来告知调用者是否出错。这种方式最大的问题是使用不便，因为函数不能直接把计算结果通过返回值赋给其他变量，同时也不能把这个函数的计算结果直接作为参数传递给其他函数。 2.当发生错误时设置一个全局变量。此时我们可以在返回值中传递计算结果了。这种方法比第一种方法使用起来更加方便，因为调用者可以直接把返回值赋给其他变量或者作为参数传递给其他函数。 但是这个方法有个问题：调用者很容易就会忘记去检查全局变量，因此在调用出错的时候，忘记做相应的错误处理，从而留下安全隐患。 3.第三种方式就是异常。等函数运行出错的时候，我们就抛出一个异常，我们还可以根据不同的出错原因定义不同的异常类型。因此函数的调用者根据异常的类型就能知道出错的原因，从而做相应的处理。 另外，我们能够显示划分程序正常运行的代码块（try 模块）和异常处理的代码块（catch 模块），逻辑比较清晰。另外，当抛出异常的时候，程序的执行会打乱正常的顺序，对程序的性能有很大的影响。 方式 优点 缺点 返回值 和系统 API 一致 不能方便的使用计算结果 全局变量 能够方便的使用计算结果 用户可能会忘记检查全局变量 异常 可以为不同的出错原因定义不同的出错类型，逻辑清晰 有些语言不支持异常，抛出异常时对性能有负面影响 上述三种错误处理方式各有其优缺点。那么，面试的时候我们应该采取哪种方式呢？这要看面试官的要求。在听到面试官的题目之后，我们要尽快分析出可能存在哪些非法的输入，并和面试官讨论如何处理这些非法输入。","tags":[{"name":"编程","slug":"编程","permalink":"http://ijiangnanbei.com/tags/编程/"}]},{"title":"如何写出高质量的代码？","date":"2017-06-16T23:16:09.000Z","path":"2017/06/17/如何写出高质量的代码？/","text":"读书笔记：《剑指offer》 代码的规范性1.清晰地书写：绝大部分面试都是要求应聘者在白纸或者白板上书写，面试过程中减慢写字的速度，尽量把每个字母写清楚，书写清晰。 2.清晰地布局：如果布局不够清晰，缩进也不能体现出代码的逻辑性，面试官对这样的代码会头昏脑涨。 3.合理的命名：在书写代码的时候，用完整的英文单词组合命名变量和函数，比如函数需要传入一个二叉树的根节点作为参数，则可以把该参数命名为 BinaryTreeNode * pRoot，不要因为这样会多写几个字母而觉得麻烦。合理的命名应该一眼能看出变量函数的用途。 代码的完整性面试官会非常关注应聘者考虑问题是否周全，通过检查代码是否完整来考察应聘者的思维是否全面，通常会检查代码是否完成了基本功能，输入边界值是否能得到正确的输出，是否对各种不合规范的非法输入做出了合理的错误处理。 应聘者在写代码之前，首先要把可能的输入都想清楚，从而避免在程序中出现各种各样的质量漏洞。也就是说在编码之前要考虑单元测试。如果能够设计全面的单元测试用例并在代码中体现出来，那么写的代码自然也就是完整正确的了。通常我们可以从功能测试，边界测试和负面测试三方面设计测试用例，以确保代码完整性。 1.首先要考虑的是普通功能测试的测试用例。我们首先要保证写出的代码能够完成面试官的基本要求。比如面试题要求的功能是把字符串转换成整数，我们可以考虑输入字符串“123”来测试你的代码。这里要把零、整数和负数都考虑进去。 2.考虑功能测试的时候，我们要尽量突破常规思维的限制。比如面试题“打印从 1 到最大的 n 位数”，很多人觉得这很简单。最大的二位数是99，最大的三位数是 999，这些数字很容易就能算出来。但是最大的 n 位数都能用 int 型表示吗？超出 int 型的范围我们可以考虑 long long 类型，超出 long long 类型能够表示的范围呢？面试官是不是要求考虑任意大的数字？如果面试官确认题目要求的是任意大的数字，那么这个题目就是一个大数问题，此时我们需要特殊的数据结构来表示数字，比如用字符串或者数组来表示大的数字，以确保不会溢出。 3.其次需要考虑各种边界值的测试用例。很多时候我们的代码中都会有循环和递归。如果我们的代码是基于循环的，那么结束循环的边界条件是否正确？如果使递归，递归终止的边界值是否正确？这些都是边界测试时要考虑的用例。还是以字符串转换成整数的问题为例，我们写出的代码应该确保能够正确转换最大的正整数和最小的负整数。 4.最后还要考虑各种可能的错误的输入，也就是通常所说的负面测试的测试用例。我们写的函数除了要顺利的完成要求的功能之外，当输入不符合要求的时候还能作出合理的错误处理。在设计把字符串转换成整数的函数的时候，我们就要考虑当输入的字符串不是一个数字，比如“1a2b3c”，我们怎么告诉函数的调用者这个输入是非法的。 5.最后也是最重要的一点。在软件开发过程中，永远不变的就是需求一直会改变。如果我们在面试的时候写出的代码能够把将来需求可能的变化都考虑进去，在需求发生变化的时候能够尽量减少代码改动的风险，那我们就向面试官展示了自己的对程序可扩展性和可维护性的理解，通过面试就是水到渠成的事情了。","tags":[{"name":"编程","slug":"编程","permalink":"http://ijiangnanbei.com/tags/编程/"}]},{"title":"git 常用操作","date":"2017-06-16T07:26:54.000Z","path":"2017/06/16/git-常用操作/","text":"1.克隆仓库到本地：git clone [url]2.查看工作区和暂存区的状态：git status3.提交文件从工作区到暂存区：git add .4.提交文件从暂存区到版本库：git commit -m &quot;注释&quot;5.提交文件直接从工作区到版本库：git commit -a -m &quot;注释&quot;6.提交：git push7.查看提交历史：git log8.更新本地仓库 git pull origin master","tags":[{"name":"编程","slug":"编程","permalink":"http://ijiangnanbei.com/tags/编程/"}]},{"title":"如何写出简洁优美的 CSS Reset","date":"2017-06-15T06:02:15.000Z","path":"2017/06/15/如何写出简洁优美的-CSS-Reset/","text":"什么是 CSS resetCSS reset 的就是让各个浏览器的 CSS 样式有一个统一的基准，而这个基准更多的就是“清零”！ 如何写出简洁优美的CSS reset我们的 reset 应该根据自己的要求来书写。然而，目前的状态是（尤其一些中小型网站）， reset 代码直接拷贝过去，不做任何的思考。 你所不知的 reset1.div、li、还有像 form,img, input, button, textarea 这样子的表单元素标签是没有 margin 值和 padding 值的。2.dt 标签默认的 margin 和 padding 值就是 0。3.code 标签是个属于 inline 水平的元素，不存在 margin值和 padding 值。4.input元素有 padding 值 没有 margin 值5.fieldset, legend这两个90年代的标签使用概率不足1%，不需要拿来重置。6.在某些浏览器中，q 或者是 blockquote 前后会出现引号，该引号严重破换了美感，所以需要重置：12blockquote,q&#123;quotes:none;&#125;blockquote:before,blockquote:after,q:before,q:after&#123;content:'';content:none;&#125; 简洁的 reset 可以这样书写：123456789101112131415161718body, dl, dd, h1, h2, h3, h4, h5, h6, p, form&#123;margin:0;&#125; ol,ul&#123;margin:0; padding:0;&#125;table&#123;border-collapse:collapse;border-spacing:0;&#125;//对于具有边框的的元素，可以做如下处理fieldset,img&#123;border:0;&#125;abbr,acronym&#123;border:0;font-variant:normal;&#125;//上标，下标及 baseline 的重置sup,sub&#123;font-size:100%;vertical-align:baseline;&#125;//除了重置样式之外，清除浮动也很重要.clearfix:after&#123;content:\"\";display:block;height:0;clear:both;visibility:hidden;&#125;.clearfix&#123;display:inline-block;&#125;/*hides from ie-mac */*html .clearfix&#123;height:1%;&#125;.clearfix&#123;display:block;&#125;/* end hide form ie-mac */ reset 存在的问题css文件的大小显然，reset 平白无故的增加了 CSS 文件的大小，虽然，增加的大小可能有限，但是，要知道，即使 0.1 秒的载入时间差异也会影响互联网企业的收入的。 样式的重置许多的 CSS 样式要重写与重新覆盖，典型的多此一举。 CSS的渲染这可以说是最大的问题，样式无缘无故增加了很多的渲染，想想看，一个项目或是一个页面中有多少个 div 标签，居然使用div{margin:0; padding:0;} 当然，*{margin:0; padding:0;} 更是无法容忍的。 兼容 html5 的 Reset12345678910111213141516171819202122232425262728方案三html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video &#123; margin:0; padding:0; border:0; font-size:100%; font:inherit; vertical-align:baseline; outline:none; &#125;html &#123; height:101%; &#125; /* 总是显示滚动条 */body &#123; font-size:62.5%; line-height:1; font-family:Arial, Tahoma, Verdana, sans-serif; &#125;article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; display:block; &#125;img &#123; border:0; max-width:100%; &#125;a &#123; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;ol, ul &#123; list-style:none; &#125;blockquote, q &#123; quotes:none; &#125;blockquote:before, blockquote:after, q:before, q:after &#123; content:\"\"; content:none; &#125;strong &#123; font-weight:bold; &#125; input &#123; outline:none; &#125;table &#123; border-collapse:collapse; border-spacing:0; &#125; 小技巧12345678910111213141516/* 把斜体扶正 */em&#123;font-style: normal;&#125; /* 图片放在a链接里面外面肯定会有难看的边框，然后把它对齐 */img&#123;border: none;vertical-align: top;&#125;/* 消灭表格之间的间隙 */table&#123;border-collapse: collapse;&#125;/* 在chrome下选中，他会自动给你添加一个高亮显示我们要实现的话可以用js实现 */input,textarea&#123;outline: none;&#125;/* chrome 可以缩放输入框 */textarea&#123;resize: none;overflow: auto;&#125;body&#123;font-size: 12px;font-family: \"微软雅黑\";&#125; 少既是多最少的 CSS 代码，最少的渲染，最少的重置就是最好的 CSS 样式代码，这反应了您的 CSS 层次。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://ijiangnanbei.com/tags/CSS/"}]},{"title":"识破障眼法","date":"2017-06-14T15:41:51.000Z","path":"2017/06/14/识破障眼法/","text":"读书笔记：《世说新语》 继续谈说话技巧中的怎么”不说”，但是这个不说，除了借机会听、借机会学，更重要的是你要借机会分析那个说话的人，尤其是当你不说，他却一直说个不停，甚至抢你话的时候，你更得小心，因为他说话很可能是障眼法，把你的注意力分散，免得你发现他的弱点，甚至弊端。 房地产掮客小姐的技巧很简单，她一方面掠过房子的弱点，根本不提；一方面不断说话，把你的注意力带开。 知道了这一点，以后你买自己不熟悉的东西，除了少说话、多听、多比较，而且要在对方指东的时候，除了往东看，也好好往相反的西边看看；当他指着天花板滔滔不绝的时候，你千万小心地上。 而且无论买什么东西都如此。当你看上一块玉，那卖家指着那玉上的优点、特点，说得天花乱坠的时候，你千万小心，只怕优点之外，全是缺点，等你买回家才发现好多裂璺。上古董铺更得小心，如果他的光线特别昏暗，别以为古董铺因为古，所以应该点古董油灯，而要想想，会不会有些东西是见不得光的，光线一亮，他就露马腳了。 至于在办公室里。如果你是主管，当你叫一个职员进来问话，他不直接答，或答一半，忽然把话题岔开，好像另有急事向你报告，譬如你问他今天一共收了多少钱、出了几箱货的时候，他刚答一半，说收了五千多呢……突然话题一转，说：”对了！今天老王来找您……”这时候你也得小心，会不会因为那人心里有鬼，怕你发觉，于是主动把话题带开。 在心理学上早发现人们会这样表现，连你的子女或另一半，当他们突然多话，而且常常抢着说，或一进门就主动找话题的时候，都有可能是声东击西。 至于当你自己是小职员的时候，更得以此为戒。你千万要避免在主管的话题之外找话题。尤其不能抢话，把话题带开。就算你能干、口才好，又有事情急着想报告，也要懂得忍，等主管的问话告一段落，或会议讨论的事情告一段落之后再说，否则不但会显得你毛躁，而且令人起疑，你言词闪烁是不是有什么心虚的事。 就算你心里没鬼，也不能喋喋不休。你想嘛，“喋喋不休，言不及义”怎么比得上“不鸣则已，一鸣惊人”。","tags":[{"name":"貌似有知识","slug":"貌似有知识","permalink":"http://ijiangnanbei.com/tags/貌似有知识/"}]},{"title":"弹出窗口屏蔽程序","date":"2017-06-13T15:59:35.000Z","path":"2017/06/13/弹出窗口屏蔽程序/","text":"大多数浏览器都内置有弹出窗口屏蔽程序，而没有内置此类程序的浏览器，也可以安装带有内置屏蔽程序的实用工具。于是，在弹出窗口被屏蔽时，就应该考虑两种可能性。如果是浏览器内置的屏蔽程序阻止的窗口弹出，那么 window.open() 很可能会返回 null。此时，只要检测这个返回值就可以确定弹出的窗口是否被屏蔽了。 如果是浏览器扩展或其他程序阻止的弹出窗口，那么 window.open() 通常会抛出一个错误。因此，要想准确的检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对 window.open() 的调用封装在一个 try-catch 块中，如下所示： 1234567891011121314var blocked = false;try &#123; var wroxWin = window.open('www.ijiangnanbei.com','_blank'); if(wroxWin == null) &#123; blocked = true; &#125;&#125; catch (ex) &#123; blocked = true;&#125;if(blocked) &#123; alert('the popup was blocked!\");&#125;","tags":[{"name":"BOM","slug":"BOM","permalink":"http://ijiangnanbei.com/tags/BOM/"}]},{"title":"沉默是金","date":"2017-06-13T15:46:10.000Z","path":"2017/06/13/沉默是金-1/","text":"读书笔记：《世说新语》 沉默，不出声音，有时候对讲话的人，要比你跟他辩论，来得更有压力。因为他抓不住你，不知道你怎么想，他好像一颗颗石子儿往洞里扔，下去，连一点回音都没有，他能不紧张吗？ 当你听说一个人深沉的时候，眼前很可能浮现一个”惜话如金、莫测高深”的画面。 “莫测高深”，正是你不说话的好处。当别人说，你只冷冷地听，除非你是听长官训话。假使两个人平等，你不讲话，就显得莫测高深，成了”他在明处，你在暗处。” 一个会说话的人，先要懂得什么时候不说，尤其当你没把握的时候，可以让对方先说，从对方的话里探虚实，甚至用这个方法偷偷学。 对！偷偷学！举个例子，你要买老式的家具，半窍不通，卻又怕吃亏，你可以去家具店集中的地方，先到第一家店，一样一样看。老板过来，问你对哪种感兴趣，你只笑笑。于是那老板不得不主动介绍了：”您瞧瞧，这明式的如何？”接着你进另一家，进去绕绕，老板问你对什么感兴趣，你说”明式的吧！” 老板立刻把你带到明式家具的那区，你再一样样看，不吭声。这时候老板看你正端详其中一样，说”喔！您要买明式的圈椅？” 你跟着又出来了，进下一家店，才进门就问”有没有明式的圈椅？”老板赶快带你过去，一样样介绍，看你正摸其中一把，就说”这可是海南的黄花梨，还有，您瞧！这里有瘿子，多漂亮！” ? 好！接着你又出来了，进下一家，而且这次进门就问”有没有明式圈椅，要海南黄花梨。最好带瘿子装饰的……” 老板一听，喝！来了行家。这时候，如果你问价钱，而且说：”我可是比价，你开，我不还价，但是如果贵了，我转身就走。” 请问，他能不开低一点吗？事实证明，你在行！最起码你看过不少，真是比价。 于是你可以拿着他开出的价钱，作比较，再去别家，甚至回你看过的前面那几家。 相反的，如果你当初嘴巴大，进店门先说”我要中国式的、老式的，比较古典的椅子，木料要好一点。”那老板能不立刻看穿，你是外行。碰上奸商又能不狠狠敲你吗？所以说，你可以用沉默的方式去学习。学会了，再开口。","tags":[{"name":"貌似有知识","slug":"貌似有知识","permalink":"http://ijiangnanbei.com/tags/貌似有知识/"}]},{"title":"废话少说","date":"2017-06-13T14:14:29.000Z","path":"2017/06/13/废话少说/","text":"读书笔记：《世说新语》 千万别在应该听别人说话或专心做事的时候，在旁边啰啰嗦嗦。要知道，当你啰嗦的时候，很可能影响别人的判断，失去听别人意见的机会，或造成对方的错误。结果损失的是自己。 这里要强调一点，就是有些东西你可以说，但不必先说。譬如你要装修房子，找来设计师。既然他是专家，你应该先听他怎么说，而不是自己先讲：我觉得这个门可以改到那边，这里加个屏风，床头上面像旅馆一样，加几盏石英灯，地上用拋光的石英砖……。 你这一说，设计师还能发挥他的创意吗？你怎不想想，因为他是专家，能提出你完全想不到的好点子，比你原先的构想好得多呢？如果再碰上个图省事的设计师，你怎么说，他怎么办，办得不好，反正是你的意思，你也不好不接。到头来，请问，是他作设计师，还是你作设计师？如果都由你作了，连材料都自己想好了，你又何必付那么多设计费？ 不必说的时候先说，是人们的通病，你可能知道当人数钞票的时候，千万别去打扰，却可能在银行职员给你填表格，或医生给你开药单的时候，一个劲的跟他说话，如果金额弄错了、帐号写错了、药开错了，你要怪谁？ 所以无论看病、装修、上银行、找律师，都要懂得有些话得先憋着。 不是不说，而是等该说的时候才说。","tags":[{"name":"貌似有知识","slug":"貌似有知识","permalink":"http://ijiangnanbei.com/tags/貌似有知识/"}]},{"title":"奇数次的数（一个）","date":"2017-06-13T00:22:27.000Z","path":"2017/06/13/奇数次的数（一个）/","text":"问题描述： 给定一个整形数组 arr 。已知 arr 中只有 1 个数出现了奇数次，其他的数都出现了偶数次，请返回出现了奇数次的数。 时间复杂度为 O(N) ，额外空间复杂度为 O(1)。 思路： 整数 n 与 0 异或的结果是 n，整数 n 与整数 n 异或的结果是 0.所以先申请一个整形变量，记为 use。把 use 和每个数异或（use = use ^当前数），最后 use 的值就是出现了奇数次的那个数。 异或运算满足交换律和结合律。 代码： 123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123; int use = 0; int arr[5] = &#123;1,2,2,3,3&#125;; for(int i=0; i&lt;5; i++) &#123; use ^= arr[i]; &#125; cout &lt;&lt; use &lt;&lt; endl;&#125; 补充： 按位异或运算将两个运算分量的对应位按位遵照以下规则进行计算：^ 0 = 0, 0 ^ 1 = 1, 1 ^ 0 = 1, 1 ^ 1 = 0,即相应位的值相同的，结果为 0，不相同的结果为 1。 异或运算的意思是求两个运算分量相应位值是否相异，相异的为 1，相同的为 0。按位异或运算的典型用法是求一个位串信息的某几位信息的反。如欲求整型变量 j 的最右 4 位信息的反，用逻辑异或运算 017^j ，就能求得j最右 4 位的信息的反,即原来为 1 的位，结果是 0 ,原来为 0 的位，结果是 1。 0^num = num; 1^num = ~num; num ^ num = 0; 其中num = 0或者1。 a^a^b^b^c = (a^a)^(b^b)^c=0^0^c=c;","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"《第三部：妖孽宫廷》","date":"2017-06-11T23:22:21.000Z","path":"2017/06/12/《第三部：妖孽宫廷》/","text":"1.“莫须有”杀掉了岳飞，“意欲”杀掉了于谦。 2.徐有贞聪明绝顶，认定李贤是他的亲信，可是他错了。 石亨位高权重，对李贤许以官位，以为可以拉拢他，可是他也错了。 他们都认为这个叫李贤的人会乖乖地听他们的话，为他们办事，却绝不会想到，在李贤的眼里，他们不过是猎物而已。 他原本可以投靠“还乡团”，做大官，拿厚禄，可是他没有这样做，在“还乡团”肆虐的日子里，他默默地隐藏着自己，从那些阴谋家身上学习权谋和诡计，并最终用这些武器打倒他们。但他这样做又是为了什么呢？ 从他后来的言行中，我们可以找到答案：公道。 3.真正的政治老手是不同于常人的，他们炒菜时从来不用大火爆炒，只用小火慢炖，打仗时从不中央突破，总是旁敲侧击。 4.朱见深明白大臣们的疑虑，但他并不想解释什么，因为他知道，这些人是不会理解的。 在那孤独无助的岁月里，只有她守护在我的身边，陪伴着我，走过无数的风雨，始终如一，不离不弃。 是的，你们永远也不会明白。 在这世上，爱一个人不需要理由，从来都不需要。 5.当一个人不得不走向死亡时，自杀代表着尊严和抗争。6.朱熹到底是一个怎样的人？ 支持者认为，他是宋明理学的标志性人物，是一个伟大的哲学家。 反对者认为，他是宋明理学的标志性人物，是禁锢思想的罪魁祸首。 其实朱熹先生远没有人们所说的那么复杂，在我看来，他只是一个有追求的人，不过是他的目标有些特殊罢了。 他追求的是这个世界上最为深邃的秘密。 （提示：下面的内容将叙述一些比较难以理解的哲学问题，相信按本人的讲述方式，大家是能够理解的，如果实在不行的话，就去翻书吧。） 自古以来，有这样一群僧人，他们遵守戒律，不吃肉，不喝酒，整日诵经念佛，而与其他和尚不同的是，他们往往几十年坐着不动，甚至有的鞭打折磨自己的身体，痛苦不堪却依然故我。 有这样一群习武者，经过多年磨炼，武艺已十分高强，但他们却更为努力地练习，坚持不辍。 有这样一群读书人，他们有的已经学富五车，甚至功成名就，却依然日夜苦读，不论寒暑。 他们并不是精神错乱、平白无故给自己找麻烦的白痴，如此苦心苦行，只是为了寻找一样东西。 传说这个世界上存在着一种神奇的东西，它无影无形，却又无处不在，轻若无物，却又重如泰山，如果能够获知这一样东西，就能够了解这个世界上的所有的奥秘，看透所有伪装，通晓所有知识，天下万物皆可归于掌握！ 这并不是传说，而是客观存在的事实。 这样东西的名字叫做“道”。 所谓道，是天下所有规律的总和，是最根本的法则，只要能够了解道，就可以明了世间所有的一切。 这实在是一个太大的诱惑，所以几千年来，它一直吸引着无数人前仆后继地追寻。更为重要的是，事实证明，道不但是存在的，也是可以为人所掌握的。 对于不同种类的追寻者而言，道有着不同的表现方式，对于和尚们来说，道的名字叫做“悟”，对于朱熹这类读书人而言，它的名字叫“理”。 和尚们梦寐以求追寻的“悟”，并不是虚无缥缈的，事实上，它是一种极为玄妙的快感，远远胜过世间所有的欢悦和一切精神药品，到此境界者，视万物如无物，无忧无虑，无喜无悲，愉悦之情常驻于心。佛法谓之“开悟”。 最著名的“开悟”者就是“六祖”慧能，之后的德山和尚与临济和尚也闻名于世。 穷诸玄辨，若一毫置于太虚；竭世枢机，似一滴投于巨壑。 此即所谓佛者之道。 而关于武者的道，大致可以用这样一个故事来说明： 按照武术中的说法，兵器是越长越好，即所谓“一寸长，一寸强”。但据说五代年间，有一位高手用剑，却是越用越短，到后来他五六十岁了，剑法出神入化之时，居然不用剑了，每逢打架都是光膀子上阵，却从未被打败过。 当我看到这个故事时，才真正开始相信一句小说中的常用语： “手中无剑，心中有剑。” 朱熹的道源自儒家，又叫做“理”，既不是开悟，也不是练习武术，这玩意儿是从书中读出来的，而且还是能够拿出去用的，一旦通理，便尽知天下万物万事，胸怀宽广，宠辱不惊，无惧无畏，可修身，可齐家，可治国，可平天下！ 唯天下至诚，能尽其性；能尽其性，则能尽人之性；能尽人之性，则能尽物之性；能尽物之性，则可赞天下之化育；可以赞天下之化育，则可以与天地参矣！ 此即儒家之道。 此即儒家之道。 上面大致解释了道的意思，如果某些文言看不太懂得话，也不用去找翻译了，概括起来，只要你懂得三点就够了： 一：道是个稀罕玩意儿，是很多人一生追求的。 二：无论什么职业的工种，悟道之后都是有很多好处的。 三：悟道是很难的，能够悟道的人是很牛的。 也就这样了，能看明白就行。 7.随从们的脸立马就白了，王大人你太不仗义了，那里平时可是发配犯人的地方啊！ 面对着随从们的窃窃私语，王守仁十分坦然： “如果你们不愿意去，那就回去吧。” 看着犹豫不决的随从，王守仁没有多说什么，只是默默地拾起行李，向前方走去。 夕阳之下，王守仁那孤独的身影越来越远，突然，远处传来了王守仁的大声吟诵： 客行日日万锋头，山水南来亦胜游。 布谷鸟啼村雨暗，刺桐花暝石溪幽。 蛮烟喜过青扬瘴，乡思愁经芳杜洲。 身在夜郎家万里，五云天北是神州！ “天下之大，虽离家万里，何处不可往！何事不可为！”王守仁大笑着。 在这振聋发聩的笑声中，随从们开始收拾行装，快步上前，赶上了王守仁的脚步。 8.士不可以不弘毅，任重而道远！仁以为己任，不亦重乎！死而后已，不亦远乎！ 面对着一切的困难和痛苦，仍然坚定前行，泰然处之的人，才有资格被人们称为圣贤。 王守仁已经具备了这种资格。 但是他还有最后一个问题没有找到答案——“理”。 必须找到，并且领悟这个“理”，才能懂得天地大道的秘密。除此之外，别无他路。 可是“理”到底在哪里呢？十余年不间断地寻找，沉思，不断地“格”，走遍五湖四海，却始终不见它的踪影！ 为了冲破这最后的难关，他制造了一个特别的石椁，每天除了干活吃饭之外，就坐在里面，沉思入定，苦苦寻找“理”的下落。 格物穷理！格物穷理！可是事实让他失望了，怎么“格”，这个理就是不出来，在一次又一次的失败中，他逐渐变得急躁、愤怒，脾气越来越差，随从们看见他都要绕路走。 终于，在那个宿命的夜晚，他的不满达到了顶点。 黑暗已经笼罩了寂静的山谷，看着破烂的房舍和荒芜的崇山峻岭，还有年近中年、一事无成、整日空想的自己，一直以来支撑着他的信念终于崩溃了，他已经三十七岁，不再是当年的那个风华少年，他曾经有着辉煌的仕途、光荣的出身、众人的夸耀和羡慕。 现在这一切都已经离他而去。 最让人痛苦和绝望的折磨方法，就是先赐予，然后再一一拿走。 十几年来，唯一支撑着他的只有成为圣贤的愿望。但事实是残酷的，多年的努力看来已付之流水，除了日渐稀少的头发，他什么也没有得到。到底出了什么问题呢？ 矢志不移，追寻圣贤，错了吗？ 仗义执言，挺身而出，错了吗？ 没有错，我相信我所做的一切都没有错。 那上天为何要夺走我的荣华，羞辱我的尊严，使我至此山穷水尽之地步？ 既然你决意夺去我的一切，当时为何又给予我所有？ 夺走你的一切，只因为我要给你的更多。 给你荣华富贵，锦衣玉食，只为让你知晓世间百态。 使你困窘潦倒，身处绝境，只为让你通明人生冷暖。 只有夺走你所拥有的一切，你才能摆脱人世间之一切浮躁与诱惑，经受千锤百炼，心如止水，透悟天地。 因为我即将给你的并非富甲一方的财富，也不是号令天下的权势，却是这世间最为珍贵神秘的宝物——终极的智慧。 王守仁在痛苦中挣扎着，一切都已失去，“理”却依然不见踪影。 竹子里没有，花园里没有，名山大川里没有，南京没有，北京没有，杭州没有，贵州也没有！ 存天理，去人欲！ 天理，人欲！ 理！欲！ 吃喝拉撒都是欲，“欲”在心中，“理”在何处？“理”在何处？！ 王守仁陷入了极度的焦虑与狂躁，在这片荒凉的山谷中，在这个死一般宁静的夜晚，外表平静的他，内心正在地狱的烈火中煎熬。 答案就在眼前！只差一步！只差一步而已！ 忽然，一声大笑破空而出，打碎了夜间山谷的宁静，声震寰宇，久久不绝。 在痛苦的道路上徘徊了十九年的王守仁，终于在他人生最为痛苦的一瞬获知了秘密的答案。 空山无人，水流花开。 万古长空，一朝风月。 此一瞬已是永恒。 我历经千辛万苦，虚度十九年光阴，寻遍天涯海角，却始终找不到那个神秘的“理”。 现在我终于明白，原来答案一直就在我的身边，如此明了、如此简单，它从未离开过我，只是静静地等待着我，等待着我的醒悟。 “理”在心中。 我竟如此的愚钝啊，天地圣贤之道并非存于万物，也无须存于万物，天人本是一体，何时可分？又何必分？ 随心而动，随意而行，万法自然，便是圣贤之道！ 存天理，去人欲？ 天理即是人欲。 这是载入史册的一瞬，几乎所有的史书都用了相同的词语来描述这一瞬——“顿悟”，中华文明史上一门伟大的哲学“心学”就此诞生。 它在这个幽静的夜晚，诞生于僻静而不为人知的山谷，悄无声息，但它的光芒终将照耀整个世界，它的智慧将成为无数人前进的向导。 王守仁成功了，历史最终承认了他，他的名字将超越所有的帝王，与孔子、孟子、朱子并列，永垂不朽。 9.一个人干一件坏事不难，但要一辈子只干坏事，真的很难很难。 10.可怜的土匪们不会知道，王守仁先生通常被后世人称为“四家”：伟大的哲学家、军事家、政治家、文学家。这四个称谓他都当之无愧。 所谓军事天才，就是不用上军校，拿一本盗版《孙子兵法》也能打仗的人，王守仁就属于这一类型，他不但会打仗，还打出了花样。 他的用兵方法可以用两个字形容——诡异。 别人打仗无非是敌进我退，敌退我追，兵多就打，兵少就跑。王哲学家却大大不同，他从来不与敌人正面交锋，从来都是声东击西，你往南走，他偏往北，经常搞得敌人晕头转向。 不按常理出牌也就罢了，有意思的是，这位仁兄还有个不合常理的习惯，即使兵力再少，他也敢出战，士兵不够他就玩阴的，什么挖坑打埋伏，那是家常便饭，更为奇怪的是，即使他占据绝对优势，把对手围得如铁桶一般，也从不轻易发动进攻，如果时间允许，总要饿他们个半死不活，诱使对方突围，钻入伏击圈，才开始发动总攻。 基本上这几招一路下来，神仙也会被他整死的。 公正地讲，在日常生活中，王巡抚确实是一个正直忠厚的老实人，可到了战场上，他就会立马变得比最奸的奸商还奸，比最恶的恶霸还恶。 11.要知道大凡历史上干哲学这行的，一般都满足两个条件：第一，智商要过剩，弱智白痴是禁止入内的（大智若愚者除外）；第二，必须是吃饱了没事干（饭都吃不饱还搞啥哲学）。 哲学有这么高的门槛，是因为它是世间一切科学的基础，如果你够厉害，理论上是什么学科都可以搞得定的。 12.随着时间的流逝，王守仁终于发现光懂得哲学是不够的，整天谈论“心学”并没有什么效果，“心学”并不能打跑土匪，他隐约地感觉到，要想理论联系实际，成功立业处世，还需要另一样神秘的工具。 经历了穷山野岭的荒凉、无人问津的落寞、曾经悟道的喜悦后，王守仁又一次来到了关口，在江西的两年，由于遍地都是土匪，他只能四处出差专职剿匪，没有时间去研究他的哲学。 上天没有亏待王守仁，正是在这金戈铁马、烽火连天的两年中，王守仁逐渐找到了这一样工具，并且熟练地掌握了它。 有了这件工具，他才能超越众多的前辈，成为理学的圣贤。 有了这件工具，他才能成就辉煌武功，为后人敬仰。 有了这件工具，他的哲学方为万人信服，远流海外，千古不朽。 而后世的名臣徐阶、张居正也正是借助了这件工具，建立不世功勋，名留千古。 这件工具的名字叫做“知行合一”。 关于知和行的关系，是一个中国哲学史上的根本问题，这个麻烦从诸子百家开始，一直到后来的孙中山，历时几千年，骂了无数次，吵了无数次，始终无法解决。 我也不能解决，但我可以解释。 其实这个问题说穿了，就是一个理论和实践的问题，有人认为知易行难，懂得理论是容易的，实践是很难的，有人认为知难行易，领悟道理很难，实践很容易。 比如朱圣人（朱熹）就主张知难行易，这也好理解，按照他那个“格”法，悟道是很难的，但执行似乎是很容易的。 大家可能很难想象，但就是这么个玩意儿，折腾了上千年，直到今天，都没停过。 此刻王守仁站了出来，他大声喊道： 懂得道理是重要的，但实际运用也是重要的。 这句话的真正意思是：要想实现崇高伟大的志向，必须有符合实际、脚踏实地的方法。 这绝不仅仅是一句话，而是一种高深的处事和生活智慧，足以使人受用终身，所以它看起来很容易明白，实际上很不容易明白。 二十多年后，有两个人先后读了他的书，却都看到了“知行合一”这句话，一个人看懂了，另一个人没有看懂。 看懂的那个人叫张居正，没有看懂的那个人叫海瑞。 四百年后，有一个年轻人看到了这句话，佩服得五体投地，以此作为自己的终身行为准则，并据此改名——陶行知。 13.有时候我也会看电视上那些以唐伯虎为原型的电视剧，看他如何智斗奸臣，看他如何娶得美人归，这些情节大都十分搞笑，但无论如何，每次我都笑不出来。 因为在我的脑海里，始终浮现着的，是那个真实的唐伯虎，是那个意气风发的年轻人、那个怀才不遇的中年人、那个心灰意冷的老人，是那个在无奈中痛苦挣扎、无比绝望的灵魂。 只有那首桃花歌仍旧在诉说着他的心声，萦绕千载，从未散去。 别人笑我太疯癫，我笑他人看不穿。 不见五陵豪杰墓，无花无酒锄作田。 14.王守仁是一个很绝的人，他总是在奇怪的地方，提出奇怪的意见，做出奇怪的事，但最后却都被证实是正确的。 他的这种可怕的智慧来源于他的哲学，因为王守仁先生和古往今来的所有哲学家都不同，他的哲学十分特别，就如同吃饭的筷子和挖地的锄头，随时都可以用，随时都有用处。 他痛恨杀害孙燧、发动战争的宁王，却从未被愤怒冲昏头脑，他十分清楚凭借目前的兵力，绝对无法战胜对手，眼下他只能积蓄力量，等待时机的到来。 有着平叛的志向，也要有切合实际的平叛策略，这就是“知行合一”，这就是王守仁无往不胜的哲学和智慧。 15.所谓兵法之奥秘，在我看来，只有八个字而已。” “此心不动，随机而行。” 16.按说到了这个份儿上，就应该动手打了，可大家别忘了，这支军队的指挥官是王守仁先生，王司令带兵自然有王司令的方法，但凡打仗之前，他如果不搞点儿自己的特色（阴谋诡计），是不会罢休的。 首先他派人四处传扬，大张旗鼓，说自己手下有三十万人（敢吹），还特别说明这都是从福建和广东调来的精锐部队，绝非传言中的乌合之众（传言是真的）。 搞得守军人心惶惶之后，他又派遣大量间谍，趁人不备，躲过城管监察，摸黑在南昌城内大肆非法张贴广告告示，劝诫南昌市民不要多管闲事，关好自家房门，安心睡觉，听见街上有响动，不要多管闲事。 他的这一连串动作不但让敌人惊慌失措，连自己人也是雾里看花，要打你就打，又不是没有士兵装备，有必要耍阴招吗？ 王守仁认为很有必要。 他的兵法就是用最小的代价，换取最大的胜利，兵不厌诈正是他的兵法哲学，除了使用上述计谋外，他还选定了一个特别的进攻时间——深夜。 因为他压根儿就没有想过硬拼，早在行军途中，他就已准备了大量的攻城云梯，只等夜深人静时，派出精干人员用云梯突袭城墙，夺取城池。 为了保证登城的成功，王守仁还同时派人预备攻城器械，潜进到城门附近，准备吸引守军注意，配合登城士兵。 一切都准备妥当之后，他召集所有部下，开了一次别开生面的动员会。 王守仁虽然机智过人，平日却也待人和气，所以大家经常背地称呼他为老王。 可是在会上，一贯慈眉善目的老王突然变成了阎王，满脸杀气地下达了最后的命令： “此次攻城，由我亲自督战，志在必取！一鼓令下，附城！二鼓令下，登城！三鼓令下未登城，杀兵！四鼓令下未登城，杀将！” 会场鸦雀无声，大家都面无人色，就此达成共识——王司令着实不是善类。 该准备的准备了，该玩的诡计也玩了，王守仁正襟危坐，等待着夜晚的进攻。 但连他也万万没有料到，自己的这些战前热身运动竟起到了意想不到的效果。 17.“我即将赴任，但此去必定再无返乡之日，此刻即是永别之时，望你们用心于学，今后我不能再教你们了。” 钱德洪和王畿当即泪流满面，马上跪倒在地，连声说道： “老师哪里话！老师哪里话！” 王守仁却笑着摇摇头： “生死之事，上天自有定数，我已五十有六，人生已然如此，别无牵挂，只是有一件事情还要交代。” 钱德洪和王畿停止了悲泣，抬起了头。 “我死之后，心学必定大盛，我之平生所学，已经全部教给了你们，但心学之精髓，你们却尚未领悟，我有四句话要传给你们，毕生所学，皆在于此，你们要用心领会，将之发扬光大，普济世人。” 天地竟是如此之宁静，大风拂过了空旷的天泉桥，在四周传来的阵阵风声中，王守仁高声吟道： 无善无恶心之体，有善有恶意之动。 知善知恶是良知，为善去恶是格物。 钱德洪与王畿一言不发，屏气凝神，记下了这四句话。 此即所谓心学四诀，流传千古，至今不衰。 吟罢，王守仁仰首向天，大笑之间飘然离去： “天地虽大，但有一念向善，心存良知，虽凡夫俗子，皆可为圣贤！” 号哭而来，欢笑而去，人生本当如此。 18.嘉靖七年（1528）十月，他的肺病发作，在生命垂危之际，他提出了最后一个要求——回家，从哪里来，就回哪里去吧！ 可是他的病情实在太重了，要等到上级审批，估计坟头上都长草了，王守仁当机立断，带着几个随从踏上了回乡之路。 但他终究没有能够回去。 嘉靖七年十一月，王守仁到达了江西南安，再也走不动了，这里就是他最后的安息之地。 在临终之前，他的门人聚在他的身旁，问他还有什么遗言。 王守仁笑了笑，用手指向胸前，留下了他在人世间的最后一句话： “此心光明，亦复何言。” 鸟，我知道它能飞；鱼，我知道它能游；兽，我知道它能走。飞的我可以射，走的我可以网，游的我可以钓。 但是龙，我不知该怎么办啊！学识渊深莫测，志趣高妙难知；如蛇般屈伸，如龙般变化，龙乘风云，可上九天！ 对于王守仁先生，我别无他法，只能用这段两千多年以前的文字来描述他，这是他应得的称颂。 他的心学，是中华文明史上的一朵奇葩，是值得我们每个人为之骄傲的财富，他吹响了人性解放的号角，引领了明代末期的思想解放潮流，他的思想流传千古，近代的康有为、孙中山等人都从其中受益匪浅。 除了中国外，他的心学还漂洋过海，深刻影响了日本、韩国等东亚国家，他本人也被奉为神明，受人日日顶礼膜拜，那位东乡平八郎大将就是他的忠实粉丝。 彪炳显赫，自明之后，唯此一人而已。 王守仁的一生，是光明的一生。他历经坎坷，却意志坚定；混迹官场，却心系百姓。他反对暴力和贪欲，坚信正义和良知。 赞：王守仁是一个高尚的人，一个纯粹的人，一个有道德的人，一个脱离了低级趣味的人，一个有益于人民的人。 他是真正的圣贤，当之无愧。 19.后生可畏，焉知来者不如今！","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ijiangnanbei.com/tags/读书笔记/"}]},{"title":"《第二部：万国来朝》","date":"2017-06-10T16:17:44.000Z","path":"2017/06/11/《万国来朝》/","text":"1.为什么要读书？一般而言这个问题的答案是建设祖国，为国争光之类，当然，真正的目的大多是升官、发财、满足欲望，等等。但事实告诉我们，为了名利去做一件事情也许可以获得动力和成功，但要成就大的事业，需要的是另一种决心和回答——为了读书而读书。 2.罢官的日子是苦闷的，人类最大的痛苦并不在于一无所有，而是拥有一切再失去。 3.解缙终于满足了，他似乎意识到，自己多年来没有成功，知识因为当年政治上的幼稚，为什么一定要说这么多违背皇帝意愿的话呢？那不是为难自己吗？ 而这次政治投机的成功也让他认定，今后不再关心那些与己无关的事情，只有积极投身政治，看准政治方向，并放下自己的政治筹码，才能保证自己的权利和地位。 于是，当年那个一心为民请命、为国效力的单纯的读书人死去了，取而代之的是一个跃跃欲试、胸有城府的政客。 也许在很多人看来，这也并没有什么大惊小怪的，只不过是一个人对自己人生的选择罢了，但问题在于，解缙在做出这个选择的时候忘记了一个重要而简单的原则，而正是这个简单的原则断送了他的一生。 这条原则就是：不要做你不擅长的事。 这句话倒不一定是打击，在很多情况下，它是真诚的劝诫。 4.解缙太天真了，他不知道朱棣从根本上讲是一个政治家，政治家说话是不能信的，你对他有用时或他有求于你时，他会对你百依百顺，恨不得叫你爷爷。但事情办完后，你就会立刻恢复孙子的身份。很明显，解缙搞错了辈分。5.在历史上，经常会出现一些十分有水平的人物，他们能够在形势尚不明朗之前预见到事物将来的发展，如诸葛亮在破草房里就能琢磨出天下将来会三分等，但诸葛亮的这种琢磨是不需要成本的，即使他琢磨得不对，也没有人去找他麻烦。 容易出麻烦的是抉择，也就是说，必须牺牲某些眼前的利益去换取将来更长远的利益。这种抉择往往是极为痛苦的，因为眼前的利益是大家都能看到的，长远的利益却是看不到的。就好比你让大家丢下手中已有的钞票，跟着你去挖金矿，金矿固然诱人，但是否真有却着实要画个大问号，你说有就有？凭什么？ 一百多年后伟大的改革家张居正就是栽倒在这种抉择上的，因为那些大臣们宁可抱着手上的那点家当等死，也不肯跟他去走那条未知的道路。 朱隶就是这样一个很有水平的领导，也是一个敢于抉择的领导，他知道迁都是一项大工程，耗时耗力，但它准确的判断出，影响明帝国长治久安的最大因素就是北方的蒙古，要想将来平平安安过日子，就必须舍弃眼前的利益，迁都北京。否则明朝将难逃南宋的厄运。 与张居正相比，朱隶有一个优势–他是皇帝，而且还是一个铁腕皇帝，一个敢背骂名我行我素的皇帝，所以它能够一直坚持自己的信念，所以他终于完成了迁都这项艰难的工作。 棣迁都的行为招致了当时众人的反对，很多人也断言此举必不可行，但十九年后站在北京城头遥望远方的于谦应该不会这样想。 历史才是事物发展最终的判断者，在不久之后，它将毫无疑问地告诉每一个人：朱棣的抉择是正确的。 6.可是某些人注定是不会平凡地度过一生的，伟大的使命和事业似乎必定要由这些被上天选中的人去完成，即使有时是以十分残忍的方式。 7.无数的梦想似乎都已经离他而去了，但历史已经无数次地告诉我们，悲剧的开端，往往也是荣耀的起点。 悲剧，还是荣耀，只取决于你，取决于你是否坚强。 8.在手握重兵的情况下，能够保持清醒的头脑，克制自己的愤怒，以大局为重，这需要何等的忍耐力！郑和的行为不是懦弱，而是明智。 9.一仗打出十年和平。 至理名言，古今通用。 10.是的，穷人也是有尊严和信义的，正是因为有这样明理的母亲，后来的杨士奇才能成为一代名臣。 杨士奇就是这样成长起来的，在困难中不断努力，在贫困中坚持信念，最终成就事业。 人穷，志不可短！ 11.青少年时期的艰苦经历磨练了杨世奇，使他变得老成而有心计。他为人十分谨慎，别人和他说过的话，他都烂在肚子里，从不轻易发言泄密，他是太子的忠实拥护者，却从不明显表现出来，其城府可见一斑。 而杨士奇之所以能够有所成就，其经验大致可以概括为一句话：刚出道时要低调，再低调。 12.如果明天生命就可能结束，而你却无能为力，你会干些什么？ 我相信很多人在这种状况下是准备写遗书或是大吃一顿，把以前没玩儿的都补上，更多的人则是怨天尤人，抱怨上天不公。 这些都是人的正常反应，可杨溥奇就奇在他的反应不正常。 明天就可能被拉出去砍头，他却仍在读书，而且是不停地读，读了很多书（读经史诸子书不辍），这实在是让人难以理解，在那种险恶的环境下，性命随时不保，读书还有什么用呢？ 可这个人却浑似坐牢的不是自己，每天在散发恶臭、肮脏潮湿的牢房里，却如同身在自己书房里一样，不停地用功读书，他的自学行为让其他犯人很惊讶，到后来，连看守他的狱卒都怀疑他精神不正常。 他的这种举动也引起了朱棣的主意，有一次朱棣突然想起他，便问杨溥现在在干什么（幸好不是问杨溥尚在否），大臣告诉他杨溥在监狱里每天都不停地读书。 朱棣听到这个答案后，沉思良久，向锦衣卫指挥使纪纲下达了命令，要他务必好好看守杨溥，不能出任何问题。 朱棣是一个很有水平的领导，这种水平就体现在对人的认识上，他很清楚杨溥的境况和心理状态，然而就是在这样的情况下，杨溥却能视死如归，毫不畏惧，也绝非伪装（装不了那么长时间），这是很不容易的。 很明显，这个叫扬溥的人心中根本就没有害怕这两个字。 自古以来，最可怕的事情并不是死，而是每天在死亡的威胁下等死。 不知何时发生，只知随时可能发生，这种等死的感受才是最为痛苦的。 杨溥不怕死，也不怕等死，这样的人，天下还有何可怕！ 真是个人才啊！ 13.永乐十年（1412）的风波之后，朱棣对太子也产生了怀疑，便向杨士奇询问太子监国时表现如何。 这看上去是个很简单的问题，实际上却暗藏杀机。 城府极深的杨士奇听到这句问话后，敏锐地感觉到了这一点，他立刻意识到，决定太子命运的关键时刻来到了。 他紧张地思索着问题的答案。 趁着杨士奇先生还在思考的时间，我们来看一下为什么这个问题难以回答又十分关键。 如果回答太子十分积极，勤恳做事，和群众（大臣）们打成一片，能独立处理政事，威望很高的话，那太子一定完蛋了。 你爹还在呢，现在就拉拢大臣，独立处事，想抢班夺权，让老爹不得好死啊。 既然这个答案不行，那么我们换一个答案：太子平时积极参加娱乐活动，不理政事，疏远大臣，有事情就交给下面去办，没有什么威信。 这样回答的话，太子的结局估计也是一完蛋。 这又是一个非常类似二十二条军规的矛盾逻辑。 太子的悲哀也就在此，无数太子就是这样被自己的父亲玩儿残的，自古以来，一把手和二把手的关系始终是处理不好的，在封建社会，皇帝就是一把手，太子就是二把手，自然逃脱不了这个规则的制约。 你积极肯干，说你有野心；你消极怠工，说你没前途。 干多了也不行，干少了也不行，其实只是要告诉你，不服我是不行的。 让你干，你就不得休息；不让你干，你就不得好死。 为什么呢？ 答案很简单：权力。 谁分我的权，我就要谁的命！（儿子也不例外） 朱棣很明白，他最终是要将权力交给太子的，而在此之前，太子必须有一定的办事能力，为了帝国的未来，无能的废物是不能成为继承人的，所以必须给太子权力和锻炼的机会，但他更明白，要想得一个善终，混个自然死亡，不至于七八十岁还被拉出去砍头，就必须紧紧握住自己手中的权力，直到他死的那一天！ 儿子是不能相信的，老婆是不能相信的，天下人都是不能相信的。 这就是皇帝的悲哀。 好了，现在杨士奇先生已经完成了他的思索，让我们来看看他的答案： “太子监国期间努力处理政事，能够听取大臣的合理意见，但对于不对的意见，也绝不会随便同意，对于近臣不恰当的要求，他会当面驳斥和批评。” 这就是水平啊，在朱棣举办的现场提问回答活动中，杨士奇能够在规定时间内想出这种两全其美的外交辞令，实在不简单。 既勤恳干活礼贤下士，又能够群而不党，与大臣保持距离，在杨士奇的描述下，朱高炽那肥头大耳的形象一下子变得光辉照人。 朱棣听了这个答案也十分满意，脸上立刻阴转晴，变得十分安详，当然最后他还不忘夸奖杨士奇，说他是一个尽职尽责的人。 在这场看不见硝烟的战争中，朱棣和杨士奇各出绝招，朱棣施展的是武当长拳，外柔内刚，杨士奇则是太极高手，左推右挡，来往自如。 从这个角度来看，他们似乎可以算是武当派的同门师兄弟。 于是，永乐十年（1412）的这场纷争就此结束，太子党受到了沉重打击，太子被警告，地位也有所动摇，但由于杨士奇等人的努力，终于稳定住了局势。 14.当时的政治局势极为复杂，由于朱棣公开斥责太子，且把太子的很多亲信都关进了监狱，于是很多大臣们都认为太子已经干不了多久了，倒戈的倒戈，退隐的退隐，太子朱高炽也陷入了孤立之中，现实让他又一次见识了世态炎凉，人情冷暖。 原先巴结逢迎的大臣们此时都不见了踪影，唯恐自己和太子扯上什么关系，连累自己的前途，在这种情况下，杨士奇开始了他和朱棣的问答较量。 这次朱棣没有遮遮掩掩，他直截了当地问杨士奇，太子是否有二心，不然为何违反礼仪，迟缓接驾？（这在朱棣看来是藐视自己） 在此之前，也有人也劝过杨士奇要识时务，太子已经不行了，应该早作打算。 杨士奇用自己的答案回复了朱棣，也回复了这些人的“建议”。 杨士奇答道：“太子对您一直尊敬孝顺，这次的事情是我们臣下没有作好准备工作，罪责在我们臣下，与太子无关（太子孝敬，凡所稽迟，皆臣等罪。）。” 说完，他抬起头，无畏地迎接朱棣锐利的目光。 朱棣终于释然了，既然不是太子的本意，既然太子并不是有意怠慢，自己也就放心了。 就这样，悬崖边上的朱高炽又被杨士奇拉了回来。 杨士奇这样做是需要勇气的，在太子势孤的情况下，主动替太子承担责任，需要冒很大的风险，要知道，朱棣不整太子，对他们这些东宫官员们却不会手软。与他一同辅佐太子的人都已经进了监狱，只剩下了他暂时幸免，但他却主动将责任归于自己，宁愿去坐牢，也不愿意牵连太子。 杨士奇用行动告诉了那些左右摇摆的人，不是所有的人都能被收买，不是所有的人都趋炎附势。 从当时的形势来看，朱高炽的太子地位被摘掉是迟早的事情，继续跟随他并不明智，还很容易成为朱高煦打击的对象，是非常危险的。所以我们可以说，在风雨飘摇中依然坚持支持太子的杨士奇，不是一个投机者。 就如同三十年前，他身处穷困，却仍然无私援助那位朋友一样；三十年后，他又做出了足以让自己母亲欣慰的事情。 三十年过去了，虽然他已身处高位，锦衣玉食，他的所作所为却并没有违背他的人生信条。 人穷志不短，患难见真情。 15.朱棣问：“我最近听到很多汉王（朱高煦封号）行为不法的传闻，你们知道这些事情吗？” 这话是对杨士奇和蹇义两个人问的，但两人的反应却大不相同。 蹇义虽然忠于太子，却也被整怕了，他深恐这又是一个陷阱，要是实话实说，只怕又要遭殃，便推说自己不知道。 朱棣失望地转向了另一个人——杨士奇，他注视着杨士奇，等着他的答复。 杨士奇等待这一天已经很久了。 经历了那么多的波折和阴谋，自己身边的同伴不是被杀掉，就是被朱高煦整垮，为了自己的信念，他忍耐了很久，他曾经有很多机会向朱棣揭发朱高煦的不轨行为，但作为一个政治老手，他十分清楚权力斗争就如同剑客比武，一击必杀才是制胜的王道，因为一旦宝剑出鞘，就没有收回的余地。 朱棣已经丧失了对朱高煦的信任，他已经渐渐看清自己这个儿子的真面目，这是最好的机会，机不可失，时不再来！ 拔剑出鞘！ 杨士奇从容答道：“我和蹇义一直在东宫服侍太子，人家就把我们看成太子的人（还装，难道你不是吗），有什么话也不会跟我们讲，所以我们不知道。” 奇怪了，这句回答不是和蹇义一样，啥也没说吗？ 要知道，自古以来最狠的整人方法就是先夸你，再骂你，杨士奇熟练地运用了这一技巧。所以别急，下面还有个但是呢： “但是，汉王两次被封都不肯到地方就藩，现在陛下要迁都了，在这个时候，他要求留在南京，希望陛下仔细考虑一下他的用意。”（唯陛下熟察其意。） 细细品来，杨士奇此言实在厉害，看似平淡无奇，却处处透着杀机，要把朱高煦往死里整，杨士奇之权谋老到实在让人胆寒。 杨士奇终于亮出了他的宝剑，在正确的时间，正确的地点，对正确的人，使出了那一剑。 一剑封喉。 16.因为一无所有并不可怕，可怕的是得到后再失去。 17.在这个世界上的无数国家民族中，要排聪明程度，中国人绝对可以排在前几位，而其最大的智慧之一就在于变通。这样做不行，那就换个做法，反正达到目的就可以了。 所谓此路不通，我就绕路走，正是这一智慧的集中体现。 18.在历史中，奸邪小人依靠一些偶然的闪光表现得到皇帝的欢心和信任，从而为祸国家的事情并不少见（比如和珅），但事实证明，这一次，朱瞻基并没看错，这位声音洪亮的御史确实是一位不可多得的人才。 在二十年后，他将挺身而出，奋力挽救国家的危亡，并成就伟大的事业，千古流芳。 这位御史的名字叫做于谦。 19.好的皇帝就如同现代足球场上的好裁判，四处都有他的身影，不知疲倦地奔跑，却从不轻易打断比赛的节奏，即使出现违规行为，也能够及时制止，并及时退出，不使自己成为场上的主角。 这样的裁判才是好裁判。 不干扰百姓们的生活，增加他们的负担，为其当为之事，治民若水，因势利导，才是皇帝治国的最高境界。 这样的皇帝才是好皇帝。 朱瞻基就是一个彻头彻尾的好皇帝，而且从治国安民的角度来看，他比他的祖父要强得多。 20.要知道，当一个坏人并不难，但要做一个坏到极点的极品坏人是很难的。 21.一个人如果饥饿就会去找东西吃，因为这是他的基本需求。 如果他已经吃饱了呢？那么他就会四处闲逛，找点事情干，反正闲着也闲着。 如果一个吃饱的人又找不到什么好事干，他可能就会去干坏事，实现自我价值。 22.“单挑”实际上是一件比较痛苦的事情，因为打人的是你，挨打的也是你，是输是赢全要靠你自己。当然，如果你比对方高大，比对方强壮，凑巧还练过武术（最好是搏击，套路不怎么管用），那么胜利多半是属于你的。 现在我们把范围扩大，如果你有两个人，而对方还是一个人，那你的赢面就很大了，两个打一个，只要你的脸皮厚一点，不怕人家说你胜之不武，我相信，胜利会是你的。 下面我们再加一个人，你有三个人，对手还是一个人。此时，你就不用动手了，你只要让其余两个人上，自己拿杯开水，一边喝一边看，临场指挥就行。 就不用一个个地再增加了，如果你现在有一千个人，对手一个人，结果会怎样呢？ 我相信，在这种情况下，你是不会赢的，因为对手早就逃了。 到现在为止，你可能还很乐观，因为一直以来，都是你占优势。 然而真正的考验就要来了，如果你有一千个人，对手也有一千个人，你能赢吗？ 你可以把一千个人分成几队去攻击对方，但对手却可能集中所有人来对你逐个击破，你能保证自己获得胜利吗？ 觉得棘手了吧，其实我们才刚开始。 下面，我们把这个数字乘以一百，你有十万人，对手也有十万人，你怎么打这一仗？ 这个时候，你就麻烦了，且不说你怎么布置这十万人进攻，单单只说这十万人本身，他们真的会听你的吗？ 你要明白，你的手下这十万人都是人，有着自己的思维，有的性格开朗，有的阴郁，有的温和，有的暴躁，他们方言不同，习惯不同，你的命令他们不一定愿意听从，即使愿意，他们也不一定听得懂。如果里面还有外国友人（比如朝鲜），那你还得找几个翻译。 这就是指挥的难度，要想减低这一难度，似乎就只有大力推广汉语和普通话了。 要是再考虑他们的智商和理解能力的不同，你就会十分头疼。这十万人文化程度不同，有的是文盲，有的是翰林，对命令的理解能力不同，你让他前进，他可能理解为后退，一来二去，你自己都会晕倒。 很难办是吧，别急，还有更难办的。 我们接着把这十万人放入战场，现在你不知道你的敌人在哪里。他们可能隐藏起来，也可能分兵几路，准备伏击。而你自己要考虑怎么使用自己这十万人去找到敌人并击败他们。 此外，你还要考虑这十万人的吃饭问题，住宿问题，粮食从哪里来，还能坚持多少天。 脑子有点乱吧，下面的情况会让你更乱。 你还要考虑军队行进时的速度、地形、下雨还是不下雨，河水会不会涨，山路会不会塞，士兵们经过长时间行军，士气会不会下降，会不会造反，你的上级（如果有的话）会不会制约你的权力，你的下级会不会哗变。 你的士兵有没有装备，装备好不好，士兵训练水平如何，敌人指挥官的素质如何，敌人的装备如何，敌人的战术是什么，你的心里承受能力有多大，打了败仗怎么撤退，打了胜仗能否追击，等等。 事实上，战场上的情况还要复杂得多。相信看到这里，你已经明白，别说带十万人出去打仗，你就是带十万人出去转一圈，旅个游，能平安无事地回来就已经很不错了。 你可能以为事情就此结束了，恰恰相反，真正的考验还在后面，不要忘记，我们的目标是多多益善。 如果你再把指挥的人数乘上十倍，一百万人，你就会发现，你面对的已经不是一百万可以依靠的人，而是一百万个麻烦，是真正的灾难。 从十万到一百万，你的人数增加了十倍，但你的问题却可能增加了一百倍，任何小的问题如果不加以重视，就会一发不可收拾。一百万人，每天要消耗多少粮食不说，他们每个人都有自己的想法，谁也不是傻瓜，你怎么控制一百万个人，让他们去听从你的指挥呢？ 军事指挥就如同一座金字塔，指挥的人数和指挥官的指挥能力是成正比的，指挥的人数越多，对能力的要求就越高。从古至今，有能力站在塔顶的人是很少的。 多多益善是一种境界，它代表着指挥官的能力已经突破了人数的限制，突破了金字塔的塔顶，无论是十万、还是五十万、一百万，对于指挥官而言，都已经没有意义。 因为这种指挥官的麾下，他的士兵永远只有一个人，命令前进绝不后退，命令向东绝不向西。 同进同退，同生同死。 这才是指挥艺术的最高境界。 所以，善带兵而多多益善者，是真正的军事天才。 这样的人，我们称之为军神。 23.一个人犯一次错误不难，难的是从头到尾都犯错误. 24.一个人最可悲的地方不在于被骂，而在于骂无可骂。 25.在国家出现危难之时，总有一些人挺身而出，为国效力，这样的人，我们称为英雄。 英雄不是人人都能当的。一般看来，英雄有如下特点： 敢为人之所不敢为，敢当人之所不敢当。 挽狂澜于既倒，扶大厦于将倾。 但实际上，要成为英雄，必须先学会畏惧。 这个世界上本来就不存在着天生的英雄，只要过日子，就会有困难，有困难，就会有障碍。你会开始畏惧，畏惧所有阻挡在你眼前的障碍。 当你感到畏惧和痛苦，支撑不下去的时候，你应该同时意识到，决定你命运的时候到了。 因为畏惧并不是消极的，事实上，它是一个人真正强大的开始，也是成为英雄的起点。 不懂得畏惧的人不知道什么是困难，也无法战胜困难。 只有懂得畏惧的人，才能唤起自己的力量。 只有懂得畏惧的人，才有勇气去战胜畏惧。 懂得畏惧的可怕，还能超越它、征服它的人，就是英雄。 这就是我所认为真正的英雄——畏惧并战胜畏惧的人。 关键只在于那畏惧的一刻，你是选择战胜它，还是躲避它。 人生的分界线就在这里，跨过了这一步就是英雄，退回这一步就是懦夫！ 26.所谓有水平就是能做到别人做不到的事情，想出别人想不出的方法。 27.在这个世界上，很多事情只要一平均就会原形毕露。 28.在残酷的战场上，弱者是无法生存下去的，只有最为坚强的、刚毅的强者才能活下来，并获取最后的胜利。 29.他在城头看得一清二楚，也明白孙镗也并非贪生怕死，实在是支持不下去了，可是他军令在身，而且他也是一个比较死板的人，通俗说来就是认死理。所以他没有开门，而是站在城头，对孙镗喊了很长的一番话。 这番话的大意是，虽然我知道你很辛苦，敌人很多，很想进城，我也可以理解，但是因为上级有命令不能放你入城，所以我不能违背命令放你进来，其实只要你打退敌人，就可以进城了，所以希望你多多努力，我会在城头为你呐喊助阵的。 这番话说得孙镗目瞪口呆，要能打退敌人，老子还找你干吗？不让进就不让进，说这么多废话干啥？ 找一个言官来做武将的监军，实在是很有意思的组合，在很多时候会造成极强的喜剧效果。 孙镗明白，虽然这位城头的言官说了一些废话，但是主题意思是清楚的： 能够进城的只有两种人，胜利者，或是尸体！ 它拔转马头，转向了激战正酣的战场。 反正也进不去了，就战死在这里吧！也先，老子跟你拼了。 人有时候必须有舍弃生命的觉悟，才能找到生路。 30.无论在多么绝望的情况下，也不要放弃希望，坚持下去，就一定能够创造奇迹。 于谦用他的行为为我们证明了这一真理。 31.在权力面前，从来就没有兄弟的位置。 32.其实王直的这段话还是经过仔细思考才写出来的，他已经察觉，朱祁钰不想朱祁镇回来，就是因为皇位，所以他特别声明，就算朱祁镇回来了，也不会抢你的皇位，你就安心吧！ 这样看来，这段话似乎没有问题，那怎么会让朱祁钰生气呢？ 因为王直千算万算，却算漏了一点：这件事情虽然众人皆知，却是朱祁钰埋藏最深的心事，帝王心术鬼神不言，你王直竟然捅破，真是自作聪明！ 33.事实上于谦也是一个城府很深的人，他早就看清了形势，也明白朱祁钰的心理变化以及他震怒的原因，经过仔细思考后，他站出来，只用了一句话就化解了僵局。 “天位已定，宁复有它！” 这句话真是比及时雨还及时，朱祁钰的脸色马上就阴转晴了，于谦见状趁机表示，要派遣使者，不过是为了边界安全而已，还是派人去的好。 于谦的这一番话说得朱祁钰心里一块石头落了地，只要皇位还是自己的，那就啥都好说。 朱祁钰一扫先前脸上的阴云，笑逐颜开，对于谦连声说道：“依你，依你（从汝）。” 我每看到此处，都不由得自心底佩服于谦，不但勇于任事，还如此精通帝王心术，实在不简单。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ijiangnanbei.com/tags/读书笔记/"}]},{"title":"最常见的错误有哪些？","date":"2017-06-09T13:55:54.000Z","path":"2017/06/09/最常见的错误有哪些？/","text":"Ego is the No.1 enemy of succesful marketing. 自大骄傲自大是人们常犯的第一个错误。成功往往导致骄傲自大，而骄傲自大则会导致失败。 自以为是是成功营销的头号敌人。客观性是必要的，当人们成功时，他们往往会变得缺乏客观性，以自己的主观判断代替市场的客观需求。聪明的营销人员能够像潜在顾客那样思考，他们把自己摆在顾客的位置上，不会将自己的主观认识强加到客观环境上。 但是大量研究表明，在长时间的成功后，人们不太可能做出令人满意的决定。 以自我为中心是成功营销的头号杀手。 贪婪‘贪婪’就是人们常犯的第二个错误。经理不将精力放在公司经营上，却时刻关注公司的股票价格。这时公司开始扩张，同时它的品牌形象也开始遭到破坏。安然公司便是一个典型的案例。为了保持股票的高价格，安然公司由一家能源公司变成了贸易公司。 无知‘无知’是另一个常见的错误。许多大公司由于不知道‘战略是针对顾客心智之战’这一点而陷入麻烦。重要的不是更好的产品，而在于更好的认知。 如何避免无知？ 你首先要研究人们的心理，并且要不停学习。 那你如何才能腾出时间来学习呢？重要的是雇佣可信赖的人。 妄想下一个错误是妄想，如果公司的计划是基于梦想而非事实，这个错误就出现了。大多数成功的公司关注的是事实而不是建立所谓的‘目标’。重要的不是‘你想做什么’，而是‘你能做什么’。过高地估计市场潜力非常危险。 失去焦点‘失去焦点’是一个很普遍的错误，而且通常是由成功导致的。取得成功后，首席执行官便不再专注于核心业务，而是向其他领域扩张。 修修补补‘修修补补’其实算不上是致命错误，但有时它也会带来很大的麻烦。通向混乱状态的道路是由不断的修修补补铺成的。每一个富有激情的CEO都想对公司做些改进，以便借此成名。他们改进产品，不停地扩张产品线，抢占其他业务，渐渐把事情搞得一团糟。 麦当劳就犯了这样的错误，它在已经超负荷的菜单布告牌上增加了44个新的滚动菜品，结果人们开始对收银台前移动缓慢的队伍感到困惑，抱怨不断。 骄傲公司在市场中占据一席之地后，你往往会低估竞争对手，因为你觉得自己强大，富有且见多识广。你不在谦虚，你觉得别人都会犯错误，但你不会。 在这方面做得最好的，最谦虚、最成功的首席执行官就是西南航空公司的赫伯·凯莱赫，许多年来，他都很小心，告诫自己不要低估竞争对手，并始终忠实于‘短程、直飞’的概念。他坚持只用一种型号的小型飞机，只用小型飞机场的战略。他总能正确评估自身所处的竞争环境。多年来，他的航空公司一直是最成功的。 保持简单那些所谓的专家、顾问和骗子会把营销描述的非常复杂，不要相信他们。他们正是靠贩卖复杂谋生的，你要保持简单。 出处：《特劳特营销十要：笔记完结》","tags":[{"name":"营销","slug":"营销","permalink":"http://ijiangnanbei.com/tags/营销/"}]},{"title":"公司标志有多重要？","date":"2017-06-09T13:39:59.000Z","path":"2017/06/09/公司标志有多重要？/","text":"The name is far more powerful than a symbol. A logo should be designed around the name. 品牌的力量在于名称而不是符号。重要的不是符号，而是与这个符号相关的名字。视觉符号还有商标被高估了，品牌的力量在于名称而不是视觉符号。 比如说耐克，是耐克这个名字为“对钩”赋予了意义，他们花了数亿美元将二者联系了起来，因此他们可以将该标志印在服装上而不需要展示其名字，而他实际上就是名字的代表。 对标志的一些研究夸张的风格或设计一定不能以易读性为代价，不管商标设计得多么漂亮，如果难以理解，就要放弃。 在商标设计方面还有其他需要考虑的问题。一个就是形状，最好选择长方形，因为长方形是人类用两眼最容易看清楚的形状，但如果太高或太宽，就不易辨认了。人们犯的最大错误就是将商标设计得让人费解。 有些人使用比名字还大的标志来做商标，还有人让设计者使用一些字体来表达他们认为品牌应该具有的特性。他们强调商标的特征而忽视商标的易读性。有些人选择了难认的字体，而容易辨认恰恰是选择商标所要考虑的最重要因素。 夸张的风格或设计一定不能以易读性为代价，不管商标设计得多么漂亮，如果难以理解，就要放弃。 标志的形状那么独特的形状也可以成为品牌的一部分吗，以绝对伏特加为例，具有独特形状的瓶子就是它的商标，他们通过视觉广告将形状进行了戏剧化的演绎。 标志的色彩色彩能成为区隔品牌的一种强有力的方式，可以通过先占有一种颜色而使它成为身份。不要选择竞争对手的色彩。 像红色、橘红和黄色这样的暖色调往往引人注目，它们充满活力，这对零售是有利的；蓝色调是冷静而保守的颜色，不太吸引目光，柔和易搭配；黑色和金色被认为是高档的颜色；明亮的色彩常常被认为是自由的、快乐的…… 品牌昵称品牌名称的选择要避免毫无意义的首字母商标，它们只有作为地位稳固的公司名称的昵称时才会成为好的商标。通用电气公司是一个很长的名字，因此GE就成了一个好商标，因为人们愿意将之作为昵称来使用。同样，FedEx 代表 Federal Express（联邦快递），而 IBM 代表 International Business Machines （国际商用机器公司）。像 Minnesota Mining and Manufacturing （明尼苏达矿业及制造业公司）这样的名字很难记，因此它会变成 3M 公司。 因此，如果你有一个很长的名那么依据昵称或首字母来设计商标可能就是有用的。但是你要记住，昵称是市场所赋予你的，是人们主动用来称呼你的，不要试图勉强使用一个昵称。如果人们倾向于使用你的全名，那么全名就是你的商标名，并且也应该成为你的商标。 总结因此在选择商标的时候，最重要的是名字，而且要确保它易于辨认。颜色和印刷字体要比一些无意义的符号重要得多，除非那些符号是公司的昵称，而昵称也只能用来做昵称。 出处：《特劳特营销十要：笔记九》","tags":[{"name":"营销","slug":"营销","permalink":"http://ijiangnanbei.com/tags/营销/"}]},{"title":"怎样选择合适的媒体？","date":"2017-06-09T13:24:51.000Z","path":"2017/06/09/怎样选择合适的媒体？/","text":"The mind works by ear. Media with sound is more powerful than media without sound. 广告媒体只有印刷品和广告招牌，然后有了广播、电视和互联网，但这些还只是冰山一角。现在我们拥有各种各样的广告媒介，可以利用像小便池、垃圾桶、公园长椅、饭碗、服装、热气球等你所能想到的任何东西来做广告。 那么你怎样确定哪一种或哪一些媒体才是可以利用的最好的广告形式呢？ 首先，你必须了解不同媒体的优势和弱势。在广告业，一个简单的衡量标准是一种媒体的受众数量。电视拥有相当大的受众数量，广播的受众数量也很大，但是还不够大；印刷体广告拥有较少的受众，并且受众数量呈下降趋势。告示板和广告牌的受众仅限于当地……传媒人员应该能够为你提供某类媒体的受众数量。 虽然互联网是向顾客传递更多信息的好地方，但它并不是一个发布广告的好地方，因为你不能打断节目来传达你的信息，你所能做的就是在别人的电脑屏幕上零散地放上一些信息，而没人想接收它们。 语言与图画如果你仔细分析大量的成功营销项目，你会看到它们都不仅仅是视觉上的，它们更强调听觉，它们都是概念而不仅仅是图片。 两种语言听总比阅读有效，差异有两点：首先，大脑对口述语言存储的时间更长，这能使你更清晰地理顺思路；其次，人们的声音、语调会赋予语言情感，这是单纯的书面文字所不能及的。 也就是说带有口述语言或声音的媒体要比单调的书面文字媒体更好。你的主要媒体是那些带有声音的电视、广播以及电影等，你的次要媒体是那些只有书面文字的媒体，如杂志、报纸等。因此，要尽可能地使用有声媒体。 公关和促销公关非常重要，如果你能够在投放广告之前利用它会更好。相对于在广告中了解到的信息，人们更容易接受新闻中提供的信息。根本原因是，他们不喜欢推销，但是想知道发生了什么。同时，新闻中的有关信息也会给你的产品带来很高的可信度。 对于促销而言，有些促销方式有助于产生一些公关效应。例如，用大象在商业中心游行的方法推出你的新产品；某些特别的优惠有助于引来消费者试用你的产品。但如果促销仅仅是打折，其作用就微乎其微，无休止地通过打折促销产品只会让你的顾客买促销品。促销是吸引消费者的不当方法。 整合营销一旦确定了差异化信息，你就可以利用各种不同媒体的优势来进行传播。 但是怎么做才能将它们整合在一起呢？ 这就是整合营销，它是营销人员所追求的‘圣杯’。在整合营销中，你要让差异化信息通过各种媒体进行传递。一旦确定了差异化信息，你就可以利用各种不同媒体的优势来进行传播。公关能够帮助你推出新理念，赋予其可信度，并制造话题；广告能够迅速为这一理念建立认知度；展览会能够在行业内或产品分销渠道中引起兴奋；直邮可以将你的理念推荐给你最好和需求量最大的那一部分顾客；促销能够吸引人们试用新产品。 但你首先要有差异化信息。如果没有差异化，就只会造成一片混乱。这就是整合营销难以把握的原因。 总结首先应确保拥有差异化信息；其次，如果可能的话，通过公关将其推出；再次，将我们的资金投入到那些有声的媒体上；最后，不要把促销做过头。 出处：《特劳特营销十要：笔记八》","tags":[{"name":"营销","slug":"营销","permalink":"http://ijiangnanbei.com/tags/营销/"}]},{"title":"如何评估广告？","date":"2017-06-09T13:07:52.000Z","path":"2017/06/09/如何评估广告？/","text":"Good advertising dramatizes a product’s point of difference. It supplies a reason to buy. 因为你无法亲自面对潜在顾客，因此需要广告。你可以通过电视广告或印刷广告来讲述品牌故事。 任何广告计划都应从你想传达的产品差异化开始——为什么要购买我的产品而不是其他人的产品。你所追求的不是一个无意义的口号，你的计划必须包括差异化及其所能带来的好处。 广告公司的基本作用是掌握产品的差异化，并将其戏剧化。人们对媒体感兴趣是因为喜欢它的娱乐性和信息价值，而不是因为他们急于看到最新的广告。广告公司可以利用幽默或是其他任何手段，但广告必须要传达购买这种产品的理由。如果你喜欢广告公司的处理方式，你就可以批准，你也可以要求加入更多的戏剧效果。但是，除非你让人们买票观看，否则这样的广告是没什么用的。 坦诚且有新闻价值人们看到一则广告，就会对广告有所了解。由于这些广告往往会打断他们的观赏或阅读，因此，对于这些不得不看的广告，他们会感到不快。没人喜欢推销，所以些许坦诚就显得非常重要。这种诚实能够消除敌意。如果你诚恳地对待别人，别人才会真诚地对待你。如果你的产品有一点美中不足，就要承认这个事实，然后再陈述它的可靠性，这样人们才会愿意购买它。 比如说公猪王为它的350种熟食产品所做的广告就既坦诚又效。他们公开将竞争对手的产品与自己的优质肉制品进行比较，其结论很简单——‘接近公猪王的品质，但不是公猪王’。他们说服人们多花点钱购买质量更好的肉制品。 记住，你越坦诚，人们就越觉得它是信息而非广告。 此外，还有一种重要方法——要尽量使你的信息听起来像重大新闻。人们总在寻找新闻，新闻能够消除广告商与观众之间的敌意，它能使人们放下‘被推销’的戒心。相信我，如果广告开端是播音员在说‘在你按下遥控器的按钮之前，请让我向您播报一条重要新闻’，那么每位观众都会牢牢地坐在椅子上。生动的视觉材料虽然会吸引人们的注意力，但同时也会分散人们对信息的关注程度。并且，在人们的注意力被分散时，他们会停止听和读。这样的广告起不到推销的作用，这也叫做‘视线转移’。 魔术师为了掩饰他们正在做的事，通常不得不转移你的视线，让你错过实际发生的事情。这是广告中最应避免的。 事实上，广告公司喜欢做所谓有创意的、与众不同的广告设计，这样它们就能得到其他同行的赞赏，而你却不得不为这样的广告设计支付费用。不幸的是，你却无法将那些奖品存入银行。 简单、明确、保持耐心谨防广告复杂化。你不能占用人们太多的时间，因此你必须使广告简单易懂。一条信息比两条信息要好，简单的视觉材料比丰富的视觉材料更佳。 告诉你一个简单的技巧——如果可以的话，使语句押韵，这可以使你的广告语更容易记忆。 更重要的是，你寻找的是显而易见的概念。它往往简单、普通，缺乏想象力，但是最显而易见的概念也是最有用的。 同时，还要有耐心。广告被人们记住是需要时间的，因此必须将你的信息保留较长一段时间，以待人们接受它。可能当你已经厌倦了一条信息时，潜在客户才刚开始注意到或是记住它。 ### 总结 当你开始评估广告的时候，首先要避免无意义的空洞口号，寻找产品的差异化。我应该看广告是否戏剧化地表现了差异化，信息的诚实度怎样，信息表述是否简单，是否向我的客户提供了有趣的新闻，这些新闻是否能够让他们在日后受益……如果广告能做到以上几点或全部就是好广告，反之就是无效广告。然后，我应该耐心地等待广告发挥作用。 还有一个建议——当你看到一个广告，它是由世界上最优秀的广告公司推荐的，由伟大的创意天才设计的，整个营销部门都支持它，而你又不知道该如何评价时，回家问问你的太太吧。 出处：《特劳特营销十要：笔记七》","tags":[{"name":"营销","slug":"营销","permalink":"http://ijiangnanbei.com/tags/营销/"}]},{"title":"什么是好的市场调研？","date":"2017-06-09T12:47:18.000Z","path":"2017/06/09/什么是好的市场调研？/","text":"Good research is simple, not complex and all about perceptions. It should contain a strong degree of common sense. 广告公司开发出各种调研系统，以便给客户留下深刻的印象。它们打着‘品牌蓝图’或‘品牌着陆点’这样的旗号到处招摇。它们询问关于品牌个性的愚蠢问题，像‘如果品牌是人的话，他应怎样着装’或‘如果你能想象的话，他会参加什么样的聚会’之类的问题… 我们之所以要调研，其实就是为了从人们那里得到一些有用的信息。但是，马克吐温说过一句话：“人只有在死的时候，才会表现出真正、完整和诚实的自我。” 总而言之，这就是调研中所涉及的首要问题——人们不是很诚实。 言行不一人们的言行常常不一，当你问他们为什么买一种东西时，他们的回答常常不是很准确，也没有什么用。 也许他们了解真正的购买原因，但不想吐露实情。然而，更多的情况下，他们确实对自己的确切动机知之甚少。 从众消费人们很少购买他们本来想购买的东西。 在某种程度上，购买者就像是随群的羊——从众心理发挥着重要作用。关于从众行为，罗伯特·西奥迪诺的一段文字最有趣。他谈到‘社会认同法则’具有强大的影响力。该法则称，我们先弄明白别人认为什么正确，然后以此决定什么是正确的。在人们判断什么样的行为是正确行为时，这个法则特别适用。我们在判断某种情况下的行为是否正确时，是以自己看到别人在此种情况下的行为为依据的。 其实人们并不知道自己确切想要什么，既然如此，那我们为什么还要去问他们呢？ 获取心智快照你真正想要的是心智中的认知快照，而 不是深入思考。人们除了自身的健康、财富及性生活以外，不会过多地思考其他东西。 你要寻找的是你和竞争对手在目标客户心智中的认知优势和劣势。比如说你可以列出某一品类的基本属性，然后让人们按1～10分的等级打分。这种做法是以竞争对手为基础的，目的是了解在某一品类中，各方所拥有的概念和认知。你也可以把它称为‘差异化实验’。 就拿牙膏来说吧，围绕这一产品，有许多特性可以考虑，像预防蛀牙、清除牙垢、口味、增白、去除口腔异味、天然成分以及高科技等。 佳洁士品牌构筑于防蛀上，Aim 牙膏口味好，UltraBrite 洁白牙齿，皓清清新口气。最近，Tom’s of Maine 抢占了天然成分特性，Mentadent 则凭借烘焙苏打和过氧化物技术成为高科技品牌，Topal 声称能去除烟渍，而高露洁则是凭其‘全效牙膏’重新攀升到了第一的位置。高露洁全效牙膏包括三个特性：预防蛀牙、清除牙垢和杀菌。 每个人都应该拥有自己的特性，对于成功的品牌来说的确应该如此。诀窍是你提前弄清楚你想在潜在顾客的心智中拥有怎样的特性或差异化。市场调研应该提供消费者心智地图，帮你了解竞争对手的认知。 所以，好的市场调研无须浪费时间去发现人们想要什么或去探求他们的心理。它实际上就是设法衡量自己在潜在顾客心智中相对于竞争对手的差异化。 对未来的思考意想不到的事情总在发生，而意料之外的事情本来就无法调查出来。想要调查新的概念几乎是不可能的，因为人们必须亲眼见过、亲身试用过、看到别人买过，才会对某种东西做出评价。 发现趋势是你应对未来的最好方式。但是发现趋势是需要技巧的，最常见的错误是夸大趋势。如果依据几年前对红肉的预测，今天所有的人可能都在吃烤鱼片或烤鸡肉了，但是这样的事情并没有发生——非但没有发生，红肉的消费量反而上升了。 基本习惯的改变是很缓慢的，而媒体却常将较小的变化过分夸大。与夸大趋势同样糟糕的是假定未来会是历史的重演。假定不会有任何变化和假定某些事物一定会发生变化一样，是在肯定地预测未来。记住，意想不到的事情总在发生，而意料之外的事情本来就无法调查出来。 出处：《特劳特营销十要：笔记六》","tags":[{"name":"营销","slug":"营销","permalink":"http://ijiangnanbei.com/tags/营销/"}]},{"title":"增长有限度吗？","date":"2017-06-09T12:22:11.000Z","path":"2017/06/09/增长有限度吗？/","text":"Successful companies are never obsessed about growth. They are obsessed about succeeding in the marketplace. 你最好相信增长是有限度的。 大多数糟糕的首席执行官会追求增长率以保住位置，提高声望，增加薪金。但是如果你只是靠数字生存，最终你会栽在这些数字上。 另一个问题是，公司总是生产适合所有人的东西。这种增长策略本应集中于主要业务上的资源浪费在了毫无意义的次要战役上。如果聚焦一项业务，做决定就简单多了。 不要专注股票管理层更多关注的往往是股票价格而非市场。许多公司都有股票期权计划，这会滋生不负责任的贪婪文化。这通常又会导致短期思维，诱发破坏长期营销计划的短期行为. 专注专业不要偏离基本业务太远。常言道，不要舍本求末。 但是，如果你在核心业务上已经感到精疲力竭时，该怎么办呢？难道你就不能转向其他业务吗？当然是可以，但是你必须在原有业务的基础上发展，这样你就可以利用你的信任状和专业知识了。 如果为了扩大业务认知度，向顾客提供更多相关产品或服务呢？这个时候，如果你生产工具，那你可以发明新式工具。或者，如果是施乐，它可以发明新的复印方法。但是你得小心，这种思维容易让你掉进满足所有人需求的陷阱。 如果你的业务是为了取得好的财务结果，而不是为了提供好的产品和服务，那你就有麻烦了。 专注认知品牌的生产以人们对其的认知为基础，一味地迫于华尔街的压力，无视品牌的特性，盲目地扩张业务，只会给你带来麻烦。 宝马们始终聚焦高价车，认为生产大众汽车会损害对宝马豪华品牌的认知。 面对现实如何才能避免陷入增长的陷阱呢？ 在制订计划和做出承诺时要尊重现实。记住，竞争者总在试图攫取你的业务。罗伯特·布鲁纳就曾写道：‘经理必须接受商业很诡异这个事实。机会与危险可能是出人意料的。优秀的经理人相信现实而非幻想。 设定现实的目标，像弗兰克·泰普的精彩定义那样——“在你伸手能及之外，在你力所能及之内”。 你必须认识到，不可能就是不可能。你不能在营销计划中加入不现实的思想，你要找到利用已有认知销售更多产品的途径。例如，如果对你的潜在顾客有意义的话，你可以增加产品式样。宝马拥有一系列不同款式的车型，但是那些都是豪华汽车；保时捷以跑车闻名，试图销售一辆保时捷的休闲旅行车就显得毫无意义，销售带有四车门和后挡板的保时捷也是很愚蠢的。 你提供的产品越多，就越容易失去焦点，也就越难实现差异化。马克·吐温说得好，‘我无法为你提供成功的公式，但我能给你失败的公式，那就是，试图取悦每一个人’。 总结你要提升品牌，就必须围绕着你的专长展开——要不断地问自己‘它对于你的顾客而言是否有意义’、‘它是否符合你的声誉或形象’。制订计划时你还必须非常实际，确定那是你能做到的。同时，你不能让华尔街为你制订计划。 出处：《特劳特营销十要：笔记五》","tags":[{"name":"营销","slug":"营销","permalink":"http://ijiangnanbei.com/tags/营销/"}]},{"title":"如何看见未来？","date":"2017-06-07T04:04:01.000Z","path":"2017/06/07/如何看见未来？/","text":"关于未来，无论你身处何处，你的身边总会有这样几类人。 无所事事，每天就是不知道该去做一点什么。 人云亦云，别人做什么我就跟着一起去做一点什么。 心比天高，满脑子的梦想但就是找不到方向，不知道该从哪里入手，像一只无头苍蝇一样在那里乱撞。 其实他们都没有错，因为他根本就不知道自己这样做到底是对还是错，他们也从来没有想过自己到底因不应该这样做。就好像一个人如果没有见过白天，他是不会知道蓝天的美的。 有的人会说，那有什么关系，有些人终究会知道。是的，我不否认这一点，有些人终究会知道，但是这里面要加上一个时间的维度，你等得起时间，但是时间等得起你吗？ 有这样一句古话“善有善报，恶有恶报；不是不报，时候未到”，我相信很多人都在心里犯嘀咕，事实真的是这样的吗？是的，事实真的是这样的。那你肯定又在想那我怎么没有看到呢？因为这句话的后面还有半句“时候一到，一切都报”，你之所以没有看到是因为你等不起那个时间！第一类人是我们生活中最多的，随处可见，触手可及。在我刚进大学的第一天，学院领导就找来了即将毕业的学长学姐给我们“传受经验”，比如说大学是什么样的呀，考试挂科会怎么样啊，是不是该谈一场轰轰烈烈的恋爱呀…学长们传授完经验，站在上面的老师说：“同学们还有没有什么想知道的？”，我站起来说：“我想问一下学长学姐你们有谁明确的知道自己的梦想是什么？如果明天你就毕业，你出去之后能做什么？”和我想的一样，张口结舌、面红耳赤，一时间江良才尽，无言以对。 说到这里我想起了我上大学之前我的启蒙老师语重心长的对我说了这么一句话：“要学会辨识那些阻止你变得优秀的人，即使你们的关系非常好，你也要学会理智的放下情感的包袱，远离他！”。 当时我的感受现在看到这句话的你们的感受是一样的，“怎么可以这样”。即便如此，我没有问我的老师为什么，我只是把这句话默默地记在心里，时不时的拿出来想是想，偶尔心里还在纠结，这句话是不是说错了。现在如果你问我大学里你学到的最有用的东西是什么，毫无疑问，就是在我上大学之前半信半疑放在我心里的那句话。 第二类人，我们生活中也不少。这种人是既然我不知道自己要干什么，那我就去看看别人在干什么，然后我也去做。这种方法如果你用的合理有时候也不失为一个好方法，比如说你可以这样做，既然我不知道自己要做什么，那我先去看看那些优秀的人在做什么，然后我跟着去做。 比它高一个等级是这样的：既然我不知道自己要做什么，那我去就看那些优秀而且符合我对自己未来道路方向偏离不大的人他们在做什么，然后我跟着去做。 再高一个等级呢？既然我不知道自己要做什么，那我去就看那些优秀而且符合我对自己未来道路方向偏离不大的人他们在做什么，我先跟着做，在做的过程中慢慢的修正方向，让他最终符合我对未来的自己所期望的那条道路。 第三类人，也就是以前的我，总是觉得自己无所不能，什么都想去做，但是最终却什么都做不好。为什么会这样，因为你的梦想太大，你想做的事情太多了嘛。人的一生就这么短短几十年，你精力的它总是有限的。专注才能专业，聚焦才能聚财嘛！ 那我们怎样才能有预见性的看见自己的未来呢？首先你要知道你的生命还有未来，还有诗和远方，如果你说我就满足于眼前的“苟且”，那谁也帮不了你。如果满足了我所说的最基本的条件。那么，来让我告诉你答案。 逻辑思维的罗胖说了这么一句话：“一个人想要变得优秀，方法有二。追求上进，死磕自己；结识牛人，拓展社交”。有的人看到我的说的答案，不屑的一笑地说，这难吗？难！真的很难！ 先说“追求上进，死磕自己”，你要知道，所谓的成功他是一个漫长的过程，不像你说我今天感冒了，明天打一针它可能就好了。这个漫长的过程可能是五年，十年，二十年…这个是谁心里都没有底的。就算是真的有一个人告诉你，你接着死磕啊，十年后你就能成功了。你真的就能死磕下去吗？ 再说“结识牛人，拓展社交”，在这个社交网络如此发达的时代，你可能会问，不就社交嘛，这有什么难的，我打开手机动动手指头不就搞定了吗？在这里我首先提出一个观点，社交网络越发达，人们的社交将会变得越来越难。 因为你要知道，人类他是一个群居动物，在社交网络中他找不到群落里面的那种信任感，这就不足以让他在社交网络里产生信任，没有信任的社交它能是社交吗？其次，结识牛人首先你自己得是一个牛人，社交的本质它就是“利益交换”，一个牛人，他的精力就这么多，他的社交圈就只能是那些至少不比他差的牛人，如果你不是，对不起，这个圈子你进不来。 那我们到底该怎么去做呢？答案很简单：脚踏实地，咬牙坚持，持续改善，然后耐心的等待时间的回报。这就是你废了这么多话给出的答案吗？是的，这就是答案。 传说这个世界上存在着一种神奇的东西，它无影无形，却又无处不在，轻若无物，却又重如泰山，如果能获知这样一种东西，就能够了解这个世界上所有的奥秘，看透所有伪装，通晓所有知识，天下万物皆可归于掌握。这并不是传说，而是客观存在的事实。 这样东西的名字叫做“坚持”，就这么简单，但是他就是那么难，无数的人在和它对峙的时候无不面红耳赤、羞愧难当。 记住：找到目标然后脚踏实地的坚持，虽然不知道未来会有多好，但未来一定不会太差。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"如何正确定价？","date":"2017-06-06T08:34:10.000Z","path":"2017/06/06/如何正确定价？/","text":"A price is what a customer will pay for your point of difference and what your competitors will let you charge. 1.定价原则首先，你必须保证产品价格合理。市场确立后，行业定价水平会很快被市场接受。如果你的产品价格过高，就会招致风险。你的顾客会开始对自己付太多的钱产生质疑，这会为竞争对手夺走你的业务大开方便之门。 其次，人们愿意为可感知的价值多付些钱。如果你的定价合理，只要顾客感到物有所值，他们还是会选择价格更高一点的‘包间席位’。塔吉特就是最好的例子。尽管它是在同对所有大经销商都具杀伤力的大品牌沃尔玛竞争，然而，由于利用了设计师品牌，人们觉得它是‘有品位的大众商品’。也就是说，你虽然多花了一点钱，但是你买到了更加优质的商品，又不会像在大型百货商店或专卖店中那样昂贵。这说明了另一条价格策略，那就是‘高质量产品理应价格更高’。 人们愿意为更好的产品花费更多，但高质量要在某种程度上明显可见。 高价位产品应该彰显声望。 如果我花 5000 美元买了一块劳力士手表，我就希望邻居和朋友都知道我戴着一块劳力士手表，这样他们就知道我很成功。昂贵的汽车也是如此。虽然人们可能从来都不承认，但他们花5万美元买一辆汽车，往往就是为了给朋友或邻居留下深刻的印象。高价格能说明什么呢？它说明产品的价值很高。 从本质上说，昂贵的价格已成为产品本身所固有的优势。雷克萨斯比英菲尼迪售出了更多的汽车，因为雷克萨斯的品牌被赋予了更高的声望。但是要谨慎寻找高价的理由。雷克萨斯强调‘完美’，劳力士强调‘每块手表花费一年时间制造’。人们购买提供声望的品牌时，需要为多花的钱找个理由。 2.如何应对低价入侵者？此外，新的进入者往往会利用价格做诱饵闯入某一领域。如果竞争者强大且地位稳固，新的竞争者通常会采用低价战略。不能任由它们建立强大的网络，你应该尽快找到一种方法来反击它们的价格战。这就是下面要说的一条指导原则：‘高价格和高利润吸引竞争对手’。 一旦竞争对手嗅到你的成功，它们就会蜂拥而至，想要分一杯羹。聪明的公司是不会高价牟利的，它们会保持低价，以求最终控制市场并使新的竞争者丧失信心。 另一个重要的指导原则是，很难以低价获胜。将自己定位于高价产品是一回事，利用‘低价’战略则是另一回事。几乎没有公司能靠低价取胜。这是因为所有的竞争者手中都有一支笔，它们能在任何时候标低价格，这样你的竞争优势就消失了。正如迈克尔·波特所说的：‘如果其他竞争者也可以像你一样降价，那么降价通常并非明智之举。’ 最后，价格会下降。随着生产量的增加、货币贬值以及竞争的加剧，旧有的规则发生了变化，价格会呈下降趋势，尤其是在商品品类上。这就需要一个新的战略，比如以独特的方式来增加价值，或寻找独特的方式来降低成本。 3.在生产过剩的品类中如何作为？答案很简单，必须通过提高工人生产效率来降低成本。 4.总结制定价格的关键是弄清楚顾客愿意为你的差异化或附加价值支付多少。但是要记住一件事，人们只是愿意多支付一点而不是很多，你必须把你的价格水平保持在合理范围之内。 出处：《特劳特营销十要：笔记四》","tags":[{"name":"营销","slug":"营销","permalink":"http://ijiangnanbei.com/tags/营销/"}]},{"title":"你的产品战略应该是什么？","date":"2017-06-06T05:24:26.000Z","path":"2017/06/06/你的产品战略应该是什么？/","text":"第一第二或者新东西 1.论第一你所需要的是第一或者第二的品牌，或者是一个全新的子品类品牌。 营销的基本问题是开创一个新品类，让自己成为其中的领导者。这就是领先原理：第一胜过更好。相比说服人们相信你拥有比先前产品更好的产品，第一个进入心智要容易得多。 在每个品类中，领先品牌几乎都是第一个进入潜在顾客心智的品牌，如电脑业中的IBM、软饮料行业的可口可乐和咖啡连锁业中的星巴克。 第一品牌往往会保持其领先优势，原因之一是它的名字常常会变成该品类的代名词，如邦迪创可贴、万能胶、舒洁纸巾以及棉签等。 原因之二是，强大的领导者会用更好的概念或新一代产品进行自我攻击。剃须刀领域的吉列就非常擅长这一方法。每隔一两年，吉列就会进行一次更新换代。这就是竞争对手永远无法超越吉列的原因，也是吉列能始终保持65%的市场份额的秘诀。 因此，如果有人给出了一个可能会成为某一新品类中领导者的产品创意，你可以毫不犹豫地批准它。 2.论第二如果你保持强有力的替代战略，你也可以成为非常成功的第二产品。 一个产品总是有很大的机会成为第一品牌的替代品。但是要注意，仅仅提供与头号品牌相同的东西不可能成为成功的替代品，你必须用改进产品或是针对不同的细分市场或顾客群的产品来攻击头号产品。如可口可乐是针对年纪稍大一些的人的，百事可乐则是针对年轻人的。如果你保持强有力的替代战略，你也可以成为非常成功的第二产品。 要当第一或者第二。如果你是第三，你的前景就不容乐观了；如果你是第四，这会是致命的。如果你怀疑第一或第二的力量，那就看看杰克·韦尔奇把这个概念应用在通用电气公司上所获得的成功吧。 二元法则 长期来看，每一个市场都是两马并驾的竞赛场。在胶卷业是柯达和富士，漱口液领域是李施德林和Scope，汉堡类是麦当劳和汉堡王，运动鞋是耐克和锐步，牙膏是高露洁和佳洁士…… 如果你长期观察市场，你就会发现，每一场战争最终通常都是两个主要竞争者之间史诗般的斗争——一方是旧有的可靠品牌，另一方是后起之秀。 3.论新品创建一个新品类是一项很大的工程，但是一旦品类形成，你就有机会创建子品类了，营销专家称之为‘细分市场’。 戴尔利用电话和现在的互联网直销电脑，在竞争激烈的个人电脑行业做到了这一点；西南航空公司第一个经营国内短途航线，在航空业做到了这一点。 这一观点与传统的、以品牌为导向的营销思路是相反的。怎样才能让人们更喜欢我的品牌呢？忘掉品牌，先来考虑品类吧！每当谈及品牌的时候，潜在顾客总是摆出防御姿态，因为人人都说自己的品牌更好。但是提到品类时，潜在客户就会持开放的心态，大家都会对新产品感兴趣，但很少有人对更好的产品感兴趣。 4.论品牌延伸对于品牌延伸，你应该像对瘟疫一样避开它！ 对于品牌延伸，公司是从经济角度来审视品牌的，为了获得成本效益和行业认可，它们非常愿意将只代表一种产品或概念的高度聚焦的品牌，转变成代表两三种或者更多的产品或概念的毫无聚焦的品牌。 但是从心理学的角度来看待品牌延伸。品牌延伸出来的产品种类越多，心智就越容易失去焦点。渐渐地，像雪佛兰这样的品牌就毫无所指了。 5.总结在开发新产品方面，应该首先考虑建立领导品牌。如果我们是第一品牌，则要确保我们的人用更新、更好的产品不断挑战自己。 其次，如果我们不是领导者，我应该确保我们处于第二位的品牌致力于攻击领导品牌，并成为一个强有力的替代品。 最后，既有品牌的新产品应着眼于成为子品类的领导者，关注细分市场。我应该不惜一切代价避免跟风和品牌延伸。 出处：《特劳特营销十要：笔记三》","tags":[{"name":"营销","slug":"营销","permalink":"http://ijiangnanbei.com/tags/营销/"}]},{"title":"如何把握市场趋势","date":"2017-06-05T07:44:57.000Z","path":"2017/06/05/如何把握市场趋势/","text":"1．一定要研究社会视点对社会视点的研究，包括政治、经济、文化等各个方面，因为这些变化往往可影响市场变化，由此进一步引发市场上对某种产品的需求。 有时候，对某产品的需求，一夜之间会急剧增加；有时候，会一下子烟消云散。例如：美国民主党总统候选人奥巴马赢得总统选举前后，众多枪械爱好者因担忧奥巴马未来执掌的政府可能限制一些攻击性枪械销售而在美国国内枪械店竞相采购，掀起了一股“购枪热”。 若能及时敏锐地感受和把握到这种市场变化趋势，并能立即采取应变措施，使顾客由此而引发的需求得到满足，就会获益良多，在短期内收到立竿见影的效果。反之，如果市场上对某种产品需求的趋势已经出现衰退或正在迅速衰退，而自己对此却毫无察觉，则难免会首当其冲蒙受巨大损失。 而要想及时了解这种市场变化情况，或者说对市场变化保持敏锐的触觉，惟一的办法就是：做好经常性的市场调查研究。市场分析的一个重要内容就是市场调查，只有通过市场调查，才能得到来自市场的第一手的详实资料。大公司可以通过设置专职部门，负责进行此项工作。中小企业通常难以仿效他们的做法。但是，如果对其他途径和方法运用得当，同样会收到良好的效果。这些途径和方法有：经常订阅有关行业的各种期刊杂志；参加行会或其他专业性的社团组织；争取多参加某些贸易展销会等。同时，也要密切注意你所组织的各类营销业务活动的效果，洞悉变化情况，查明造成销售增长或销售衰退的原因。 ###2．要及时捕捉市场机遇 市场机遇，也就是我们常说的商机，随着计划经济向市场经济过渡进程的发展，把握和利用市场机遇的能力，已成为企业及其经营者参与市场竞争的必要条件，以下原则和方法或许有益于我们把握市场机遇。 关注热门行业：热门行业都是新兴的朝阳产业，具有夕阳产业无法比拟的巨大的生产力，往往呈现出诱人的前景，如计算机业、房地产业、生物工程业等。其发展迅猛，机会多多。当然，同时，热门行业也就意味着竞争激烈，风险多。因此，作为创业者，在从业过程中，就必须有成功与失败两种思想准备。 寻找市场空白：在各个市场领域之间，或在一个市场领域内部，总是存在着各种各样的缝隙，寻找市场空白，填补经营缝隙的方法，成功率非常高。例如，在美国竞争激烈的空中航运市场上，美国西南航空公司就是采取在市场缝隙中求发展的策略，击败众多竞争对手而后来居上的。它专门寻找那些收费高、服务差的航空公司作为取代对象，常常开辟大公司弃之不用的小城市之间的航线。它不提供其他航空公司普遍提供的一些服务，如转运行李、供应膳食、预订机票、代理旅游业务等，但它所提供的服务却具有更高的价值，如航班多，服务好，票价低。 当然，在常盛不衰的行业中寻求市场机遇也是一种方法，如妇女用品、儿童用品、饮食行业、娱乐行业等。不过，其难度相对较大，要想从竞争对手手中抢到生意，必须具有高度的创造性、丰富的经验和广泛的社会关系。其实，市场机遇处处可见，重要的是你能抓住苗头，长于推理，由此及彼，由表及里，弄清其本质规律，最终必能如愿以偿。 3．敏锐发现新的市场需求现代生活方式的变化必然会产生新的市场需要，如果你能敏锐地发现那些新的市场需求，也就是比别人更快地发现了挣钱的着眼点。 例如，用金钱购买时间，就是现代都市人的时髦选择，因此，围绕着快节奏生活需求的服务项目都大有文章可做。在吃的方面，必然要求快餐食品种类更多、数量更大、服务更好；在穿的方面，人们更偏爱随意、自然、舒适、简洁的服饰，在非正式场合较少穿着一本正经的西装；在住的方面，也有一些服务类项目可以进行，如家务钟点工、维修工、物业管理服务等；在用的方面，快递、上门装收垃圾、上门美容理发、看病治疗等项目日渐兴起；在行的方面，汽车出租业向乡村发展，围绕着交通和汽车用品市场开展生意，前景也非常广阔。 另外，随着人们生活水平的提高，享受生活的观念也产生了更多新的市场需求。例如，寄养宠物、照料花草等各种“代”服务正悄然升温。","tags":[]},{"title":"商业的本质是什么？","date":"2017-06-04T14:43:32.000Z","path":"2017/06/04/商业的本质是什么？/","text":"价值的本质是什么？是稀缺性！不要以为有价值就有价格，空气最有价值，但是不具有稀缺性，他就没有价格。 前两天我在和一位朋友聊天，他的观点比较消极，大致意思就是大多数穷人，农民工的孩子受不了好的教育，然后继续成为了穷人，农民工，如此循环往复…… 去年暑假回家，我的另一位朋友和我聊天，他跟说了这么一句很有意思的话：“我老爹从小告诉我说，你要是考不上大学，你就得和我一样当一辈子农民。但是我没有上大学现在不是过得挺好的嘛。”我的这位朋友在去年买了自己的第一辆车，他就告诉我说他就只会两件事：1.会来事，2.会按摩。他的朋友多，他的按摩技术是他所在的地方按摩技术最好的，这就是属于他自己的不可替代的稀缺性。 你的报酬不是和你的劳动成正比，而是和你劳动的不可替代性成正比。在这个时代只要你不懒惰，勤于思考，勤于协作，你就能创造属于自己的不可替代的稀缺性。这个稀缺性哪里和你有没有上过大学有关系，哪里和你有没有干爹有关系，这个稀缺性是这个时代赋予你的，谁都夺不走。也许未来的某一天会发生这样一件事，一个青年才俊上完大学，流洋海外，多年后回国在一家大公司任职，朝九晚五的工作，好不容易有一天假期出去打打高尔夫，恰好在高尔夫球场的高级教练就是他当年没高中毕业的中学同学，活的自由拿着和他一样的百万年薪。 商业他有大半个身子都还藏在暗影之中，很多人就像盲人摸象里面的那个盲人。如果商业是一头大象，那么现在在我的心中我只看到了大象那只腿，所以现在在我的心中商业就是那根“柱子”，但是我发现有时候我一不小心就看到了那只大象，就只有那么一瞬间，总有一天我要把它从暗影里面拉出来，指着他的鼻子说：“好小子，被我逮到了吧”。 假设我们认为他现在就是一只大象，我相信当我们发现他的时候他一定不再会是一只大象，他一定是一个我们不知道的东西。《百年孤独》里面有这么一句话：“世界新生伊始，许多事物还没有名字，提到的时候尚需用手指指指点点。”到时候我们对别人提到他的时候会指着他对别人说，就是他，就是他。 说了这么久有人就要问了，那你说到底什么是商业？我会说商业的本质是钱，钱的本质是价值，价值的本质是稀缺性……说简单一点其实就一个字——“人”。商业，这个话题太大，需要我们持续的去探索和发现。 我觉得无论在那个时代，不管你是企业还是个人，是小公司还是一个小的组织，你都需要记住一句话：“大到极致，小到入微。”什么叫大到极致？说白了格局要大到极致，要学会放眼全局，你不要只看到腾讯和阿里在争夺支付入口，你要知道他们想要的到底是什么。什么叫小到入微？做事要小到入微，宽度一微米，深度一公里，你要学会先用轻型武器试水，精确定位，找准靶心，然重型武器配比弹药，定点清除，永绝后患。 今天看了老罗 Smartisan T2 的新品发布会，有两句话我想分享给大家。 “未来属于我们当中那些仍然愿意弄脏双手的少数分子” “通往牛逼的路上，风景差的让人只想说脏话，但创业者在意的是远方” 你永远不要觉得有些东西离你太远，你可以选择拒绝，因为时代也是这么做的。马云说过一句很有意思的话：“这是一个抢钱的时代，哪里有时间和那些思想还在原始时代的人磨磨唧唧”。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"},{"name":"商业","slug":"商业","permalink":"http://ijiangnanbei.com/tags/商业/"}]},{"title":"我所理解的商业","date":"2017-06-04T12:26:32.000Z","path":"2017/06/04/我所理解的商业/","text":"写完了《迷茫时代的明白人》的读书笔记，忽然想谈一下自己对商业的一些所见所闻所感。智识有限，也许多年以后的我回头来看自己当年写的这篇文章就会像现在我看大多数人的文章一样说一句“写的什么东西！”。但是灵魂深处的另一个我还是劝我写点吧，于是你就看到了这篇文章。 2015年我大言不惭，脸不红，心不跳地给一个非常喜欢做生意，情商高，智商高的好朋友说我理解的商业，我给他说了下面这些话…… 商业，我认为有五个等级。买卖，生意，企业，模式，资源整合，资本运作！ 什么是买卖？买卖就是你用五块钱买一块布，然后你以十块钱卖的价格卖出去，这就是买卖，在这个过程中产生了两倍的“资本溢价”。 什么是生意？生意就是你买来一块布，把这块布做成了衣服，然后以五十块钱的价格卖出去，这就是生意，在这个过程中产生了五十倍的“资本溢价”。什么是企业？企业就是我买来一块布，把它做成了衣服，然后把这件衣服做成了品牌，我有了自己的仓储，物流，供应链，我把衣服发给我的分销商，这时候我再把这件衣服卖出去价格可能就是五百元，这就是企业，在这个过程中产生了五百倍的”资本溢价”。 什么是模式？模式就是我买来了一块布，把这块布做成了衣服，把衣服做成了品牌，这个时候我不去建立自己的仓储，物流，不去搭建自己的供应链，不去弄那些，弄那些有什么用，没用！这个时候我把仓储，物流全都外包出去，甚至在这个时候我可以不去搭建自己的供应链，因为在这个时代最好的供应链就是“人”。然后我把更多的钱投入到我对产品品质的把控，质量的提高，款式的卓越追求，粉丝生态圈的营建，对用户诉求的深度挖掘，然后我们用“态度营销”去塑造去培养以穿我做的服装引以为豪的那一小撮人，没错，我们需要的就是那一小撮人，因为在这个时代你永远不要不屑于个人力量的崛起，尤其是一群有“态度”的一小撮人。 什么是资源整合？什么是资本运作？关于这些我懂得其实也不是很多，这里就暂且不说了。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"},{"name":"商业","slug":"商业","permalink":"http://ijiangnanbei.com/tags/商业/"}]},{"title":"建立品牌","date":"2017-06-03T05:02:16.000Z","path":"2017/06/03/《特劳特营销十要：笔记二-建立品牌》/","text":"Branding is all about differnetiating your product or company in the maid of your customer. 产品制造于工厂，而品牌是在心智中创建的。 1.品牌名称一个好的名字对取得成功有很大的帮助。 最好的品牌名称是与产品的优势卖点相关联的。比如‘长命’就是一种耐用电池，‘一擦净’就是一种玻璃清洁剂，而‘深度护理’是一种护肤乳。 另一个窍门就是使用听起来很美好的名称，比如‘关爱’沐浴香皂或‘特甜蜜’糖精，等等。在很多情况下，记忆是靠听觉形成的，因此你要回避那些听起来很奇怪的名称，像优耐陆、安捷伦或是齐乐格，而应该选择一些动听的名称，如悍马或讴歌。 由于品牌是在心智中创建的，所以，你所能做的最重要的营销决定，就是如何命名产品。名称是心智中的挂钩，上面挂满了小衣架，人们用这种方式存放品牌。一个易于记忆的好名称会是一个好的开端，而糟糕的名称则可能会引起很大的麻烦。 2.品牌战略品牌战略的目的是为产品或公司在你所属的领域建立差异化，像杰克·特劳特所说的——如果你没有差异化，你最好能够提供较低的价格。建立品牌的关键是想办法表达你的差异化。如果你更快、更迷人、更安全或更新颖，就很容易做到这一点。但通常是你不得不去寻找其他一些非产品本身的特性，比如领导地位、消费者偏好和传统观念等。无论你选择了什么，你都要利用它们来为你的顾客创造利益。许多公司恰恰不能理解这一点，它们所推崇的只是空洞的、无意义的口号。迈克尔·波特说得对，‘竞争战略就是要建立差异化。’这就意味着要审慎选择一系列独特的活动以体现独一无二的价值组合，战略的本质是要以行动来体现的，即选择不同于竞争对手的独特行动方式或开展与众不同的活动。否则，‘战略’就只能是经不起竞争考验的营销口号。 品牌战略就是在潜在客户心智中建立品牌以及差异化概念。 3.专注品牌是一种承诺，它建立了产品所必须实现的预期。 维护品牌和让其免受内部力量的摧毁往往比创建一个品牌更难。 有时候企业为了达到管理人员所要求的数字指标，便开始做一些有损品牌的事情。 比如说，为了获得更多的业务，组织失去了焦点，不再聚焦自己的独特之处。它们进行侵蚀核心品牌的活动，追求本不应追求的业务。例如，万宝路试图销售薄荷香烟，凯迪拉克试图销售小型凯迪拉克汽车，保时捷试图销售运动型多动能汽车，等等。有时它们还会创建子品牌，希望能将它们新的努力成果合理化，例如，假日酒店的子品牌皇冠大酒店。但顾客感觉皇冠大酒店似乎有些贵，不符合假日酒店在人们心智中物美价廉的定位。 对于高端品牌打入低端市场，就拿沃特福特水晶来说。沃特福特水晶试图通过销售侯爵水晶打入低端市场，其实，这种廉价水晶做得越成功，对昂贵的沃特福特品牌的损害也就越大。品牌是一种承诺，它建立了产品所必须实现的预期。 单一的品牌如果想以多种形式来销售，只需要做到不同的形式或式样不偏离品牌精髓，不削弱其差异化概念就行。如果沃尔沃是看上去像坦克一样安全的汽车，那么敞篷的沃尔沃在消费者心智中就是不合理的；如果耐克是给世界顶级运动员穿的，那么耐克牌高尔夫球就没有存在的意义——因为耐克高尔夫球根本没法穿。大多数人觉得好的高尔夫球应该是老虎伍兹所使用的高尔夫球，而不是耐克牌高尔夫球，因而老虎伍兹牌高尔夫球要比耐克牌高尔夫球好卖得多。 4.贪婪品牌战略就是将特定品牌连同其差异化根植于顾客的心智中。诀窍就是把精力集中于品牌的核心特征上，而不是过于贪婪，将品牌过分延伸。 怎样才能避免丧失品牌焦点呢？答案就是舍弃。有时候舍弃一些东西对你的业务会有好处。如果你对较长一段时期的产品种类目录进行研究，你就会发现过多地增加品种只会削弱增长速度，而不会对增长有任何帮助。增加的品种越多，基本的差异化概念被损伤的风险也就越大。 舍弃有三个方面： 首先是产品舍弃。例如，金霸王专营碱性电池，肯德基专营鸡肉食品，西南航空公司专门从事短途航空旅行。 其次是特性舍弃，也就是说要将精力集中在一种产品特性上。例如，沃尔沃强调其产品的安全性，戴尔强调直销，棒！约翰比萨强调好的原料。你的产品可能会拥有多种特性，但你传递的信息一定要集中在产品的核心特性上。 最后是目标市场舍弃，也就是说要将精力集中在某一品类的一个目标细分市场上，这样，你才有能力成为该细分市场备受青睐的产品。例如，得伟专营专业工具，百事主要面向年轻一代，雪佛兰的一款跑车考维特主要针对追求年轻的一代……如果你同时追寻其他的细分市场，你就可能会失去原有的顾客。 出处：《特劳特营销十要：笔记二 》","tags":[{"name":"营销","slug":"营销","permalink":"http://ijiangnanbei.com/tags/营销/"}]},{"title":"营销的本质是什么","date":"2017-06-02T22:08:58.000Z","path":"2017/06/03/《特劳特营销十要：笔记一-营销的本质是什么》/","text":"1.营销的本质是什么？Marketing is like making a good movie in which your product is the star. A good movie will sell a lot of tickets. 营销就是要确定为了销售产品和提供服务以获得利润都需要做哪些事情。 营销工作的职责就是发现新理念并将其用语言描述出来，同时使其成为完善的营销战略，然后释放出它的能量。 那怎样才能识别成功的营销计划，并从中获得启发呢？ 阅读每一期的《商业周刊》、《财富》、《福布斯》、《华尔街日报》。当这些杂志、报纸在撰述公司故事时会发表相关的分析，并列出分析方法，阅读这些成功或失败的故事会比阅读那些营销专著有用得多。 市场营销就是要把事情简单化，直接切入到如何销售产品这个核心上。 好的营销如同制作一部电影，你必须把一大堆琐碎的镜头放到一起，拼凑成一个完整的故事。也就是说，营销就像一部电影，而产品就是电影中的明星。电影中的每个人、每件事都是在讲述一个简单的故事。这个故事就是要告诉人们“为什么我的产品与众不同，为什么你应该购买我的产品而不是其他产品”。 如果你的产品能够解决一个问题，那么你首先应该将这一问题戏剧化，然后用你的产品去化解矛盾；如果你的产品是后来者，那么你应该将市场上现有的产品做一个介绍，然后戏剧化地将你的产品的新颖独到之处展示出来；如果你的产品有一个较强的竞争对手，你就应该解释为什么你的产品是一个更好的选择。千万不要‘跟风’。 2.如何处理预算？所谓预算其实就是花足够的钱把你的故事讲给目标市场听。 第一步，准备市场营销计划，按营销生命周期来展示每一种产品。分析一下这是不是一个新的市场，已有的竞争程度如何，差异化在哪里，人们对你的产品以及竞争对手的产品的认知如何。这些计划必须是客观的、建立在事实基础之上的，不应有任何主观臆断。 第二步，评估产品机会。如果工作进展顺利的话，有了这些数据，你就能够判定：哪一种产品能够提供更多的潜在利润；这种产品或服务能否赢得价格优势；这是不是新一代理念，能够帮助你成为这一市场的领头羊；这是不是一种存在激烈竞争的产品。 因为你不能预知未来，所以这一步就需要你去做一些训练有素的推测工作。你要尽力去做的就是评估每一种产品或服务，然后确定哪一种有最好的投资机会。 你应该认真评估每一次战斗的激烈程度，竞争越弱，成功的机会就越大，与地位稳固的敌人对抗可不是什么有趣的事情。 第三步，安排广告工作。由于广告往往是营销计划中费用最高的部分，所以要确保广告预算用在最有效的地方，这一点相当重要。花足够的钱把你的故事讲给目标市场听。 比如说，广告在创建新理念或新产品的知名度上特别有效，在比较你与竞争对手的产品和突出差异化方面也能起到强有力的作用。但你若想说服潜在顾客或改变顾客的心智，广告就不是很有效了。 如果你只想取悦目标客户，不在潜在顾客的心智中建立‘差异化’，这样的广告则没有多大用处。 第四步，资金不足时应该立刻停止。在这一点上，首席执行官要讲究策略。一旦你将各个项目按照获利可能性和工作有效性排出优先次序，你就要从高往低开始分配预算。如果你所能支付的只是三个大项目，那就只能做这三个项目。当你的资金到达极限时，你就必须将其余的项目舍弃，等待下一年去重新评估。这样做确实很痛苦，但你必须在做计划时避免将有限的资金覆盖到过多的项目上，这样会让所有的努力付诸东流。你要用最大的努力获得最大的回报。” 3.坚持到底的重要性实施好的概念胜过拥有好的概念，赢得一个客户永远比维护已有的客户代价高的多。 坚持到底是好的计划和好的结果之间的桥梁，营销工作同样需要持之以恒。这一过程要保证涵盖所有的细节，并且这些细节全部都能得到妥善的处理。 坚持到底还意味着，‘一旦得到顾客就要牢牢地抓住他们’。在这一点上，你可以利用各种办法保持同客户的联系，并让他们感觉到你始终关心着他们。如果你犯了错误，要马上和你的客户联系并向他们道歉，同时为他们提供额外的补偿。有人称之为‘一对一营销’，我则称之为‘保持联系’。记住，赢得一个新客户永远比维护已有客户的代价高很多。” 4.分销的重要性关于分销你首先要知道，越直接越容易控制。换句话说，如果必须通过中间商的话，就等于放弃了一部分利润和对产品的控制权。比如说迈克尔·戴尔省略了电脑零售商进行直销，非常成功，而其他公司还在拼命地挣扎。 其次，如果你选择了分销，你要知道不要与你的客户竞争。一旦你选择了分销体系，比如说通过小型专业零售商来进行销售，你就不要因为贪心而在自己的店里直接销售。那样做的话，分销商会立刻对你的产品失去兴趣。好的分销渠道要求你对渠道保持忠诚。如果你想要你的销售商忠于你，那就不要通过他们的竞争对手——大型销售商来销售你的产品。 最后也是最重要的一点，就是‘让我看到钱’。分销商卖你的产品赚到的钱越多，他们对你的关注也就越多。这就意味着你的工作就是要使你的产品对分销商的客户（即消费者）更具吸引力，也就是说，你必须要把营销工作做好。 出处：《特劳特营销十要：笔记一 》","tags":[{"name":"营销","slug":"营销","permalink":"http://ijiangnanbei.com/tags/营销/"}]},{"title":"从营销看企业家的新角色","date":"2017-06-02T15:05:32.000Z","path":"2017/06/02/从营销看企业家的新角色/","text":"什么是企业家？华尔街对于企业家有一个全新的定义：企业家就是看得懂资产负债表的营销专家。 新的竞争环境要求整个企业组织就是一个营销机构，而企业家的首要角色是营销战略家。 同时，企业经营的重心也转移到了对消费者心智的争夺。除非你能在消费者心智中建立起品牌的区隔，否则消费者将找不到选择你的理由。这就是定位之父杰克.特劳特在所强调的：品牌战略的本质在于实现品牌的差异化。因为在大竞争时代，对于品牌来说，要么差异化，要么消亡。所以杰克·特劳特说：“在营销操作展开之前，有一个最关键的步骤就是为品牌定位。”他指明了营销的目标、企业经营的方向，企业一切的营销组织和资源配置都要围绕着定位展开。要让品牌在消费者心智中占据何种定位，成了企业经营活动的战略性方向，而企业家是这个方向的设计师。","tags":[{"name":"营销","slug":"营销","permalink":"http://ijiangnanbei.com/tags/营销/"}]},{"title":"Critical thinking","date":"2017-06-02T05:01:25.000Z","path":"2017/06/02/Critical-thinking/","text":"we are bombarded with so many decisions, that’s impossible to make prefect choice every time. But there are many ways to improve our chances,and one particularly effective technique is critical thinking. This is a way of approaching the question, that allows us to carefully deconstruct the situation,reveal its hidden issues,such as bais and manipulation and make the best decision. a person who use criticla thinking, subjects all available options to scrutiny, and skepticism. There many different ways of approaching critical thinking. Here is one 5 steps process that may help you solve any number of problems. 1.Formalute your question In other words,know what you are looking for.This isn’t always as straightforward as it sounds.For example, if you are deciding whether to tyr out the newest diet craze, your reasons for doing so may be obscured by other factors, like claims that you will see results in two weeks.But, if you approach the situation with a clear view of what you’re actully trying to accomplish by dieting whether that’s weight loss,better nutrition, or having more energy, that’ll equip you to sift through this information critically,find what you’re looking for and decide whether the new fad really suits your needs. 2.Gather your informationThere’s losts of it out there, so have a clear idea of your question will help you determine what’s relevant. If you’re trying to decide on a diet to improve your nutrition, you may ask an expert for their advice, or seek other people’s testimonies. Information gathering helps you weigh different options, moving you closer to a decision that meets your goal. 3.Apply the informationsomething you do by asking critical question. Facing a decision, ask yourself : ‘What concepts are at work?’, ‘What assumptions exist?’,’Is my interpretation of the information logically sound?’. For example, in an email that promises you millions, you shound consider ‘what is my shaping my approach to this situation?’,’Do i assume the sender is telling the truth?’,’Based on the evidence, is it logical to assume I’ll win any money?’. 4.Consider the implicationsImagine it’s election time, and you’ve selected a political candidate based on their promise to make it cheaper for drivers to fill up on gas. At first glance, that seems great. But what about the long-term enviromental effects? If gasonline use is less restricted by cost, this could also cause a huge surge in air pollution, an unintended consequence that’s improtant to think about. 4.Expolre other points of viewAsk yourself why so many people are drawn to the policies of the opposing political candidate. Even if you disagree with everything that candidate says, exploring the full spectrum of viewpoints might explain why some policies that don’t seem valid to you appeal to others. That wil allow you to explore alternatives evalute your own choices and untimately help you make more informed decisions. This five-step processes just one tool, and it certainly won’t eradicate difficult decisions from our lives. But it can help us improve the number of positive choices we make. Critical thinking can give us the tools to sift through a sea of imformation and find what we’re looking for.It has the power to make the world a more resonable place. tips:source","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"}]},{"title":"尾部设计","date":"2017-05-25T15:15:01.000Z","path":"2017/05/25/尾部设计/","text":"页尾设计 页尾，也称为 Tailer，指的是页面底部部分，通常放置联系方式和版权信息等补充信息。由于其位置不够显著、重要性较低，因此也往往成为设计师容易忽略的地方。 需要规避的细节问题页尾的信息过多过杂由于页尾不太重要，因此应该尽量简化它，节约页面宝贵的空间。 不同页面的页尾不统一 有时候，由于网站的迅速扩张，页面数量迅速增加，如缺乏统一的规范约束，往往容易导致页尾等元素在同一类型页面中表现得不够统一。 这虽然只是一个很小的细节，却容易让用户对网站的专业度产生怀疑，这是页面设计中需要注意的问题之一。 版权说明格式 一般网站都会在页尾进行版权说明，目前国际上标准的格式是：Copyright[日期（dates）]by[作者/所有者（author/owner）]，其中 Copyright 通常可以用 © 代替，但是不可以用（c）。All Rights Reserved 在某些国家曾经是必需的，但是现在在大多数国家，都不是法律上必须有的字样。 设计新趋势为了更好的利用网站的空间，目前有些网站在页尾除了放置联系方式和版权信息以外，也放置网站的辅助导航，使页尾发挥更大的引导作用。","tags":[{"name":"设计","slug":"设计","permalink":"http://ijiangnanbei.com/tags/设计/"}]},{"title":"头部设计","date":"2017-05-25T15:15:01.000Z","path":"2017/05/25/头部设计/","text":"网站上每个元素都是为了满足了用户、网站或者赞助商不同角度的需求而存在的。按照各部分作用的不同，可将网站划分成以下功能区域，包括头部、页尾、导航区、搜索区、登录注册区、信息展示区、广告区等。 头部 网页头部，也称为 Header，简称头部，指的是网站页面的顶部区域，通常包含网站的 Logo、Slogan、Banner、导航条等元素，有时还提供常用功能的快速入口，如登录、帮助等。头部主要用于网站展示品牌形象，告诉用户目前在浏览哪个网站以及该网站主要提供什么内容。 头部类型实用型头部实用型的网站头部设计简洁、不花哨，能够在合理有限的空间内起到必要的作用，一般其只包含 Logo、导航条和快速入口等重要元素。 大型网站由于页面空间有限，而且品牌的知名度使其不需要使用过多的元素去渲染网站的特色和气氛，因此往往采用这种类型的头部设计。 设计型头部很多网站，尤其是个性化的网站，往往会利用头部的设计体现出网站的特色，常见于博客、小型特色网站以及部分企业网站首页。 设计型头部的优点在于有很大的发挥空间，如果设计效果好，就会造成很强的视觉冲击力，给用户留下很深的印象；其缺点在于往往占用过多空间，削减了网站内容的重要性，造成喧宾夺主的效果，也容易产生头重脚轻的感觉。 头部元素的设计不管是哪种类型的头部，一般包括 Logo、Slogan、导航条等元素。 LogoLogo 的基本作用之一是返回页面首页，使用户在网站迷路时，可以找到回去的路，增加用户在网站上的方向感和安全感。更重要的是 Logo 代表着网站的品牌和形象，尤其对知名的网站来讲，Logo 能够唤起用户对网站的品牌认知度，从而提升用户的信任感。 Logo 本身的设计非常重要，必需清晰易辨识，能体现出网站的定位和特色，具体的设计更多取决于设计者，在这不多加叙述。 对于不同类型的页面或者网站，Logo 的呈现的方式不一样。如独立的 logo，适用于网站首页。logo+文字，适用于网站子类目。logo+logo，适用于合并后的网站。 除此之外，很多网站会在节日期间设计应景的节日 logo 体现气氛，提升用户对网站的体验。 SloganSlogan 虽然只是一句简单的标语，但能够很好地体现出网站的定位和特色，显示企业文化、塑造网站个性，配合 Logo 一起使用能够达到更好的效果。Slogan 一般要求朗朗上口，而且点出网站的最大亮点。好的标语往往能让用户更好地记住网站的特色及其提供的主要服务。如： ·阿里巴巴。“全球领先的网上贸易市场和商人社区”。 ·淘宝。“淘我喜欢！” 除了 Logo 和 Slogan 以上两个主要元素之外，总体上来讲，同一级别或者同一类型页面的头部设计应该尽量保持一致。","tags":[{"name":"设计","slug":"设计","permalink":"http://ijiangnanbei.com/tags/设计/"}]},{"title":"界面整体布局及配色方案","date":"2017-05-21T13:02:26.000Z","path":"2017/05/21/《见微知著：笔记二-界面整体布局及配色方案》/","text":"《见微知著：笔记二 》 有一个知名的效应称为首因效应，指的是第一印象的形成导致的在总体印象形成上最初获得的信息比后来获得的信息影响更大。因此我们应该利用首因效应，着重设计好给用户留下第一印象的整体布局、内容和视觉设计等，这些也是网站最。 合理的布局应该符合用户的浏览习惯，合理的引导用户的视线流；清晰有效的布局能够让用户对网站的内容一目了然，快速了解内容的组织和逻辑，大大提升网站的可阅读性和整体视觉效果。 配色方案包括网站的主色调、辅助色、背景色等，适当的配色方案能够引起用户的共鸣，从情感上提升用户体验。 1.界面布局1.1一栏式布局一栏式布局页面结构简单、视觉流清晰，便于用户快速定位，但由于页面排版方式的限制，只适用于信息量小、目的比较集中或者相对比较独立的网站，因此常用于小型网站首页以及注册表单页面等。 采用一栏式布局的首页优点在于信息展示集中、重点突出。通常都会通过大幅的精美图片或者动态Flash来实现强烈的视觉冲击力，给用户留下深刻的印象，提升品牌效应，留住用户进一步浏览。但是展示的信息量有限，因此需要在首页中添加导航或者是重要的入口链接等，起到入口和信息分流的作用。一栏式布局还适用于目的性单一、较为独立的二级页面或者更深层次页面，如注册表单页面，用户只聚焦在表单填写上，因此除表单外只需提供返回首页及少数重要入口即可。 1.2两栏式布局相对于一栏式布局他可以容纳更多的内容，相对三栏式布局来讲，信息不至于过度的拥挤和零乱，但它不具备一栏式布局的视觉冲击力和三栏式布局超容量的特点。 两栏式布局根据其所占的面积比例不同，将其分为左窄右宽、左宽右窄、左右均匀这三种类型。虽然表面上看只是比例和位置不同，但它实际上影响到的是用户浏览的视线流以及页面的整体重点。 1.2.1左窄右宽式这种形式的布局通常采用左边是导航（以树状导航或者一系列文字链接的形式出现），右边是内容的设置。此时左边不适宜放次要信息或者广告，否则会过度干扰用户浏览主要内容。用户的浏览习惯通常是从左到右、从上到下，因此这类布局的页面更符合理性的操作流程，能够引导用户通过导航查找内容，使操作更具可控性，适用于内容丰富，导航分类清晰的网站。 1.2.2左宽右窄型这种结构明显突出了内容的主导地位，引导用户将视觉焦点放在内容上。在用户阅读内容的同时或者之后，才引导其去关注更多相关信息。 这种方式的右侧也可以放置次要信息或者广告，体现出信息的主次。 1.2.3左右均匀型这种类型采用的较少，适用于两边信息的重要程度相对比较均等的情况，不体现出内容的主次。 对比着三种方式，可以看到每种方式的内容重点和视线流的方向都是不一样的。左窄右宽型的导航位置相对突出，引导用户从左至右地浏览网站，即从导航寻找信息内容；而左宽右窄型的左侧往往放置信息内容，可以让用户聚焦在当前内容上，浏览完之后才会通过导航引导用户浏览更多相关的内容。 1.3三栏式布局三栏式布局紧凑可以更好的利用网页的空间，但是这难免造成了信息量的拥挤，增加了用户的查找时间，降低了用户对网站内容的可控性。 1.3.1中间宽、两边窄这类布局引导用户将视线流聚焦于中间部分，重点较为突出，但却容易导致页面的整体利用率降低。 1.3.2两栏宽、一栏窄较宽的两栏常被用来展示重点信息，较窄的一栏常用来展示辅助信息。虽然能展示更多的内容，但是重点没有第一种方式突出。 1.4设计要点1.4.1选择合适的布局方式在设计布局时，最重要的是根据信息量和页面类型等选择适合的分栏方式，并根据信息间的主次选择合适的比例，对重要信息赋予更多空间，体现出内容间的主次关系，引导用户的视线流。 针对某个新闻等具体页面，新闻内容才是用户最为关注的内容，导航等知识辅助信息，因此是和采用一栏式或者新闻内容为主的两栏式布局。 1.4.2通过明显的视觉分区保持整个页面的通透性有时候网站板块间的设计缺少统一的规范，就很容易导致各版块间的比例不一致，从而在视觉上给用户一种零乱的感觉，也容易打断用户较为连贯流畅的视觉流。 保持整个页面的通透性，只需要统一各版块间的比例，同时通过线条、颜色等视觉元素增加各栏间的区分度，就可以轻松做到。 1.4.3按照用户的浏览习惯及使用顺序分布摆放内容在页面布局设计时，应该尽量将重点内容放在左上角，右侧放置次要内容。 1.4.4统一规范，提升专业度对于网站内的不同页面类型，应该选择适合的页面布局。对于同一类型或者同一层级的页面，应尽量使用相同的布局方式，避免分栏方式的不同、甚至是各栏比例上的细微变化，以保持网站的统一性和规范性，使网站显得更加专业。 2.网站整体配色方案颜色对眼睛的刺激往往比文字来的直观，更能抓住用户的注意力。不同的颜色能够让用户产生不同的情绪。因此好的配色方案不仅能够给用户带来美的视觉享受，加深用户对网站的印象，增加对网站品牌的认可和辨识度。 网站主色调是最重要的一个元素。到底该选择哪种颜色，鲜艳还是朴素，活泼还是庄重，大众化还是个性化都是配色方案所涉及的。 网站的类型、品牌形象、整体定位、目标群体等多种因素都会影响到颜色的选择，而颜色本身也具有自己的特性以及含义，因此需要匹配颜色特性和网站特色来选择适合的主色调。 2.1不同的颜色会产生不同的主观感受如暖色调会给人带来温暖的感觉，同时具有扩张感，使暖色的元素从背景中跳出来；而冷色调则给人冷清、冷静的感觉，具有收缩的作用，因此容易隐入背景之中。纯度高的颜色饱和度高，较为艳丽，纯度低的则较为柔和。明度高的颜色会带来轻快的感觉，而明度低的颜色则显得比较庄重。取有对比的色相和明度则令人感到活泼，取类似、同一色系则令人感到稳健。色相数多则会显得华丽，色相少则会显得淡雅清新。 每个颜色都有自己的含义，带给用户不同的主观感受。下面是几种常见的颜色： 红色被认为是最热情的颜色，代表了兴奋、激情、奔放和欢乐，容易让人联想到旗帜、激情、危险、火灾、血液、竞争、侵略、警报等，对人眼刺激较大，容易造成视觉疲劳，使用时需要慎重考虑。因此不要采用大面积的红色，它常用于Logo、导航等位置。 橙色是非常温暖的颜色，通常代表着激情、欢乐、健康等。阿里系基本都采用橙色作为主色调，独特、识别度高，成为公司的一个象征。但和红色类似也容易造成视觉疲劳。 黄色通常给人轻快、明亮、乐观的印象，有扩张的视觉效果，因此采用黄色作为主色调的网站也往往呈现出活力和快乐。通常黄色还容易让人联想到黄金、缎带，因此也往往代表着高贵和富有。不同的黄色往往会带来不同的效果，因此在设计时需要注意细节的差别。 绿色具有黄色和蓝色两种成分的色，作为中性的颜色，绿色往往代表着平和、恬静、谦虚、智慧和生命力。也常用财经网站或者那些代表富饶、康复和生态学的网站。 蓝色的色感较冷，通常代表着冷静、沉思、智慧、自信和神秘，就如同天空和海洋一样，深不可测。同时，蓝色也是现代科技的象征色，如IBM等科技公司都采用蓝色作为公司网站主色调。 紫色的明度较低，给人以高贵、优雅、浪漫和神秘的感觉，同时也表示公正和真相。但眼睛对紫色光的细微变化的分辨力很弱，容易引起疲劳。 黑色往往代表着严肃、恐怖、冷静。它本身是无光无色的，当作为背景色时，能够很好地衬托出其他颜色，尤其与白色对比时，对比非常分明，白底黑字或者黑底白字的可视度很高。 白色是全部可见光均匀混合而成的，称为全色光，通常代表着明亮、简单、干净、纯真与和平。白色很少单独使用，通常都与其他颜色混合，纯粹的白色背景对于内容的干扰最小。 灰色往往代表中性、稳重和智慧。它不容易产生视觉疲劳，但是也容易让人感到沉闷。当然也有漂亮的灰色会给人高雅、精致、含蓄的印象。 当然颜色的略微变化，也可以带来不一样的感觉。在红色中加入少量的黑，会使其风格变的沉稳，趋于厚重、朴实；加入少量的白，会使其风格变的温柔，趋于含蓄、羞涩、娇嫩。如果在橙色中黄的成分较多，其风格趋于甜美、亮丽、芳香；在橙色中混入小量的白，可使橙色的感觉趋于焦躁、无力。在绿色中黄的成分较多时，其风格就趋于活泼、友善，具有幼稚性；在绿色中加入少量的黑，其风格就趋于庄重、老练、成熟；在绿色中加入少量的白，其风格就趋于洁净、清爽、鲜嫩。 3.网站特色网站目标用户群体，网站的类型，以及网站的品牌形象等因素在很大程度上决定了网站的色调选择。 3.1目标用户群体在设计时需要考虑当地的文化因素。比如红色在墨西哥表示诅咒，在其他一些西方国家红色也往往象征着残暴，流血，应尽量避免使用。 此外，不同的性别、年龄、教育背景等都会影响人们对于色彩的理解和偏好。 比如说，针对年轻人的网站应该轻快活泼，使用鲜艳或者是较饱和的颜色。针对老年人的网站应该宁静，不应过于花哨，灰色系是一个不错的选择；针对商务人士应该庄重有质感。 3.2网站类型不同的网站类型以及网站的定位都会影响到颜色的选取，当然网站类型也与目标用户群体息息相关。 门户类网站通常给人大众、专业、稳重的印象，因此主色调也往往在常用颜色中选取，适合大部分人的品位。如腾讯的浅蓝色、新浪网的黄色、Yahoo！的紫色和MSN的蓝色，在保持网站品牌形象和个性的同时，符合了大部分用户的审美。同时，由于门户网站主要以资讯内容为主，因此应尽量减少颜色等元素对于内容浏览的干扰。 电子商务网站的颜色则非常绚丽，给人激情、热闹、舒适的印象。比如淘宝的红色系，百度有啊的红色系。较多使用暖色调，刺激用户的浏览和购买。 eBay的主色对非常巧妙的将logo中的四种颜色搭配在一起，互相呼应，整个页面看上去非常清爽和谐。 淘宝主页从Logo到导航、按钮等一致地沿用了橙色系的元素。但到具体的垂直类别时，对不同分类都进行了个性化的设计。对于娱乐、女人等目标用户主要为女性用户的类别，采用较为饱和的红色，带来温暖、热情的感觉；对于亲子类别，目标用户群体主要为孕妇，采用了较为柔和的粉红色；对于男人、运动和汽车等目标用户主要为男性的类别，都采用了冷色调，给人更加冷峻、沉稳的感觉。 社交网站一般会给人轻松，互动的氛围。除此之外需要结合目标群体的特征，选择合适的颜色。如QQ校友的用户群体相对年轻，因此使用绿色较为轻快，有活力的颜色。而Linkedin的用户群体主要为商业客户，因此颜色相对稳重，职业化。 垂直类网站由于范围较窄，因此与其领域的特色紧密相关，体现出相关性和专业性。如金融类网站需要体现出正式、庄重，因此往往采用稳重的颜色。中国工商银行网站就采用了银色和红色体现出金融以及稳重的感觉。 汽车类网站则通过颜色、图片等共同体现出质感、稳重、速度等，给人造成强烈的视觉冲击。 政府网站相对比较严肃庄重，因此适合使用颜色较深的色调。 企业网站可以根据其产品特点创造独有的风格。 3.3品牌形象每个公司由于其产品特色以及企业文化等的不同，都会形成自身独特的品牌形象。尤其对于知名网站/企业来讲，多年的品牌营销使品牌形象/品牌色深入人心，因此网站沿用品牌色将有助于提升网站/企业的整体形象。 最常见的一种方式就是增加网站主色调和logo之间的关联，因为logo的设计本身就体现出了其定位及品牌形象。如前面提到的eBay，网站主色调采用了Logo的4种颜色的组合，增加了用户对于网站的认知度和识别度。 对于科技类网站，通常选择蓝色，黑色等象征现代科技的颜色，如IBM的蓝色巨人已经深入人心，因此网站的主色调也应该围着蓝色，使其更加符合品牌形象。 （网站Logo、导航等多种元素间使用统一的颜色，可提升品牌形象和品牌认知度，使网站更加和谐。） 网站还需要搭配辅助色、点睛色、背景色，形成完整的配色方案。其中： 辅色调。仅次于主色调的视觉面积的辅助色，用于烘托主色调，营造网站整体氛围。 突出色。在小范围内用强烈的颜色对比来突出重点元素，使页面更加鲜明生动，主要用于占用范围较小的按钮、标签等。 背景色。用作背景的颜色，协调、支配整体的作用。 每一个颜色对于网站都至关重要，合理搭配才能使网站颜色更加赏心悦目，重点突出，因此设计时都需要仔细斟酌。 同时网站的图片、文字、按钮等元素的颜色都需要互相搭配，达到网站的整体和谐，提升网站的整体氛围。","tags":[{"name":"设计","slug":"设计","permalink":"http://ijiangnanbei.com/tags/设计/"}]},{"title":"网站解构入门","date":"2017-05-21T04:53:27.000Z","path":"2017/05/21/《见微知著：笔记一-网站解构入门》/","text":"《见微知著：笔记一 》 1.什么是用户体验？网站的用户体验指的是由于网站的作用、品牌形象、操作的便利性、网速的流畅性以及细节设计等综合因素，最终影响到用户访问网站时的主观体验，包括用户是否能成功完成任务、是否喜欢网站、是否还想再来。 就像进入一家餐厅，除了菜式本身的可口之外，餐厅的装修、座位的分布、服务员的微笑，甚至是一句简单的“请”或“谢谢”，所有的细节都会影响到用户的整体情绪。 一个不起眼的细节，可能让用户倍感欣喜，却也可能导致错误带来沮丧。 要有更好地用户体验，不仅需要更快的速度、更好的内容，更需要从细节处着手，设身处地的从用户的角度来思考问题，体现出网站对用户的尊重和贴心。 2.为什么要网站解构？交互设计倡导的就是“it depends”的精神，没有最完美的设计，只有最适合的设计。如果没有设计规范或者相关的设计、研究结果，设计师往往需要不断地尝试、借鉴和摸索，花费大量时间和人力，对网站进行设计或改进。对于全新的网站设计，你可以先从整体上确定网站的布局和配色方案，然后将网站所需要的元素进行解构，仔细斟酌每一个细节的设计，然后再从整体的角度来检验每个细节是否符合全局的需要，而后进行局部的调整。 对于已有网站进行改进设计，你可以有针对性地对某些元素进行分析,找到最适合改进当前网站的交互方式。为了更有针对性的改进个元素或者模块的设计，最好通过可用性测试或专家评估等方法先从全局的角度发现问题所在。 3.网站解构的思路和维度一个网站往往包含了非常多的元素，我们先从整体着手，然后再细化解构到各细节元素。 3.1整体界面布局及配色方案从整体来看，网站最重要的就是信息架构、内容和视觉设计。 信息架构作为网站最核心的骨架，代表了产品内容的组织形式，表现为产品功能信息分类、分层的关系，在设计上主要体现为界面布局和导航，视觉体现为网站的配色方案。这些都将在下一章中详述。 （信息架构最好通过卡片分类法等进行统计分析，使其符合用户的心理模型） 3.2主要功能区网站的功能区指的是除整体布局之外，组成页面的需要区域，通常按照其功能进行划分。 主要包括：头部，页尾、导航区、搜索区、登录注册区、主要信息展示区、广告区等主要功能区。 3.3页面元素页面元素包括表单、标签、链接、翻页、按钮、反馈、验证码等，常用于各功能区域之中。 这些元素的细节设计是交互设计中非常重要的一部分。 如表单可用于注册表单、购买表单等。通过优化表单，可以提升用户注册率或者商品成交率等。 3.4其他细节其他细节还有：字体，网站文字的语气等细节也都对用户体验起着非常重要的作用。 其中字体包括字型、字号、字体与背景的颜色对比等。","tags":[{"name":"设计","slug":"设计","permalink":"http://ijiangnanbei.com/tags/设计/"}]},{"title":"《第一部：洪武大帝》","date":"2017-05-20T14:54:06.000Z","path":"2017/05/20/《明朝那些事第一部；洪武大帝》/","text":"《明朝那些事 第一部文摘》 1.这是一个伟大的转变,很多人可能穷奇一辈子也无法完成.转变的关键在于心.是的,即使你拥有人人羡慕的容貌,博览群书的才学,挥霍不尽的财富,也不能证明你打强大.因为心 的到强大,才是正真的强大。 2.自古以来,建立一个王朝很难,毁灭一个却相对容易的多,所谓”墙倒众人推,破鼓万人捶”,不是没有来由的。 3.知道可能面对的困难和痛苦,在死亡的恐惧中不断挣扎,而仍然能战胜自己,才是真正的勇气. 4.在军队里,朱重八很快就表现出了他的才能.比起其他的农民士兵,他是一个很突出的人,不但作战勇敢,而且很有计谋,处事冷静,思虑深远(注意这个特点),还很讲义气,有危险的时候第一个上,这一切都让他有了崇高的威信.他从不贪图财务,每次得到战利品,就献给郭子兴,如果得到赏赐,就分给士兵. 5. 待得秋来九月八,我花开时百花杀。 冲天香阵透长安,满城尽带黄金甲。 &lt;咏菊&gt;唐时的黄巢落榜之后题于长安城门前。 6. 百花发时我不发,我若发时都吓杀. 要与西风战一场,遍身穿就黄金甲. ---朱元璋 7.一个人要显示自己的力量,从来都不是考暴力,挑战这一准则的人必然会被历史从强者的行列中淘汰,历来如此.8.徐寿辉,出生年月不详(死期到时很精确) 9.徐寿辉蒙了,他不是没有想过这一天的到来,但当他到来时,还是那么残酷. 10.在实际决策中,不受他人,特别是多数人意见的影响是很困难的,当许多人众口一词时,很多人都会从大流,甚至改变自己原来的看法,而朱元璋用他的的智慧告诉了人们,真理往往是站在少数人一边的. 朱元璋对他的谋士们说,你们的看法是有道理的,但是你们没有看到问题的关键:张士诚的特点是器小,陈友谅的特点是志骄;器小无远见,志骄好生事.如果我进攻陈友谅,张士诚必然不会救他,而进攻张士诚,陈友谅就一定会动员全国兵力来救,我就要两线作战,到时候就难说了. 精彩!真精彩! 如此之见识,此人不去天下,何人取. 11.有谋事说,应该先攻下太平,然后以太平为屏障与陈友谅决战. 又有谋士说,应该趁陈友谅立足不稳,马上出击与其决战,击敌半渡,可收全功.我们客观的来看,这两种注意似乎都不错,提出谋略的人也是很有见识的,但真的行得通吗? 朱元璋再度表现出了他的军事天才,这种天分将在今后的军事生涯中不断帮助他. 它分析道,先攻太平是不行的,因为太平城坚固,不保证能一定攻下来,即使攻下来以后,也无法在短时间内守住,陈友谅一定会一鼓作气攻克太平继而攻击应天,而那时主力部队已经即为疲劳,根本受不住应天.主动出击决战也是不可取的,因为舍弃坚城不守,贸然出击,一旦未能与敌军进行决战或是战败,整个战局就会陷入被动. 最后,他说出了自己的见解,用手指了指应天城外的龙湾:”就在这里”. 12.在通往胜利之门的路上,你会见到很多钥匙,这些钥匙有的古香古色,有的金光闪闪,但只有一把能打开那扇门. 在进行决策时,会有很多人在你耳边提出他们自己的意见,将他们手中的钥匙交给你,让你去选择,但这个游戏最残酷的地方在于:你只有一次尝试的机会.如果失败了,你将失去一切. 在战役实施中,只有一个时机是最合适的,能抓住这个时机的,既是天才—拿破仑 13. 杀尽江南百万兵,腰间宝剑血尤腥. 老僧不识英雄汉,只管哓哓问姓名. 14.陈友谅之所以失败,只是因为一个很简单的道理:最强大的武器,不是军队的人数,不是强大的舰队,而是人心. 15.陈友谅第一个进攻的目标正是洪都. 后人一直为陈友谅的这个决定不解,未什么不直接攻击应天呢?那样朱元璋将腹背受敌,不堪一击,陈友谅为什么现成的便宜不捡呢? 这四会是一个很难解释的问题,但我相信,在陈友谅那里,这个问题很好解释.陈友谅的性格弱点注定了他一定会进攻洪都. 他是一个心狠手黑的人,一直在欺骗和背叛中生活,对这些东西并不陌生,洪都的投敌对他而言并不是什么意想不到的事情. 但从心理学上说,像他这样的人最忌讳的就是被人背叛,对一个人而言,他最厌恶的往往就是自己所擅长的. 属于我的东西,我一定要拿回来. 攻下洪都,就可以教训那些背叛我的人,让他们懂得对我陈友谅有绝对忠诚. 只许我付天下人,不许天下人负我,这是人类的通病. 朱文正的各种轶事自然也传到了陈友谅的耳朵里,这对他而言又是一个极大的鼓励. 攻下洪都,易如反掌! 但他似乎少考考虑了一点:以朱元璋之精明,不可能不知道朱文正的言行,怎么会把如此重要的位置交给一个这样的人? 16.按照均是天赋和功劳,朱文正大致可以排在将领中的第五位,这并不是因为他不够优秀,而是因为他前面的那四个人都是无法超越的. 17.当面对强大的敌人时,人们的第一反应往往是出生的牛犊不怕虎,先上去拼一拼,不行再说.这个行为的错误之处在于,牛犊并非不怕虎,而是因为它不知道虎的可怕. 18.越接近对方的水平,就越了解对方,就会越来越畏惧.当他的畏惧达到极点的时候,也就是它能与对手匹敌的时候. 19.以颤抖之身追赶,以敬畏之心挑战.战胜陈友谅,即为天下之主. 马渡江头苜蓿香,片云片雨渡潇湘. 东风吹醒英雄梦,不是咸阳是洛阳. 20.赌局一旦开始,无论你赢或者是输,都不能走,赌局会继续进行,知道其中一个人输掉一切,才会结束. 21.其人格之无耻,行为之卑略,脸皮之厚度,后人难以匹敌. 22.醉卧沙场君莫笑,古来征战几人还. 23.兵法之所以奇妙，关键在于一个变字。所谓善出奇者，无穷如天地，不竭如江海！战场是一个瞬息万变的世界，决断只在一线之间，进攻还是防守，前进还是退却，都要你拿主意。在你身边也许有一大群参谋，但他们往往并不站在真理一边，决断的还是你。如果参谋比你高明，为什么要你当主帅？ 24.在下曾读过一些兵书，随便聊： 在成为名将的道路上,我们要经历六个坎坷,让我们以六个年级来标明它们,只有战胜眼前的坎坷,才能升入下一个年级。当然,有些天才同学不需要经过这六个年级,生下来就会打仗,这样的人也是有的,不过极少,我们可以忽略。 好了,名将学校开学了。第一个年级要学习的是军事理论。所有想成为名将的人,必须要学习一些经典的理论知识,包括《孙子兵法》《吴子兵法》等等,只有在积累了大量的理论知识后,你才能跨入下一个年级。但这个年级有一个很特殊的规定,因为有些同学家里穷,买不起书本,所以他们只能在实战中去学习这些理论。他们之中的优秀代表就是李云龙同学。 穷人家的孩子早当家,实在没有说错的,这些在实战中学习理论的同学将可以跳过第二个程序,直接进入第三个程序。 我们还是和大多数同学一起,来看看第二个年级要学习些什么。第二个年级学习的内容是实战。这是极为重要的,那些理论学习的优秀者如果不能过这一关,他们就将被授予一个光荣的称号——纸上谈兵。这个称号的第一个获得者是赵括同学,授予者是二年级的年级主任赵奢。 我们来解释一下为什么实战如此重要。这是因为虽然军事理论都是高年级学长们的经验总结,但由于他们写这些东西的时候,情况和现状是不完全一样的,在实战中,如果照搬是要吃大亏的。赵括同学就是没有学好,才不能毕业的。 作为一个学员,想成为名将,一般都是从小兵干起,当然高干子弟除外,比如赵括同学,由于年级主任赵奢是他父亲,所以他一开始就是大将,这是不妥当的。 因为只有战场才能让一个人成为真正的名将,他必须亲手持刀去追击敌人,见识战场的惨烈,明白人被刀砍是要死的,了解你不杀我、我就杀你这条战场上永不过时的真理,知道所谓打仗就是以性命相搏,他们才会明白什么是战场、什么是实战。 大多数学员会在这一关被淘汰,他们会改行,一生当一个军事票友,这对他们来说并不见得是一件坏事。 而留存下来的那些学员,在残酷的实战中逐渐了解了战争的规律,开始真正走上名将之路。 好了,我们带领剩下的学员来到三年级,三年级要学习的是冷酷。 成为一个名将,就必须和仁慈、温和之类的名词说再见。他必须心如铁石、冷酷无情,当然历史上也有很多以仁出名的儒将,但请大家注意,他们的仁是对士兵和老百姓而言的,对敌人他们比谁都冷酷。所谓仁不带兵、义不行贾,冷酷不是残忍,不是杀戮无辜的老百姓,而是坚忍。比如你的一个很好的朋友触犯了军纪,但你为了执行军纪,一定要杀了他,只有这样,你才能控制军队,即使他是你最要好的朋友,甚至是你的亲人,你也要这样做。 这才是真正的冷酷。 学员们将在战场上学会冷酷,他们可能都是善良的年轻人,平时从不与人争吵。但当他们走上战场,亲眼看到自己的同乡和战友被敌人杀死,或者身负重伤在地上痛苦地呻吟,他们会被愤怒和痛苦所鼓动,毫不留情地杀死一切与自己敌对的人,给地上的伤兵补上一刀,然后一个人在尸体旁边喃喃自语。就在这地狱一般的环境中,他们变了。 从杀鸡都怕见血到敌人的脑浆和鲜血溅到身上浑然不知,从温文尔雅到冷酷无情,他们在残酷的环境中毕业了,不合格者将被淘汰,而那些心如坚石的人将进入四年级的学习,他们离成为名将越来越近。 四年级要学习的是理智。这也是极为重要的一个环节,我们作为普通人,生活中会被许多事情左右自己的情绪,比如买彩票中个二等奖几百块,你也会高兴半天,要是炒股票赚了大钱,就更不用说了。那么如果你玩的游戏是以人命为赌注呢？你会有何反应？ 当你在极度紧张的环境中与敌人僵持了很长时间,突然敌人退却了,你能遏制住心中的激动,先判断形势再去追击吗？当你抵挡不住敌人的进攻、全军即将崩溃时,你能及时冷静下来,发现敌人的弱点吗？ 是的,这太难了。我们都是凡人,都有感情,容易激动,而我们的学员们就必须保持冷静和理智,在任何时候都不被感情左右,就如同赛车一样,赛车固然激情四射,车手却必须保持绝对的冷静。 这就是四年级学员要做到的,能过这一关的人,已经很少了,剩下的精英们,我们继续前进！ 五年级是最重要的一个年级,在这个年级里,学员们要学习的是判断。 这是名将的重要特征,不需要理由,不需要依据,你能依靠的就是你自己的判断。你要明白的是,你所掌握的是无数士兵的生命,而所有的人都等着你拿主意。 小兵只管打仗,遇到问题,他会问伍长,伍长会问百户,百户会问千户,千户问指挥,你就是指挥,你还能去问谁？！ 在士兵的眼中,你就是上帝,就是主宰世界的神！他们能否活下来就看你的了！ 兵法之所以奇妙,关键在于一个变字。所谓善出奇者,无穷如天地,不竭如江海！战场是一个瞬息万变的世界,决断只在一线之间,进攻还是防守,前进还是退却,都要你拿主意。在你身边也许有一大群参谋,但他们往往并不站在真理一边,决断的还是你。如果参谋比你高明,为什么要你当主帅？！ 如果你能从那变化莫测的世界中,发现其中的奥妙,并就此做出正确的决断,那么恭喜你,你已经具备了名将最主要的素质。但是还有一关是你必须通过的,只有过了这一关,你才是真正的名将。 现在我们来到最后一个年级,这个年级我们要学习的是坚强。 从某种意义上说,这是非常重要的一个学习内容。所谓胜败兵家常事,不过安慰自己而已,打了败仗,死几万人,你能承受这样的心理压力吗？你怎么去面对那些士兵的家人？怎么有脸去见将指挥权交给你的上级？那是几万条人命,不是几万只鸡！ 然而你的选择只能是坚强,即使你屡战屡败,但必须屡败屡战！当你数次败在同一个人手下时,你就会畏惧这个人,所谓的恐某症就是这么来的,即使你有着杰出的军事才能,不能战胜自己的软弱,依然无法成为名将。 而那些最优秀的人能够从失败中爬起来,去挑战那个多次战胜自己的人,这就叫做坚强。 当你具备了以上所有条件后,你就成为了真正的名将,但还有一点,是你必须具备的,那就是运气。 说起来似乎有点滑稽,这也是很重要的一个因素,没准就在你万事俱备、准备大展身手时,一支冷箭射来,就此死掉,那才是比窦娥还冤,你的一切抱负和能力都无法展现了。战史上只会这样记载,某年某月某日,某某人在战场上被不知名小兵射死,其人具体情况不详。 所以名将之路是一条艰苦的道路,非大智大勇、大吉大利之人不能为。 故兵无常势,水无常形,能因敌变化而取胜者,谓之神。 在这变化无穷的战场上,要想成为真正的军神,你必须在一次次的残杀中幸存下来,看着周围的人死去,忍受无尽的痛苦,在战争中学习战争,努力获取那不为人知的奥秘和规律,经历无数次失败,有勇气从无数士兵的尸体上站立起来,去打败对手。 这才是真正的名将之路,一条痛苦、孤独、血腥的道路,在这条路上,能信任和依靠的人只有你自己。但只要你走到终点,光荣和胜利就会在那里等待着你。 无论是徐达、常遇春、王保保还是后来的戚继光、袁崇焕都是这样的名将,他们就是这样成长起来的。他们完全有理由为自己的成长经历而骄傲和自豪。 所以当不成名将的各位学员,你们完全不必为此而悲伤失望,因为这工作不是一般人能干的,甚至可以说,不是人能干的。诸位普通学员,还是回去做老百姓吧,那才是快乐的生活。 25.其实只要仔细想想,就会发现这个问题并不是那么难以解释。朱元璋是一个乡土观念很重的人,李善长是他的老乡,而且多年来只在幕后工作,从不抢风头,只知埋头干活,这样的一个人朱元璋是很放心的。相对的,刘基是一个外乡人；更重要的是,刘基对事情的判断比他还要准确！ 从龙湾之战到救援安丰,朱元璋想到的,刘基也想到了；朱元璋没有想到的,刘基还是想到了。 换了你是皇帝,会容许这样的一个人在身边吗？ 26.谈话中的考验 这一天,朱元璋单独找刘基谈话,初始比较和谐,双方以拉家常开始了这次谈话,就在气氛渐趋融洽时,朱元璋突然变换了脸色,以严肃的口气问刘基,如果换掉李善长,谁可以做丞相。 刘基十分警觉,马上说道,这要陛下决定。 朱元璋的脸色这才好看了点,他接着问：“你觉得杨宪如何？” 这又是一个陷阱,朱元璋明知杨宪是刘基的人,所以先提出此人来试探刘基。 刘基现在才明白,这是一次异常凶险的谈话,如果稍有不慎,就会人头落地！他马上回答：“杨宪有丞相的才能,但没有丞相的气量,不可以。” 但考验还远远没有结束,朱元璋接着问：“汪广洋如何？” 这是第二个陷阱,汪广洋并不是淮西集团的成员,朱元璋怀疑他和刘基勾结,所以第二个提出他 刘基见招拆招,回答道：“此人很浅薄,不可以。” 朱元璋佩服地看了刘基一眼,这是个精明的人啊。 他说出了第三个人选：“胡惟庸如何？” 刘基松了口气,说出了他一生中最准确的判断：“胡惟庸现在是一头小牛,但将来他一定会摆脱牛犁的束缚！” 说完这句话,刘基又松了口气,他知道考验已经过去了,但他错了,下一个问题才是致命的。 朱元璋终于亮出了杀招,他用意味深长的口气说道：“我的相位看来只有先生能担当了。” 大凡在极度紧张后,人们的思想会放松下来,刘基也不例外,他终于犯了一次错误,这次错误却是致命的。 他没有细想,回答朱元璋： “我并非不知道自己可以,但我这个人嫉恶如仇,皇上还是慢慢挑选吧。” 这句话说得非常不合适,自居丞相之才不说,还说出所谓嫉恶如仇的话,如刘基所说,谁是恶呢？ 刘基的昏劲还没有过去,又加上了一句话： “现在的这些人,在我看来并没有合适的。”（目前诸人,臣诚未见其可也。） 朱元璋就此与刘基决裂。 27.但很多人都知道,胡惟庸和刘基有仇,朱元璋也知道,却派他去探望刘基。而刘基这样有影响的人,胡惟庸是不敢随便动手的,不然也不会让刘基在他眼皮底下逍遥五年,他很有可能是得到了朱元璋的默许。 无论此事是否朱元璋指使,但毫无疑问的是,刘基之死朱元璋是负有责任的。 28.历史上著名的郑庄公,一直不为其母亲所喜爱,他的弟弟也仗着母亲的溺爱,向他提出种种不合理的要求,而郑庄公总是满足他,直到最后,他的弟弟企图谋反,郑庄公才出兵将之灭掉。 后人往往以为郑庄公仁至义尽,传为美谈,可是也有人指出,郑庄公是真正的伪君子,是想要他弟弟的命,才纵容他的不法。 当我们深刻理解了这个故事后,对朱元璋的这种反常举动就会有一个清晰的结论——这是一个阴谋。 这个阴谋在不同的语言方式中有不同的说法,成语是“欲擒故纵”,学名叫“捧杀”,俗语是“将欲取之,必先与之”,用小兵张嘎的话来说是“别看今天闹得欢,当心将来拉清单”。 但我们还有一个疑问,对付一个小小的胡惟庸,朱元璋需要动这么多脑筋,要忍耐他七年之久吗？ 不错,当我们仔细地分析历史,就会发现,胡惟庸绝不是朱元璋的真正目标,朱元璋要毁灭的是胡惟庸背后的那个庞然大物。 朱元璋甘愿忍受胡惟庸的专横,让这个跳梁小丑尽情表演,套用围棋里的一句话来形容就是“不为小利,必有大谋”,他经历如此多的磨难,陈友谅、张士诚、王保保这些当世豪杰都不是他的对手,何况小小的胡惟庸！ 他这样委屈自己,只因他的目标对手太过强大,这个对手并不是李善长,也不是淮西集团,而是胡惟庸身后那延续了上千年的丞相制度。 自从朱元璋当皇帝后,他一直都觉得这个制度过于限制他的权力,他一向认为天下是靠他自己的能力争来的,偏偏有人要来分权,真是岂有此理！ 29.我捧得起你,就踩得倒你！ 30.朱元璋是这样走到这一步的：从茅草屋的风雨到皇觉寺的孤灯,从滁州的刀光剑影到鄱阳湖的烽火连天,他从千军万马中奔驰而出,自尸山血海里站立起来；他经历过无数的磨难,忍受过无数的痛苦,他不畏惧所有的权威,不惧怕任何的敌人；一个个盖世枭雄在他面前倒下去,他见过的死人比胡惟庸见过的活人还多！ 胡惟庸终于明白了为什么李善长不愿意和朱元璋为敌,不是他没有野心,而是因为畏惧。 不用交手,胡惟庸已经明白,自己上错了擂台,他跟朱元璋根本不是一个重量级的选手。 31.值得注意的是,朱元璋在处死胡惟庸后仅一个月，就撤销了丞相这个延续上千年的职位，取消了中书省的设置，安排机构分流人员。如此大动作，却干得雷厉风行、干净利落，这让我们有理由怀疑他是早有准备的，就如同《水浒传》的宋江，晁盖死后无论如何不肯继位，一旦“勉为其难”答应了，立刻就能组织大型庆典。 32.丞相是怎样炼成的。 有人曾对我说，知道历史表象就好，无需知道历史本质。把故事讲明白就行了，至于原因，是无关紧要的。 是的，故事是有趣的，原因是枯燥的。但枯燥的，更有价值。 对很多人而言，诸葛亮和刘伯温是两个神人，他们往往能够预见到事情的发展方向，即使住在农村里，一年进不了几次城，也能够知道天下大势，并能够准确预测未来的走向，如诸葛亮之与“隆中对”，刘伯温之与安丰之战，坐在炕上，盘着腿就能预知未来。 因为他们知道故事，而且了解原因。所以，他们才无比强大。 这个世界上，最让人畏惧的就是未知，如果人人都知道自己的未来，他们就不会再害怕。但在时间机器没有发明之前，我们还是只能向诸葛亮和刘伯温同志学习，比如当我们知道了地主怎样炼成的规律后，下次当你看到史书上的某位农民领袖起义，你不需要再往下看，只要这人没有在起义过程中被人干掉，你就能肯定，下一个王朝中必然多了一个地主。这就是内涵的力量，无比强大的力量。 33.在我们的历史和生活中，有着很多非常奇妙的规则，这些规则看不见、摸不着，却始终起着作用。比如著名的黄金分割，以黄金分割比例确定的图案是最美丽的，划分的结构是最合理的。很多艺术高超的二胡演奏家发现，在胡弦的某个位置拉出的音色非常优美，经过验证，那个位置正是胡弦的黄金分割位。 这些规则实在是太神奇了，如果你依照这些规则去做，你就能够获得事半功倍的效果。而如果你违反这些规则，你将受到它的惩罚。 在历史中也存在神奇的规则，这些规则在冥冥中操纵着一切，没有人可以抗拒它。 在这场拔河中，历史规则也起着作用。一千余年来，王侯将相们根据这一规则确定了自己的位置，而朱元璋无视这一规则，他认为自己能够彻底消灭丞相制度。从某种意义上来说，他确实做到了。 34.在今天我们可以说她(马皇后)是一位伟大的女性:生如夏花，逝如冬雪； 35.蓝玉是一个优秀的将领，却在获得成功之后做出如此多不法的事情，似乎是难以理解的。但其实只要联系我们前面提到过的纳哈出投降事件，就能合理地解释蓝玉的行为。 从宴请纳哈出时的傲慢到喜峰关的骄狂我们可以给蓝玉下一个结论那就是：这是个粗人。 所谓粗人不是指他没有文化或是行为粗鲁，而是指他的行为欠考虑，为人处事不通人情，属于那种想了就干、干了再想的人。其实他的性格一向如此，就算不在这件事上犯错误迟早也会在那件事上捅娄子。 性格决定命运，而关键问题在于蓝玉的命运并不完全掌握在他自己的手中，在很大程度上他的生死只取决于朱元璋的容忍和耐心，而朱元璋并不是个有耐心的人。 36.其实你也可以想到，杀掉一个小小的蓝玉无须牵连这么多的人。而且蓝玉并不是胡惟庸，他的同党并不多，朱元璋却不断地把很多无辜的人当做蓝玉的同党杀掉，这就有点意思了。 在这一举动背后,隐藏着真实的目的. 很多看上去不相干的事情，其实是有着紧密的联系的。在那枯燥的历史资料里面往往隐藏着事实的真相。 37.虽然历史已经过去了几百年，黄沙早已经将那些故往埋葬，但我们还是应该从那些故纸堆中找出真相，还朱标父子一个公道。 因为迟到的公道仍然是公道。 38.事实证明，在这场斗争中，朱元璋失败了。 原因何在呢？答案看起来似乎深不可测，其实很简单： 因为朱元璋只是历史的执行者，他并不是历史的创造者。 即使没有朱元璋，也会有李元璋、王元璋来完成历史的使命，推翻旧的王朝，建立新的帝国。历史是一个好客的主人，但却从不容许客人取代它的位置。历史也从来就不是一个人或是几个人可以支配创造的。所谓时势造英雄，实乃至理名言。 真正支配历史的人，不是朱元璋，是稻田里辛勤劳作的老农，是官道上来往的商贾，是朝堂上进言的官员，是孤灯下苦读的学子。 他们中的大多数人注定默默无闻，都无法在历史上留下自己的名字，但他们才是历史真正的主人。 从古至今，从无例外。 39.自古有云：善用刀剑者，死于刀剑下。 而对于这个婴孩而言，生于战火，死于征途，似乎就是他一生的宿命。 绝对不要做你的敌人希望你做的事情，原因很简单，因为敌人希望你这样做。 ——拿破仑 41.朱棣，是一个可怕的人。 可怕之处不在于他俘获了多少敌人，而在于他在这次军事行动中所表现出来的素质和心智。 他率领数万士兵远涉千里，冒雪顶风，历经千难万苦才找到敌人，这就好比寻宝片中，一群海盗费心劳力，疲惫不堪，终于找到了宝藏。相信所有的人在那个环境下都会极度兴奋。 就要发财了！命运即将改变！ 当时的朱棣也是如此，他千辛万苦才找到了敌人，而此时的敌人也不堪一击，只要下个简单的命令，敌人就会被击溃，然而他却没有这样做。这就好比海盗们找到了藏有宝藏的海岛，打开了箱子，看见了无数的金银珠宝，头领却突然发话：大家回家吧，把财宝留在这里，明年再来取！ 如果有哪个不开窍的头目敢这样说，只怕早就被部下收拾了。 简单的占有是小聪明，暂时的放弃才是大智慧。 朱棣为了这一刻等待了很久，眼看胜利就在眼前，自己的能力终于得到了展现的机会，父亲也会另眼相看，这是极大的诱惑。 然而他放弃了，虽然是暂时的。 他没有理会磨刀霍霍的部下的催促，没有下令去砍杀那些目瞪口呆的元军。他暂时搁置了自己将要获得的荣耀。 这需要何等的忍耐力和抑制力！ 这才是朱棣真正的可怕之处：一个能够忍耐的人，一个能够压抑自己欲望的人。 不要小看这个远征中的插曲，如果你进行认真仔细的分析，就可以从这件事情中获知朱棣的性格秘密。 在史料中，关于朱棣存在着两种完全不同的记载，也代表着他的两种面孔：一种是仁慈和善，他经常和属地的老百姓在一起，为他们主持正义，爱民如子；另一种是残暴嗜杀，用油锅烹死不服从他的大臣，灭杀他们所有的亲属。 这似乎是矛盾的，同一个人怎么会有这样截然不同的两种表现？然而这些都是史实。那么怎么解释这个问题呢？ 答案很简单：朱棣有着两副不同的面孔不是因为他有精神病或者双重人格，恰恰相反，他是一个头脑极其清醒的人。他很清楚自己在做些什么，这两副面孔绝不会同时出现，它们分别有不同的用途。 和善慈悲的面孔用来应付服从他的人，残暴凶狠的面孔用来对付他的敌人。 对于朱棣而言，残暴是一种手段，怀柔是另一种手段，使用什么样的手段是次要的，达到目的才是根本所在。 为了达到目的可以压抑自己的感情，为了达到目的可以勉强自己去做不愿意做的事，为了达到目的可以不择手段！ 42.人生最痛苦的地方不在于有一个悲惨的结局，而在于知道了结局却无法改变。如果说之前的朱棣只是抱怨，那么朱允炆继位后的朱棣就是真的准备图谋不轨了。用法律术语来说，这是一个从犯罪预想到犯罪预备的过程。 43.他告诉我们，坚强的意志和决心可以战胜一切困难。 他告诉我们，执著的信念和无畏的心灵才是最强大的武器。 当朱元璋回望自己几十年的峥嵘岁月，回望自己一手建立的强大国家时，他有充足的理由为之骄傲和自豪！ 我是朱元璋，是大明天下的缔造者！ 44.大家应该从朱元璋的话中吸取教训，一般领导提拔你之前总是要打压一下的，所谓磨炼就是这样来的，千万不要为此和领导闹意见，否则就真有可能一辈子压制下去了. 45.造反需要理由吗？需要，非常需要。在造反这项活动中，理由看上去无关紧要，但实际上，理由虽不是必需的，却也是必要的。 对朱棣而言更是如此，自己是藩王，不是贫农，造反的对象是经过法律认可的皇帝。无论从哪个方面来看，自己都是理亏的。所以找一个理由实在是很有必要的，即使骗不了别人，至少可以骗骗自己。 于是朱棣和道衍开始从浩如烟海的大明法条规定中寻找自己的依据，这有点类似今天法庭上开庭的律师翻阅法律条文，寻找法律漏洞。功夫不负有心人，他们终于找到了法律规则的漏洞，打了一个漂亮的擦边球。 朱元璋并非完全没有料到自己的儿子将来有可能会造孙子的反，他制定了一套极为复杂的规定，用来制约藩王，但为了防止所谓奸臣作乱，他又规定藩王在危急时刻可以起兵勤王，即所谓“朝无正臣，内有奸恶，则亲王训兵待命，天子密诏诸王，统领镇兵讨平之”。 但这个规定有一个关键之处，那就是需要天子密诏。而在朱棣和道衍看来，这个问题是不难解决的，他们充分发挥了自己厚黑学的本领，对这一点视而不见，公然宣称朝中有奸臣，要出兵“靖难”，清君侧。 更让人难以置信的是，他们居然还将这一套歪论写成奏折，公然上奏朝廷，向朝廷要人，摆出一副义愤填膺的模样，这就如同街上的地痞打了对方一个耳光，然后激动地询问肇事者的去向，并表示一定要为对方主持公道。 “靖难”理论的提出和发展充分说明朱棣已经熟练地掌握了权谋规则中的一条重要原理： 如果你喜欢别人的东西，就把它拿过来，辩护律师总是找得到的。 ——腓特烈二世原创 46.黄子澄又一次误判了形势，一个人做一件蠢事并不难，难的是一直做蠢事。只要回顾一下此人以往提出的各种天才意见，就会发现他确实完成了这个高难度的任务。如果此人后来不是尽忠而死，恐怕逃脱不了燕王间谍的嫌疑。 47.人生最痛苦的事情，莫过于不得不玩一场绝对不能输的游戏。 48.即使你的敌人无比强大，即使你没有好的应对方法，但只要你有敢于面对强敌的决心和勇气，你就会发现，奇迹是可以创造的。 49.决定战争胜负的并不一定是先进的武器和士兵的数量，而是人的决心和智慧. 50.失败算不了什么，希望的丧失才是最大的痛苦。 51.所谓气节这样东西，平日被很多人挂在嘴边，也经常被当做大棒来打别人，但真正的气节总是在危急关头表现出来的。而在这种时候，坚持气节的下场往往不会是鲜花和掌声。 只有那些真正的英雄，才能在面对屠刀时体现出自己的气节。 52.暴力不能解决一切，却可以解决你。 53.从历史中我们可以知道，宽容从来都不是软弱。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ijiangnanbei.com/tags/读书笔记/"}]},{"title":"如何看懂一个程序？","date":"2017-05-06T15:31:30.000Z","path":"2017/05/06/如何看懂一个程序？/","text":"看别人的程序，从别人的程序中学习对程序人来说是一件非常重要的事，但首先你得能看懂别人的程序，那么如何才能看懂别人的程序呢？具体来说只需要三步： 1.弄明白程序执行的流程，即程序执行的顺序,先执行哪一个后执行哪一个。 2.在弄明白语句执行的流程的基础上弄明白每一个语句的功能。 3.试数。所谓试数就是说你要给程序不同的输入，然后把自己当成计算机看看每一个不同的输入对应的输出的结果是什么。试数的时候，我们一般是在草稿之上写程序执行的过程，要注意你一定要写的整齐，详细，规范，只有这样你才能够明白这个程序到底要做什么。 最后我想说，有时候我们之所以看不懂程序那是因为我们没有把自己当成计算机一样一步一步的去执行，说白了，那是因为你懒！","tags":[{"name":"编程思想","slug":"编程思想","permalink":"http://ijiangnanbei.com/tags/编程思想/"}]},{"title":"给你一个亿，你能干什么？","date":"2017-04-22T15:38:00.000Z","path":"2017/04/22/给你一个亿，你能干什么？/","text":"“我给你一个亿，你能干什么？”这句话像照妖镜，常常能把人问得张口结舌、面红耳赤，一时间江郎才尽、无言以对。 1.创业绝对不是钱的问题。 2.创业者必须是个创新者。 创业就是创新，不然的话人人都可以说：“你把钱给我吧，我也去开个‘国美’连锁大卖场吧，我也去珠海开发房地产吧，我也做一个YouTube、MySpace、《魔兽》、‘支付宝’、‘狗扑’、‘犹酷’、‘开膛网’吧……”没人敢这么说是因为人人明白忽悠至多只能骗些小钱，搞大钱是要凭真功夫的，真功夫就是创新、创新、创新！！！创业就是要创新，不玩点儿新名堂，VC怎么会对你感兴趣？没有点儿新花招，你怎么能够击败竞争对手而成为市场的宠儿？没有新产品、新服务、新模式、新用户体验，怎么会有消费者青睐你、掏腰包大把大把付你钱？当然，创业也未尝不是没有人去卖山寨机、去偷工减料把同类产品做得更烂卖得更便宜，去靠“让利”和“打折”作为自己抵挡竞争的武器……人生难得几回搏，一旦你走上了创业之路，一定要想好，十字路口，向东走还是向西走？ 人们常常误解“创新”，以为分析一下市场数据，就可以马上“创新”出产品去填补市场空缺；回头看了一下历史，就以为自己能够看清未来。所以常常有人以为：因为PC时代到来了，为了弥补市场的空缺，所以乔布斯发明了个人电脑，比尔-盖茨发明了Windows……错也错也，乔布斯发明苹果电脑完全是由着自己的兴致干一件自以为是充满刺激的事情，比尔-盖茨的Windows垄断了PC操作系统完全是因为“蓝色巨人”IBM在错误的时间做了一件错误的事情，昏头昏脑地送给了比尔-盖茨一个发大财的机缘。 其实，人类预测未来的能力很低。为什么世界上只有一个爱因斯坦？为什么苹果从树上落下来砸到那么多人脑袋上却只有牛顿想到了“万有引力”？为什么千百个山寨机中只有一个iPod、一个iPhone鹤立鸡群？ 直截了当问你吧，你能不能告诉我，10年以后你如何听音乐？你会不会还继续使用你那台老掉了牙的iPod？iPod到那时应不应该被颠覆掉？如果你能够看到未来，能想出将会取代iPod的新玩意儿，那么，全世界的VC都会抢着过来砸钱给你，让你去把乔布斯这小子给灭了，让他到时候也来跟风造山寨机。 创新是个神秘的过程，谁要是拍胸脯说自己知道如何创新，那是呓语。。。。。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"},{"name":"商业","slug":"商业","permalink":"http://ijiangnanbei.com/tags/商业/"}]},{"title":"面向过程与面向对象的区别","date":"2017-04-22T03:19:16.000Z","path":"2017/04/22/面向过程与面向对象的区别？/","text":"从编程发展史谈面向对象当软件还非常简单的时候，我们只需要面向过程编程：12345678910111213141516定义函数函数一函数二函数三函数四定义数据数据一数据二数据三数据四最后各种函数，数据的操作。 当软件发展起来后，我们的软件变得越来越大，代码量越来越多，复杂度远超Hello World的时候，我们的编写就有麻烦了：函数和数据会定义得非常多，这时候就面临两个问题。 首先是命名冲突。英文单词也就那么几个，可能写着写着取名时就没合适的短词用了，为了避免冲突，只能把函数名取得越来越长。 然后是代码重复。比如你做一个计算器程序，你的函数就要确保处理的是合理的数据，这样最起码加减乘除四个函数里，你就都要写对参数进行检测的代码，写四遍或者复制粘贴四遍不会很烦，但多了你就痛苦了，而且因为这些检测代码是跟你的加减乘除函数的本意是无关的，却一定要写在那里，使代码变得不好阅读，意图模糊。 比如你做一个计算器程序，你的函数就要确保处理的是合理的数据，这样最起码加减乘除四个函数里，你就都要写对参数进行检测的代码，写四遍或者复制粘贴四遍不会很烦，但多了你就痛苦了，而且因为这些检测代码是跟你的加减乘除函数的本意是无关的，却一定要写在那里，使代码变得不好阅读，意图模糊。 随着软件业的发展，解决办法就要出来了： 代码重复。我们可以用函数里面调用函数的方法，比如把检测代码抽出来成一个独立函数，然后加减乘除四个函数运行时只要调用一下检测函数对参数进行检查就可以了。分布在四个函数里的重复代码变成了一个函数，是不是好维护多了。 命名冲突，我们就把这一堆函数们进行分类吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//分类之前，我们取名只能这样取：检测整数加整数减整数乘整数除复数加复数减复数乘复数除小数加...//进行分类后我们取名可以这样取：整数 &#123; 检测 加 减 乘 除&#125;复数 &#123; 检测 加 减 乘 除&#125;小数 &#123; 检测 加 减 乘 除&#125;分数 &#123; 检测 加 减 乘 除&#125; 这个时候一种叫做类的概念就呼之欲出了，这样我们打开一个整数类代码文件，里面就是简简单单的加减乘除四个函数，简单清晰不会跟外面的其他加减乘除函数命名冲突。 当然，进行归类后，又出现了各种问题和与之对应的解决方法，比如四个类中的检测也是应该提取出来的，所以简单的起因最终发展出什么继承衍生之类挺复杂的一套编程模式。然后学术界那帮人就又乱起什么高大上的名字了，所谓面向对象程序设计去祸害大学里那帮孩子。 就算未来出来一个什么新的面向XX编程，我们也不用多想为什么会出现，肯定是为了解决麻烦而已。 123456789101112131415//上面进行归类以后，代码其实还是不好维护的，然后我们就继续提取为：数 &#123; 检测 加 减 乘 除&#125;整数 &#123; 沿用上面数的设计&#125;小数 &#123; 沿用上面数的设计&#125; 所谓继承，就是数这个类的整体设计，沿用给整数，分数小数这些类，作为他们的编写大纲去编写加减乘除这些函数的具体代码。根据整数，分数，小数各自的性质，做出各自的调整。 这时数这个类，如果你给它里面的加减乘除函数的写了一些很粗糙简单的代码，就叫做父类，基础类。子类们“继承”了父类（把代码进行了复杂化）。 如果没写，那这个类其实就只是个设计图，叫做抽象类。子类们“实现”了抽象类（把空空的设计变成了具体代码）。 模版是什么？像 C++ 这种复杂成狗的语言是强类型的，就是给变量进行了类型区分的，比如整数类型，双整数类型。很明显这两种变量所能容纳的数据体积是不一样的，单个函数不能通吃多种类型的参数，我们就可能会面临下面两套代码并存的局面。1234567891011121314151617//第一套代码：单整数类 &#123; 单整数加 单整数减 单整数乘 单整数除&#125;//第二套代码双整数类 &#123; 双整数加 双整数减 双整数乘 双整数除&#125; 所以 C++ 跟其他强类型语言为我们提供了一个所谓模版功能：12345678910111213&lt;变量类型&gt;整数 &#123; &lt;变量类型&gt;加 &lt;变量类型&gt;减 &lt;变量类型&gt;乘 &lt;变量类型&gt;除&#125;/*整数类等于把变量类型设置为整数，套上模版双整数类等于把变量类型设置为双整数，套上模版 这样就写了一份代码，得到了两份类的代码。当然，弱类型的编程语言，比如 JavaScript 或者 PHP 是没有这种烦恼的，因为变量没有类型之分。但变量类型有时候还是很重要的，弱类型语言里就会出现类似数加字符串这种运算，可能并不是程序员的预期和本意，所以比起强类型性语言而言经常会出现很多无聊的BUG。*/ 上面发展出了父类之后，我们发现编程还是有问题的，小数类：123456小数类 &#123; 加 减 乘 除&#125; 如果我们需要一个能自动实现结果四舍五入的小数计算类，同时又需要一个不实现结果四舍五入的小数计算类，怎么办呢，难道要写两个类吗？不要。所以做出了“实例”或者“对象”这一东西，首先把类改成：123456789小数类 &#123; 标识变量：是否四舍五入 标识变量：是否限定小数点后位数 构造函数（设置上面的标识） 加（会根据上面两个标识变量输出不同结果） 减（会根据上面两个标识变量输出不同结果） 乘（会根据上面两个标识变量输出不同结果） 除（会根据上面两个标识变量输出不同结果）&#125; 这样，我们就写一个类，但是通过构造函数，把一份代码，构造出了行为稍微有点不同的两个实例供我们使用，这时候名词来了，不能进行实例化微调化的类，叫做静态类，函数们的行为是固定的。不能实例化的类，其实只是函数们的一个集合归纳，只是对函数进行了整理，功能的强大和编码的自由灵活度是不够的。 能够进行实例化，变化出各种行为各自不大一样的实例的类，我们一般就把它们叫做类了，因为最常见。 程序员们也就能保持代码简单的同时而又可以很方便进行代码行为微调了。 面向过程与面向对象的区别，由如何把大象装进冰箱来看1.面向过程为了把大象装进冰箱，需要3个过程。123456789101112131415161718192021222324/*思路：1.把冰箱门打开（得到打开门的冰箱）2.把大象装进去（打开门后，得到里面装着大象的冰箱）3.把冰箱门关上（打开门、装好大象后，获得关好门的冰箱)*///每个过程有一个阶段性的目标，依次完成这些过程，就能把大象装进冰箱。//写法一：1：冰箱开门（冰箱）2：冰箱装进（冰箱，大象）3：冰箱关门（冰箱）//写法一变体：1：（冰箱开门 冰箱）2：（冰箱装进 冰箱大象）3：（冰箱关门 冰箱）//写法二：冰箱关门（冰箱装进（冰箱开门（冰箱），大象））//写法二变体：(冰箱关门 (冰箱装进 (冰箱开门 冰箱) 大象)) 面向对象 为了把大象装进冰箱，需要做三个动作（或者叫行为）。每个动作有一个执行者，它就是对象。12345678910111213141516 /* 思路： 1.冰箱，你给我把门打开 2.冰箱，你给我把大象装进去（或者说，大象，你给我钻到冰箱里去） 3.冰箱，你给我把门关上 */ //依次完成这些动作，你就可以把大象装进去 //写法一：1：冰箱.开门()2：冰箱.装进(大象)3：冰箱.关门()//写法二：冰箱.开门().装进(大象).关门() 总结再来一个简单的栗子：有一天你去买电脑，发现什么显卡啊、内存啊、处理器啊、价格一概不懂，于是你就懵逼了，没办法啊不懂自己就去网上查呗，于是自己捣鼓了半天终于弄懂了这才放心去买–这是面向过程。 有一天你去买电脑，自己还是不懂，于是你就叫上了一个懂电脑的哥们，其余所有事情都交给他来做了，你只管付钱了。–这是面向对象。 面向过程：执行者；面向对象：指挥者； 面向过程还是对象，名词并不重要，重要的是哪个适合，软件工程师们自己根据项目复杂度进行选择罢了。 参考文献一，参考文献二。","tags":[{"name":"编程思想","slug":"编程思想","permalink":"http://ijiangnanbei.com/tags/编程思想/"}]},{"title":"什么是营销?","date":"2017-04-14T14:35:35.000Z","path":"2017/04/14/什么是营销/","text":"何谓营销?营销是作为思维的存在，而非具体学科.你所学所知的“市场营销”，其实是“企业营销”，冰山一角而已。 那么什么是营销？ 营销就是A为B创造对方想要的价值，建立与维持关系，以获得回报的思维过程. 思维过程表达式：STP+4P+CRM A与B的等量代换能生一切法，真实不虚. ###先说企业营销 把“企业”代入A，把“消费者”代入B，我们可以得到这样一个定义：企业营销就是企业为消费者创造对方想要的价值，建立与维持关系，以获得回报的过程。是不是和科特勒的定义几乎一模一样？此处结合过程表达式展开说企业营销，毕竟社会公认营销就是企业营销。 企业营销过程就是： 1.STP:企业通过消费者洞察与市场调查，了解消费者有哪几类（S市场细分），自己最有优势的是哪类消费者（T目标市场选择），自己要在这类消费者大脑中占据“最”什么或“第一”什么的位置（P定位）。 2.4P:完成STP之后，企业以独占目标消费者大脑中的目标位置为出发点与目标为消费者制造产品价值与塑造品牌价值（4P之产品与价格）、提供产品与品牌价值（4P之渠道）、传播产品价值与品牌价值（4P之宣传，特别说明国内多数市场营销教科书将4P中的“Promotion”翻译为“促销”与“销售促进”都是极其脑残的，因为促销本身是Promotion中的一个组成部分，而销售促进则不包含传播品牌价值，都是云遮雾绕的译法）。 3.CRM:做好上述价值创造工作，我们就可以通过客户关系管理（CRM）与内外部消费者建立并维持关系，并持续获得产品利润与品牌利润的回报了。 企业营销就是这样一个营销思维过程。虽然企业营销总被当成营销，但企业营销绝不是营销的所有。 那么，何还谓营销？ ###又如，恋爱 把“恋爱中的一方”代入A，把“恋爱中的另一方”代入B，我们可以得到这样一个定义：恋爱就是恋爱中的一方为恋爱中的另一方创造对方想要的价值，建立与维持关系，以获得回报的过程。 知道怎么恋爱了吗？若不明确，就把“你”代入A，把“小妞”代入B，恋爱就是你为小妞创造对方想要的价值，建立与维持关系，以获得回报的过程。过程表达式：知道小妞大体有几种类型，对于自己最有优势搞定的是哪类小妞，以及自己在选中类型小妞的大脑中独占什么什么样的Mr.Right标准；按对方心中Mr.Right的标准打造自己，若即若离但总在对方需要的时候出现，用一切方法让她确信你就是她的近在眼前的Mr.Right；建立并维持如胶似漆的恋爱关系，然后一晚上、一段时间或一辈子活活美死去吧。恋爱就是这样一个营销思维过程…… 复次，何又谓营销？ ###又如，职业生涯 把“员工”代入A，把“老板”代入B，我们可以得到这样一个定义：职业生涯就是员工为老板创造对方想要的价值，建立与维持关系，以获得回报的过程。 过程表达式：知道老板有哪几类，自己最适合的老板的是哪类，自己要成为该类老板心中什么岗位不可或缺的人才；通过努力使自己符合该类老板心中该岗位不可或缺的人才的标准，为公司持续贡献价值，并让老板耳闻目染你的价值与贡献；建立并维持相互忠诚的雇佣关系，老板离不开你之后就可以获得提薪或升职了。职业生涯就是这样一个营销思维过程…… 然后，何复谓营销？ ###甚至，人生 把“自己”代入A，把“生活”代入B，我们可以得到这样一个定义：人生就是自己为生活创造生活想要的价值，建立与维持关系，以获得回报的过程。 过程表达式：知道世上有什么样的生活，自己最适合什么样的生活，自己要在选择的生活中活出什么样的精彩；学习如何把自己选择的生活过得精彩，之后将生活过得精彩，让人生无憾所选择的生活；建立与维持自己与所选生活的各种微妙平衡，让自己可以始终享受所选生活给你的满足。人生也不过是这样一个营销思维过程…… 问：何谓营销。答：营销作为思维无所不在，何不谓曰营销？只要你用营销思维观想世界。 (原文链接：https://www.zhihu.com/question/20047841/answer/13799890)","tags":[{"name":"营销","slug":"营销","permalink":"http://ijiangnanbei.com/tags/营销/"}]},{"title":"如何制造病毒营销？","date":"2017-04-11T15:55:29.000Z","path":"2017/04/11/如何制造病毒营销？/","text":"要制造病毒式营销的核心首先你要去抓住人们的好好奇心。说有这么一个人，他在城市里面所有的地方都贴上了这几个字“我要去大山”，那别人就很好奇，这个到底是什么意思，就这大家都百思不得其解的时候，这个人又在这个城市的所有地方都贴上了“我要去大山英语学校”，于是当年的业绩爆了30倍。 其实如果你想要制造病毒式的营销，最重要的就是：首先你要抓住人与人之间那种微妙的心理，看看究竟是什么能够刺激人内心深处的那个G点，然后你在用一种比较适合病毒式传播的形式，然后把它连接起来。 比如说：第一：好奇心。第二个：竞争欲。第三：炫耀。 营销真的很难吗？ 学透了心理学，你也可以做到。说白了，其实就是在玩人性的游戏。","tags":[{"name":"营销","slug":"营销","permalink":"http://ijiangnanbei.com/tags/营销/"}]},{"title":"产品缺点变卖点","date":"2017-04-10T14:54:37.000Z","path":"2017/04/10/产品缺点变卖点/","text":"有时候，商品的缺点也能变成卖点，关键看你如何引导！ 有一淘宝店在网上卖键盘膜，老是收到差评，纷纷指责键盘膜太薄了，说店家偷工减料，以次充好。店家临机一动，在标题和主图上加上了：超薄型!. 从此以后,好评连连.","tags":[{"name":"营销","slug":"营销","permalink":"http://ijiangnanbei.com/tags/营销/"}]},{"title":"《穷查理宝典》","date":"2017-04-10T06:42:02.000Z","path":"2017/04/10/《穷查理宝典》/","text":"《穷查理宝典》收录了查理过去20年来主要的公开演讲。除简单而权威的查理传略外，其后的《芒格的生活、学习和决策方法》以及《芒格主义：查理的即席谈话》整理了芒格最精华的思维与决策方式和以往在伯克希尔·哈撒韦公司和西科金融公司年会上犀利——和幽默——的评论。 而最后最珍贵的十一篇讲稿则全面展现了这个传奇人物的聪明才智。贯穿全书的是芒格展示出来的聪慧、机智，其令人敬服的价值观和深不可测的修辞天赋。他拥有百科全书式的知识，所以从古代的雄辩家，到18、19世纪的欧洲文豪，再到当代的流行文化偶像，这些人的名言他都能信手拈来，并用这些来强调终身学习和保持求知欲望的好处。 1.生活 如果我们在生活中唯一的成功就是通过买股票发财，那么这是一种失败的生活。成功的投资只是我们小心谋划、专注行事的生活方式的副产品。我们要能够比其他人更快更准确地分析出任何种类的交易，能够在60秒内找出令人信服的弱点。但是，生活不仅仅是精明地积累财富。我们要追求人生幸福，我们为此可以采取逆向思考的方式：如果要明白人生如何才能得到幸福，首先研究人生如何才能变得痛苦；研究企业如何做强做大，首先研究企业如何倒掉。生活上的大多数成功来自于你应该知道避免哪些事情（死亡、糟糕的婚姻艾滋病、吸毒）。培养良好的行李习惯，避免邪恶之人，尤其是那些性感诱人的异性。在生活里面我们要拥有良好的客观态度、个性素质——自律、耐心、冷静、独立。当然，你这么做会让你有所孤立，但是如果你因为你的特立独行而在周围人中不受欢迎——那么你就随他们去吧。 对于生活，我们追求朴素，一切从简：我们赚钱，靠的是记住浅显的，而不是掌握深奥的。我们从来不试图成为非常聪明的人，而是持续地试图别变成蠢货，久而久之，我们这种人便能获得非常大的优势；我们并不自称是道德高尚的人，但至少有很多即便是合法的事情，也是我们不屑去做的（有性格的人才能拿着现金坐在那里什么事也不做，我能有几天，靠的是不去追逐平庸的机会。）；所以对于谎言，我们的办法很简单——说真话，将无需记住你的谎言——就这么简单；满足我们已经拥有的：在生活中减少物质需求——你不需要很多物质的商品来满足自己大量愚蠢的需求（这些需求自然会很快消失）；在生活中不断培养自己理想性格（投资性格）：毫不妥协的耐性、自律，自控——无论遭受多大的压力也不会动摇或者改变原则 当然，我们还要有自知之明：一方面我们不需要懂很多事情，“我没有足够的能力来回答这个问题”“在这个领域我没有能力给你任何特殊的见解”——当你不了解、也没有相关的才能时，不要害怕说出来，没有人期望你什么都懂。有些人总是很自信地回答他们其实并不了解的问题，我不喜欢跟他们在一起。在我看来，他们就像是那只乱跳舞的蜜蜂，只会把整个蜂窝搞得乱哄哄的，而另一方面，如何对付错误和那些改变赢面的新情况，也是你们必须掌握的知识之一。如果你不明白有舍才有得的道理，如果你以为鱼与熊掌可以见得，那么你就太傻了。生活有时候就像扑克游戏，有时候你们即使拿到一把非常喜欢的牌，但也必须学会放弃。 2.学习学习100种模型，它们能够给你带来特别大的力量。当几个模型联合起来，你就能得到lollapalooza效应——这是好几种力量共同作用于同一个方向，而且你的道德通常不仅仅是几种力量之和。在投资领域我将这个学习方法称之为“生态”投资法：完美地糅合来自各个传统学科的分析工具、方法公式，这些学科包括：历史、心理、生理、数学、工程、生物、物理、化学、统计、经济等。这个投资法的理论基础是：几乎每个系统都受到多种因素的影响，所以若要理解这样的系统，就必须熟练地运用来自不同学科的多元思维方式。你必须意识到——生活无非就是一个接一个的联系。所以你必须拥有各种模型，你必须弄清楚各种模型的相互关系以及它们的效应，你必须辨认出这些事情之间的关系。如果你把自己训练得更加客观，拥有更多学科的知识，那么你在考虑事物的时候，就能够超越那些比你聪明得多的人，我觉得这是很好玩的。再说了，那样还能赚到很多钱，何乐而不为呢？所以与其创立一种有漏洞的制度，还不如就不要赔偿了——就让生活艰辛一些。 争取掌握近100种模型和一些思维技巧，那并不是很难的事情。这么做的好处在于绝大多数人不会这么做——部分原因是他们接受了错误的教育。所以我们必须全面掌握各种主要模型，把它们当作一张检查清单。再强调一些：你们必须注意那些能够产生lollapalooza后果的多因素组合效应。 有关我们在学校的教育，我们必须要认识到其局限性。很多聪明人之所以会犯错，大概是他们没有掌握所有重要的模型，把它们当作检查清单，用来审视各种复杂系统的结果。我们不能依照你们教授传授的方法来学习。你们应该学习他们传授的一切，但你们还应该学习许多他们没有教的知识——因为这些教授们并没有正确地对待他们自己的学科。大多属于教授用一个假定来解决这个问题：“如果我不能用实验来证明它，它就是不存在的。”然而，他们的假定明显是愚蠢的，如果有的事情在生活中极为明显，但很难通过容易做的、可重复的学术实验得到证明，这些的讯菇犬就会忽略它。如果有些东西非常重要，但由于道德约束，你们无法完美而准确地证明它，那么你们也不应该把它当作是不存在的。你们必须经历而为，利用现有的证据去证明它。而在你学习了心理学之后，你也要注意：装备基本的心理学力量的技巧（也就是说当你知道该怎么做）之后，你们必须依据道德规范来调整自己的行为。并不是你们懂得如何操控人们之后，就可以随心所欲地去操控他们。如果你跨过了道德的界限，而你们试图操控的那个人因为也懂得心理学，所以明白你们的用意，那么他就会恨你们。 当然了，我们的脑子没有那么好使，很多时候我们的确很难记住一些东西，还好前辈们给我们留下了两样宝贝：图表和优秀的文学作品。前者可以弥补弥补我们天生不擅长处理数字的缺陷；而后者逼着我们需要略加思考才能理解——只有这样它对我们的影响会很深，我们会更牢固地记住它（如果你动脑筋才懂得某个道理，你就会更好地记住它）。 3.工作当我们年轻的时候，我们在工作中应该尽量做到以下三点，当然了同时满足他们几乎是不可能的，但你应该努力去尝试： 1）不兜售你自己不会购买的东西 2）不为你不尊敬和倾佩的人工作 3）只跟你喜欢的人同事 工作上我们常常会主动或被动地有保留地接受专业顾问的建议，这里给出一般的对策： 1）如果顾问提出的专业建议对他本身特别有利，你就应该特别害怕这些建议 2）在和顾问打交道时，学习和使用你的顾问所在行业的基本知识 3）复核、质疑或者更换你得到的建议，除非经过客观考虑之后这些建议看起来是合理的 随着时间流逝，我们在长大，而我们的人生在不同阶段会遇到不同的难题，非常棘手的难题。这时候有3点有助于应付这些困难： 1）期望别太高 2）拥有幽默感 3）让自己置身于朋友和家人的关爱之中 4）最重要的是，要适应生活的变化。如果世界没有改变，我们现在身上会有更多的缺陷。 4.投资所谓投资这种游戏就是比别人更好地对未来作出预测。你怎样才能够比别人做出更好的预测呢？一种方法是把你的种种尝试限制在自己能力许可的那些个领域当中，光有好几回是不够的，我们能看明白这个领域到底是什么，所以得在我们能看明白的领域出现定错价的机会。这种机会不会经常出现。相反，如果你花费力气想要预测未来的每一件事情，那你尝试去做的事情太多了。你将会因为缺乏限制而走向失败。投资之所以困难，是因为人们很容易看出来有些公司的业务比其他公司要好，但他们股票价格升得太高了，所以突然之间，到底应该购买哪只股票这个问题变得很难回答。所以我们要把投资局限在简单而且好理解的备选项目之内——关于投资，我们只有3个选项：可以投资（容易理解、有发展空间、能够在任何市场环境下生存的主流行业）、不能投资（大张旗鼓宣传“交易”和公开招股）、太难理解（高科技、制药）。 投资股市最大的风险其实并不是价格的上下起伏，而是你的投资未来会不会出现永久性的亏损。单纯的股价下跌不仅不是风险，简直就是机会。不然那里去找便宜的股票呢？有些人的个性天生就不适合投资，他们要么过于焦躁，要么缺乏耐心。我认为优秀的品性比大脑更重要，你必须严格控制那些非理性的情绪，你需要镇定、自律，对损失与不幸淡然处之，同样地也不能被狂喜冲昏头脑。只有当你具有较好的个性（主要是指你非常有耐心），拥有了足够的知识后，势必进行大规模进攻，然后就会慢慢学会游戏规则，部分通过实践，部分通过学习别人的经验。显而易见，你能从别人那儿获得的启发越多，你的情况就会越好。 要记住那些竭力鼓吹你去做什么事的经纪人，都是被别人支付佣金和酬金的，那些初涉这一行、什么都不懂的投资者不如先从指数基金入手，因为它们毕竟由公共机构管理，个人化的因素少一些。一个投资者应当掌握格雷厄姆的基本投资方法，并且对商业经营有深入的了解，你要树立一个观念：对任何价值进行量化，并比较不同价值载体之间的优劣，这需要非常复杂的知识架构。 5.思维模型原则思维模型原则（你必须把经验悬挂在头脑中的一个由许多思维模型组成的框架上）： 1）你必须拥有多元思维模型——因为如果你只能使用一两个，你将会扭曲现实。 2）这些模型必须来自各自不同的学科——因为你不可能在一个小小的院系里面发现人世间全部的智慧。 3）使用最可靠的思维模型 1.硬科学/工程学：特别是质量控制理论（基础是费马和帕斯卡的基础数学理论）。 2.生物学/生理学：因为我们大家毕竟在基因构造方面都是相同的。 3.心理学：懂得如何利用人性，让大脑以某种错误运转的人能够使你看到根本不存在的东西。重点掌握核心内容里的误判心理学，包括20个小原则。 4.微观经济学：不过他不是那么可靠，这种人类智慧要小心使用。 4）了解所使用模型的局限：这一点也可以用来操控和激励别人 世界上不存在不犯错误的学习或行事方式，只是我们可以通过学习，比其他人少犯一些错误——也能够在犯了错误之后，更快地纠正错误。但既要过上富足的生活又不犯很多错误是不可能的。实际上，生活之所以如此，是为了让你们能够处理错误。那些破产的人的通病是无法正确地处理心理否认","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ijiangnanbei.com/tags/读书笔记/"}]},{"title":"《牛奶可乐经济学》","date":"2017-04-10T06:35:57.000Z","path":"2017/04/10/《牛奶可乐经济学》/","text":"《牛奶可乐经济学》原名叫做《经济博物学家：破解日常生活的密码》。作者罗伯特•弗兰克教授著有最畅销的中级经济学教材《微观经济学和行为》，他教的微观经济学入门课程每年都会吸引6000多名学生，他布置过这样的书面作业：“利用经济学原理，探讨你亲身观察到的事件或行为模式中的有趣题。”而且不要长篇大论，字数限制在500字以内。“文章里面不要掺杂复杂的技术，要假设你是在给一个从没上过经济学课的亲戚讲故事。” 《牛奶可乐经济学》就是一本这样的故事合集。问题千奇百怪，分析工具却相当简单——成本效益原则。当一个行动带来的收益大于成本时，人们就会采取行动。这是绝大多数举动的根源。 比如，为什么最畅销的书常常打折销售，而最热门的电影却不打折？因为对电影院来说，最稀缺的资源不是电影本身，而是座位。大受欢迎的电影即使不打折也会满座，出于收益最大化的考虑，电影院有理由不给票价打折。但是书不一样，如果预见到哪些产品更热门，卖家往往可以提前准备好充足的库存。卖家给书打折以促进销量，是更有利的做法。为什么机票现卖价格更高，而演出门票现买却更便宜？因为航空业主管们发现，出公差的商务人士更倾向于临时决定出行安排，而他们往往是高收入者，要么很富裕，要么可报销，对价格并不敏感。而演出不一样，高收入者一般不愿意到最后一刻才买票，临时买票毕竟要面对不知道能不能买到、也不知道还有什么样的座位等不确定因素。事到临头才在售票口买票的，大多是对价格比较敏感的人。 为什么“维多利亚的秘密”要提供价值数百万美元的镶钻胸罩，虽说从来没人买过？因为镶钻胸罩显然是个很能够吸引眼球的新闻噱头，而且成本并没有想象中那么高，它的主要价值在于镶钻，而钻石很容易回收，可以重复使用。但是，它起到的作用却非常明显。它改变了人们对送礼物该花多少钱的参照系，把“别人花了几百万美元”的想法悄悄灌输到人们的意识里，于是，花几百美元买上一款高级胸罩就显得没那么荒谬了。 为什么男性立法者也赞成废除一夫多妻制呢？很多人觉得一夫多妻制对女人不利、对男人来说倒是件好事。其实，对于一部分男士来说，一夫多妻制的确是有利的，但是，多妻制会造成男女比例失衡，女性供应量持续短缺，不少男人完全结不上婚，男人面临的压力更大，所以，禁止多妻制的法律实际上充当了一种限制恶性竞争的协议，以免男人过得太辛苦。 为什么某企业奖励员工一辆豪华轿车，而不是等值的现金？经济学家有一个很有说服力的观点：最好的礼物，往往是我们想要但是又不舍得买的东西。被奖励，等与别人帮着自己做出了选择，自己可以开开心心享受奖品，又无需为自己的奢侈行为感到愧疚。 书中提出了100多个这样的问题，全部来自于日常生活经验，涉及产品设计、供求关系分析、公用品、人际关系、心理学、职场风云等等各个方面，作者说“这些生活中的问题不是公式和概念，它们并没有标准确切的答案，每个人都有可能给出更多更合理的解释。”这也许正是此书的魅力所在。人人都可以从经济学的角度来分析经济生活现象，我思故我在，人生因此充满乐趣。作为一个“从没上过经济学课的亲戚”，这种书让人读得真是高兴。独特的观察角度，如同一场美妙的智力探险，情趣盎然。不枝不蔓，一个圈子也不绕，尽量用最简单的方法来解决问题，没有高深的数学模型，成本效益原则，边际效益分析，机会成本分析……都是最基础的经济学概念。如同高手，无招胜有招，手中不需藏利器，拈花飞叶，皆可伤人，何必非要倚天剑、屠龙刀？ 所以，花点时间翻翻看这本书，应该是能赚到的吧？谨以此篇文章献给每一位热爱生活，热爱思考的朋友们!","tags":[{"name":"经济学","slug":"经济学","permalink":"http://ijiangnanbei.com/tags/经济学/"}]},{"title":"为什么要读书？","date":"2017-04-10T06:30:05.000Z","path":"2017/04/10/为什么要读书？/","text":"在我们的的生活中总是要有一些这样的人，当我们被困在了一个漆黑的山洞中，我们的粮食只能够吃有限天，面临着前方的未知和恐惧，以及资源的有限，我们不可能让每个人都去探寻出口，于是我们就把多数的粮食给了其中一些人，让他们去摸索出口，找到以后再回来带我们出去……我便是其中的一员，书籍就是我的粮食，时间是我的朋友。至于最终我会摸索到什么，别急，让时间告诉你…… 那么我们为什么要读书呢？首先我觉得我们读书是为了让我们更加了解这个世界，当你更加了解这个世界的时候，无论你身处何处你的内心都不会有丝毫的慌张和恐惧，因为你知道世界就是这个样子，它就在那里。其次，有时候读书它是一件没办法的事情啊，你不读书你就没法和一些有趣的人有思想的人交流，就好像不能见面就只好写信一样，书只是一个载体，人和人之间的关系才是这个世界的根本。“你现在的气质里藏着你读过的书和爱过的人”，爱过的人不是你能够决定的，但是如果你能选择自己想看的书，最终会让你慢慢成为自己想成为的人。 希望你看到这篇文章之后能够多去看一些好书,哪怕只是略读一下也好,说不定那一本就改变了你呢…","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ijiangnanbei.com/tags/读书笔记/"}]},{"title":"《明朝那些事》","date":"2017-04-10T06:24:31.000Z","path":"2017/04/10/《明朝那些事》有感/","text":"高中与《明朝那些事儿》擦肩而过，那时候我的我喜欢钱钟书，喜欢韩寒，喜欢李敖，喜欢鲁迅。 大一我一股脑的钻研商业，那时候我喜欢Jason Fried，我喜欢彼得·蒂尔，我喜欢罗伯特·弗兰克、布莱克·马斯特斯、贝索斯、李善有、乔布斯、吴晓波、罗振宇、罗永浩、马尔科姆·格拉德威尔、埃里克·施密特…… 现在大二虽然现在我的世界里更多的是郭霖、是刘末鹏、是Benjamin J. Evans、paul graham ……但是我仍旧在这一年之内将《明朝那些事儿》一书共七部通读了两遍。恩，历史可以很“好玩”。历史是一个非常狡猾的动物，它有很多话想讲但是它就是不告诉你，只有当你能“从字里面看出字来时”，你才能够理解什么是历史。第二次看完《明朝那些事》，我看到了痛苦，挣扎，悲伤，追悔莫及，我看到了“情绪”。为什么我们很多人不懂历史？《明朝那些事儿》的作者当年明月说：“是因为你不知道，那个是真实发生过的，历史从来就不是故事，它是真的，这就是历史的秘密”。 第二次读《明朝那些事儿》，短短的数天之间见证了无数人的一生，每当我翻过一页纸，我就知道很多人的一生就这样结束了，他们当中的一些人在历史没有任何记录，甚至当他们的战友发现他们的尸体的时候都不知道他叫什么名字，他们的一辈子可能就只有一句话，你能理解他们的痛苦吗？当你看到我说这句话的时候可能觉得没有什么，内心甚至不会泛起一丝涟漪，但是我要告诉你他们父母再也见不到他们的儿子，妻子没有了丈夫，孩子们永远的失去了父亲，好好的一个家就这样没了……如果这还不能给你一丝触动的话，那么你可以去看看《卢旺达饭店》，但是要记住，千万不要用电影的结果去掩盖历史给这部电影的用意本身。因为所有试图“用战术上勤奋来掩饰战略上的懒惰”的行为都是耍流氓。 如果你说我就是没感觉呢？好吧，来看这样一句话：“白起伐赵，杀人四十万”，这句话特别普通是吧？但是如果你把它化为一个场景，你就知道它很可怕，几十万人的性命，他们也有父母，也有妻子，就没了…… 王阳明，于谦，朱元璋，朱隶，朱瞻基，朱佑樘，徐达，常遇春，陈士诚，陈友谅，蓝玉，杨善，扬廷和，扬士奇，毛人凤，袁崇焕，徐介，唐伯虎，海瑞，张居正，王振，魏忠贤，严嵩，严世蕃，胡宗宪，申时行，俞大猷，戚继光，郑和……我穿过历史看到了他们的痛苦，他们的无奈，他们的悲伤，他们的孤独，他们的挣扎，他们的追悔莫及，他们的自以为是…… 回到正题，来说说我们为什么要看历史呢？有些人说我们之所以看历史是因为要以史为鉴，其实我不赞同这句话，即便我们将《明朝那些事儿》背的滚瓜烂熟，该犯的错我们还是要犯，该吃的亏我们还是要吃。我们之所以要读历史，仅仅是穿越了时空，和那个时代的人交了一个朋友，看看他们是怎样和那个时代相结合度过自己的一生的，然后来反观我们这个时代，思考我们应该度过怎样的一生。仅此而已！ 如果你想给自己一个爱上历史的机会，如果你想穿越历史去交一些朋友和他们谈谈心，如果你想对自己的人生有一个新的认知，那就是这本书了！","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ijiangnanbei.com/tags/读书笔记/"}]},{"title":"书读多了你会变成什么样?","date":"2017-04-10T06:15:11.000Z","path":"2017/04/10/书读多了你会变成什么样/","text":"如果你读的足够多，你会获得一种超凡的经历：感受人类知识的进步。 你会发现一个问题在这本书里是这个说法，而过了几年之后有人另写了一本书，引用更有力的证据，把整个结论给改变了。有时候你会赞同这个新结论，有时候你会反对。有时候你必须从几本书的几个不同的结论中判断哪个才是最靠谱的。有时候你会觉得他们说的都不对，只有你知道正确的答案，如果你到了这个层次，那么，恭喜你…你已经可以俯视他们，评判他们之间的高下了。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ijiangnanbei.com/tags/读书笔记/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"成功如此","date":"2017-04-10T06:11:24.000Z","path":"2017/04/10/成功如此/","text":"其实成功有的时候就取决于信心，只要你特别相信一件事，然后就按照这个方向做，没准就能做成，尤其是今天的这个商业社会，每个人都有自己的一套商业理论，你只要在逻辑上自洽，都可能对，关键是你怎么做。 创业这件事，有这么一句话，我们不是判定了一个理论，然后去实践它，而是，我们先说出了一个理论，然后用创业的整个过程证明我说的是对的。所以信心这件事，本质上在成功路上就很重要。 信心不仅是我们通往成功的必由之路，它即使不成功，他可以让我们的内心充满了幸福感和安定感。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"在现有格局上,向上走一步","date":"2017-04-10T06:08:36.000Z","path":"2017/04/10/在现有格局上-向上走一步/","text":"要能权衡好本末轻重，就得有“价值意识”，也就是要搞清楚“人生中到底想要什么，追求什么”. 一个人为自己的内心树立什么样的最高目标、设定什么样的价值尺度，反映了他的“格局”。 当我们面临人生中的中中选择时，如果我们拿出一点勇气，为自己设定更高的目标，那么我们就可以发现更多更好的选项，做出更加完美的决定。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"具有心智独特性的人所具有的优势","date":"2017-04-09T14:04:22.000Z","path":"2017/04/09/具有心智独特性的人所具有的优势/","text":"1.在主流观点之外能洞察出被人未曾发现的机会. 2.形成个人核心竞争力，避免低层次的同质化竞争，使自己不可代替. 3.拒绝他人和大众给自己贴上标签，以更开放和自由的心态发展自己. 4.因为不必迎合社会主流而节约了大量的时间精力，可以专注于做好自己的事. 5.为大众带来新鲜的见解和启发，形成对公众的影响力. 6.具有更高的可辨识性，更易于形成个人品牌. 7.吸引到其他独特而优秀的人，与他们成为朋友或者合作伙伴","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"普通人和高手的区别","date":"2017-04-09T14:01:55.000Z","path":"2017/04/09/普通人和高手的区别/","text":"普通人和高手有一个很大的区别，就是视角区别。普通人只会站在自己的角度看问题，谈感受；高手会切换视角，站在别人的角度看问题，感受他们的感受，从而解决问题。 站在用户的角度看问题，能把营销在做好，产品做好；站在领导的角度问题，能了解他的需求，博取他的欢心从而升职加薪；站在异性的角度看问题，能处理好男女关系。 只可惜，大部分普通人只会站在自己的角度看问题：抱怨用户太蠢、领导太傻、女人太拜金。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"更高的标准才会有更好的选择","date":"2017-04-09T13:59:29.000Z","path":"2017/04/09/更高的标准才会有更好的选择/","text":"决策心理学认为，人在面临选择时，通常会采用“满意原则”，而不是“最优原则”。也就是说，如果找到一个满足内心标准的选项，就会采纳这个选项，余下的选项就放弃了，而不是对比所有的选项，然后选出其中最好的。因此一个人会不会做出一个尽量好的选择，更他所采纳的标准有很大的关系。 一个成熟的人，他的标准来自他的内心，而大多数人，却受环境所左右。一个年轻人，进入一所不那么优秀的学校，对自己的标准会不由自己的降低以适应这个环境，减少自身与环境的冲突，而这种做法对他们的人生也许是致命的。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"说说我眼中的巴菲特","date":"2017-04-09T13:56:10.000Z","path":"2017/04/09/说说我眼中的巴菲特/","text":"对于商业有点兴趣的朋友都应该听说过巴菲特和索罗斯,毕竟商业的最高境界也就是”资本游戏”了,先不说索罗斯,先说说巴菲特. 巴菲特被认为是世界上最成功的投资者之一,2008年他的财富超越比尔盖茨成为世界首富,刚才看了一下,现在是世界二富,4500亿软.今天我们不谈财富,就评其人. 但凡对投资有一点兴趣的大多数人一定和当年我的一样,对巴菲特所坚持的投资理念奉若神明,视他为偶像,对他的一言一行顶礼膜拜,今天我带你重新认识一下巴菲特,毕竟他曾是我的偶像.真的有股神吗?巴菲特有一句名言:”我们喜好的持有期就是永远”,这也就是他那众所周知的投资策略-“买入并长期持有”.对,这句话是他告诉所有投资者的,但是他却不是这么做的,所谓兵不厌诈,他声东击西,指南打北,出尔反尔. 2003年,他购得5亿美元的中石油股票,消息一公布,无数的股神追随者相继跟入,攥住中石油的股票死也不放.”股神”果然不负众望,”苦苦守候”了四年,等他的信徒差不多都进场了,便在2007年7月悄悄地抛售了中石油的所有股票.单单这一笔,”股神”就从中国老百姓身上掠走35亿美元.有练就绝世武功的葵花宝典,你会告诉别人吗? 再说长期持有,纵观巴菲特的整个投资生涯,他真正长线并长期持有的股票总共才7支,你不知道吧?他同时还是这7家公司的大股东,是”内线者”,你知道吗? 恩,再来说说内幕交易……算了,这个我也是略懂皮毛,不扯了. 对了,忘了告诉你,巴菲特的父亲是美国参议院议员和国会金融委员会成员. 之所以想说说巴菲特,就是我在铁杆巴粉的三年里学会了一件事,学会了质疑,学会了立体的看一个人,学会听他没有说什么.我好想再喷一喷宋鸿兵,多少好娃被他带环了.","tags":[{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"},{"name":"投资","slug":"投资","permalink":"http://ijiangnanbei.com/tags/投资/"}]},{"title":"对赌天气跨界营销","date":"2017-04-09T10:13:08.000Z","path":"2017/04/09/对赌天气跨界营销/","text":"Alan Perry是美国北卡州Wilmington一家小珠宝店的老板。 2010年冬天，他推出了一个很有趣的促销活动： 如果在感恩节之后的2个星期里，你在店里买了珠宝。圣诞节当天，假如北卡另外一个小镇Asheville（距离Wilmington500公里左右）圣诞节当天下雪超过3英寸，珠宝留着，钱全退，全退！ 这个消息一下就在附近传开了，甚至Asheville的当地居民也专门驱车500多公里来这家珠宝店买珠宝，一时间门庭若市，销售大涨！结果圣诞节当天，极少下雪的Asheville竟然下了6英寸的厚雪，小店前排满了申请全额退款的人，Alan Perry二话没说，珠宝保留，全额退款，当天退了40多万美金。 Perry失算了？要破产了？独自一个人流泪到天亮？ 错! Small pain, large gain: Perry bought a weather-based insurance policy from his longstanding insurer Global Weather Insurance. 因为这位Perry老板根据自己那段时间的销售额购买了天气保险。 这种保险方式原本是要让一些「靠天吃饭」的商家在使用的，譬如卖伞的小店主，每个月要下十五天以上的雨天才能获利，阿婆可买一份「15天以上会下雨」的保单，假如真的下雨不超过十五日，就会获赔一笔足以平摊她生意损失的费用。 这位老板充分利用这种气象保险，借助这种极富传播力的趣味活动，绕开了打折送赠品之类的老套促销手段，达到了提升销售、提升知名度的目的。 这位老板后来变本加厉，搞出了“结婚当天如果下雨婚戒免费”等活动 ，都有效地提升了销售，没有降低利润率。 对于金银首饰珠宝这种同质化竞争很强的产品，如果依赖老套的打折、赠品等方式，是很难在不降低利润率的前提下获得销售增长的，营销人的真正实力，在这种同质化竞争市场上体现得最为明显。这位Perry老板，通过对赌天气这种趣味跨界营销活动，通过保险对冲其风险，大大提升了自己店铺的知名度，最后连CNN的新闻都报道了他的促销活动（文章来源：Six inches of snow gets free jewelry for 311 lucky shoppers），免费给他做了一次广告，生意涨得一发不可收拾。 (文章来源:https://www.zhihu.com/question/20431221/answer/145301562)","tags":[{"name":"营销","slug":"营销","permalink":"http://ijiangnanbei.com/tags/营销/"}]},{"title":"前端切图简明教程","date":"2017-04-01T06:02:15.000Z","path":"2017/04/01/前端切图简明教程/","text":"工具、面板、视图为什么要切图？有些时候一些效果没办法用代码实现，或者实现了也没办法做到很好的兼容，这时可以通过引入图片资源实现。比如说：html--&gt;img，css--&gt;background。 ps 首选项设置编辑-&gt;首选项-&gt;单位与标尺-&gt; 标尺和文字都设为像素（可以保存为自己的工作区，下次直接使用）。 切图常用工具 移动工具（设置：自动选择-&gt;图层） 矩形选框工具 魔棒工具：抠出一些不规则的图形（调节‘容差’，可以消除锯齿，选取范围时让边缘光滑，容差越小，选择颜色范围越小） 裁剪工具+切片工具 取色器 辅助视图 对齐 标尺 显示-&gt;参考线（勾选了“显示额外的内容”才可以看到有哪些选项） 测量、取色要测量哪些东西？ 宽高 内外边距 边框（border） 定位（top、left） 文字大小（所有文字都要测量） 行高 背景图位置 测量时画布尽可能放大。 如何测量文字大小？ 如果文字是一个单独的图层，用文字选中工具，在选项面板里就有信息了 如果文字在背景图中则测量文字的高度，即 font-size值，尽量选择大的字测量 如何测行高？ 如果文字是单独的图层，用文字工具选中，选中面板点击“切换字符和段落面板”即可看到 如果文字在背景中，则行高为第一行的下面到第二行的下面 矩形选框 当测量整个页面的宽度时，可以在页面左右各取一块，然后看宽度 添加到选取按住 shift 从选区中剪去按 alt 与选区交叉 shift+alt 取色 边框色 背景色 文字色 所有的颜色都要取。 确定背景色是否是纯色？多点取色 确定是否是线性渐变？选中图层，用魔棒将容差调低，然后多点触控 切图哪些是需要切出的？1.修饰性的，一般用在 background 属性 图标、Logo 有特殊效果的按钮文字 非纯色背景 2.内容性的，一般用在 img 标签 Banner、广告图片 文章中的配图 切出的图片一般保存为那种类型？1.修饰性的 png8 （全透明） png24 （全透明/半透明，IE6不支持png24半透明图，需要做兼容） 2.内容性的图片一般存为 jpg 但是要压缩 切图1.若文字为独立图层，则隐藏文字图层 2.若文字和背景合并则平铺背景覆盖文字 若背景图层可拉伸：则矩形选框-&gt;自由变换（ctrl+l） 若背景不适合做拉伸：矩形选框-&gt;移动工具+alt-&gt;向右侧移动隐藏文字（按住`shift则只能在水平方向移动） 切图 png241.单个图层 2.多个图层则右键合并图层（ctrl+e） 切图 png8（带背景切）合并可见图层（shift+ctrl+e）-&gt;矩形选框工具选择内容-&gt;魔棒取出多余部分-&gt;从选区中减去，按住alt 可平铺背景的切图 用矩形选框选取一块区域，复制粘贴到新文件中，平铺内容充满文件的宽高。 切片工具适用于可以一刀切的活动页 拉参考线-&gt;选择切片工具-&gt;点击“基于参考线的切片”-&gt;切片选择工具，更改切片名称-&gt;保存，全选切片，统一设置存储格式 保存保存时背景一般选为透明的 保存类型（一）当图片色彩丰富且无透明要求时，建议保存为 jpg 格式，并选择合适的图片品质，一般 60~80 比较合适。 保存类型（二）当图片色彩不太丰富时，无论有无透明要求，请保存为 png8 格式。（扩散：无纺色） 保存类型（三）当图片有半透明要求时，保存为 png24 保存类型（四）为了保证图片质量，保留一份psd，在 psd 是进行修改（psd 可以保留图层） 修改、维护更改画布大小图像-&gt;画布大小-&gt;更改大小-&gt;定位（选在左上角） 移动图标1.若为独立图层，用移动工具拖动即可 2.若非独立图层，用选区工具选中图标区域，用移动工具拖动图标（两个图像在一个图层，若想将其中一个分开可用 ctrl + x ,然后再粘贴） 要减小画布到指定区域选择你所要的区域，然后你可以使用图像裁剪，也可以使用剪裁工具剪裁 注意事项修改 png8 的图片，需要更改颜色模式为 RGB颜色 图片的优化与合并图片优化合并1.大小与质量之间要平衡取舍，同时可以使用压缩工具。无损压缩可以使用 minimage ，有损压缩可以使用 tinypng。 2.图片之间必须留空隙，小图标一般在 20px 左右，大的图标可以大一点，保留足够的缝隙够后期维护的就可以了。 3.图片的排列方式可以选择横向排列和纵向排列。 合并-分类 把同属于一个模块的图片进行合并 大小相近的图片进行合并 色彩相近的图片进行合并 合并推荐 只本页用到的图片合并 有状态的图标合并 浏览器兼容1.IE6 不支持 png24 半透明，所以你可以给高级浏览器 sprite.png24 ，给 IE6 存一份带背景切 sprite_ie.png8。 2.高级浏览器可以用 css3 实现，低级浏览器可以用 切图+hack 来实现。或者你可以使用优雅降级，都用 css3 处理，让低级的浏览器没有这个效果，比如说圆角。","tags":[{"name":"设计","slug":"设计","permalink":"http://ijiangnanbei.com/tags/设计/"}]},{"title":"《一流人才思考习惯》","date":"2017-03-29T16:37:04.000Z","path":"2017/03/30/《一流人才思考习惯》/","text":"我们常说习惯决定命运这句话不是没有道理的，本书的作者高妻荣是一名运动教练，她用她自己多年的经历告诉你一流的运动运是如何思考的，又是如何行动的，虽然这些优秀的习惯来自于运动员，但是这种共通的“思考习惯”，对于任何领域的一流人才来说都是通用的，就算你现在不具备这种取得成就的资质，只要你改变自己的思考方式，你照样能将这种宝贵的资质据为己有。 一：每天的习惯总有自己执着的事；脸上永远不会缺乏笑容；每天都不忘记早餐；精神百倍的与人打招呼；每天都做同样的事；特别注重平衡；心智坚定无法动摇。 二：采取行动时的习惯总会想象自己成功的时候的样子；从不会忘记检查自己的计划表；总会通过反推来分析事物；总是惜时如金。三：为了将实力发挥到最佳的习惯控制自己的心态；总是执着于自己所关注事情的某一点；靠着呼吸来调节自己的情绪；保持着最挺拔的身姿；能灵活划分“紧张”和“松弛”；就算在逆境中也不轻言放弃；不会在意旁人的说法；不会过分在意成就；利用对手来让自己强大；总是能开心开始，开心结束。 四：被任务追着跑时的习惯把压力当做朋友；善于苦衷做乐；从不多想；永不消沉；不会满足于简单的反省；好胜；对成功体验有特别的执著。 五：为磨练自我而形成的习惯不会忘记初衷；善于“偷师”；在人看不见的地方偷偷地努力；拥有有别于他人的享乐方式。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ijiangnanbei.com/tags/读书笔记/"}]},{"title":"《明朝一哥王阳明》","date":"2017-03-29T16:31:29.000Z","path":"2017/03/30/《明朝一哥王阳明》/","text":"第一次知道王阳明是在当年明月的《明朝那些事》里，这是读的第二本关于王阳明的书，没有读完，知识略读了一下，感觉写的不是很好，当然如果你没有细看，第一眼看上去这屎的不能再屎的排版也会让你放弃想读的欲望。下面是一些我摘抄的句子： 1.告诉你在这个险恶的世界上年轻人的希望在哪里，修炼强大的内心，你的人生永远你有出路！ 2.龙岗山上一轮月，仰见良知千古光。 3.心即理，知行合一，致良知。 4.一切战斗都是心战，内心的强大才是正真的强大！ 5.不要被自己的情绪所左右，偏激永远是因为你看的不够多。6.待一切都安静下来，不管你站在什么立场，且只问一句话：多久没有倾听自己的内心了？其实，世界是什么样子不重要，重要而是你需要什么！ 7.所谓天理，圣人之道，全在我心中，全在我与生俱来的秉性中，为圣之道，只需向自己的内心深处去挖掘和寻找。 8心虽主乎一身，而实管天下之理，理虽散在万事，而实不外乎一人之心。 9.此心安处是我家，给漂泊的心灵找一个归宿，给活着寻找一个意义。 10.生命的价值在于她能够拒绝庸俗，能够灿烂奔放，但也可以在随波逐流中丧失任何意义，成为行尸走肉。 11.立志，勤学，改过，择善！不立志就不可能勤学，不勤学也就无法成就。为人处世不可能无过，但应有过必改。你不可能让所有人都满意，但你应该让尽量多的人满意。同时，不仅自己向善，还要帮助他人向善。但责人向善必须注意方法，是人乐于接受，否则便会适得其反。 12.幼稚的理想主义者为了理想去死，成熟的理想主义者为了理想而隐忍。 13.俗话说得好，犯贱是普遍真理，你我只是其中之一。 14.中国人的智慧是事缓则圆，一切都得慢慢来。 15.有人的地方就有变数，有变数就有机会，从而可以推导出：人越多的地方机会越多。这就是无论哪行哪业，哪朝哪代，大家都爱往京城扎堆的原因。 16.做起来，就能成，你要相信人可以凭借意志和内在的修炼成为你想成为的人！ 17.能有得力处，便是用力处。 18.沉默里也包含着三种危险：疑而不问，蔽而 不辩，这是愚蠢的沉默；用不说话讨好别人，这是狡猾的沉默；怕被人看清底细，故作高深掩盖自己的无知无能，这是自欺欺人的沉默。 19.不是你所处的环境决定了你的命运，而是你所做的决定注定了你的命运。当你制定一个目标时，整个宇宙都会让你知道接下来会发生什么。 20.判断人生价值的标准不在外部世界，不在官职高低，不在权势大小，而在你的内心。心安自足，充实强大才是安生之本，成功之基。 21.温和是顶级的暴力。 22.坚强的意志和决心可以战胜一切困难，执着的信念和无谓的心灵才是最强大的武器。 23.不用感谢我此刻的宽宏大量，所谓宽宏大量云云，皆因你目前的档次不够。 24.低调是弱者的权利，强者从来不需要掩饰。 25.招降是虚，进攻是实。要让对方绝望，必先给其希望，此所谓围师必阙。 26.在这个世界上有人想脚踏两只船，左右逢源。有人想不问是非，抽身事外。但只有立场坚定的人，才可能有所作为。 27.人可以不识字，但是不能不识相。 28.困兽是不好斗的，但只要把它放出来，就好斗了。 29.能改的叫缺点，不能改的叫弱点。 30.懂得明哲保身不难，难的是懂得什么时候挺身而出。 31.所谓敌人，不过是那些迫使自己变得强大的人。 32.请求援军就好比买保险，用不上时痛苦，用上时更痛苦。 33.心学是教会了很多人使用权术，但更重要的是，它教会了我们什么时候不用权术，这才是它之于这个历史悠久的泱泱大国的最更本的意义。 34.乱世就是舞台，演技才是王道。 35.历史的统治阶级无不是体制内给黄金，体制外给信心。 36.政治选择了思想，而不是思想改造了政治。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ijiangnanbei.com/tags/读书笔记/"}]},{"title":"《数据统治世界》","date":"2017-03-29T16:27:15.000Z","path":"2017/03/30/《数据统治世界》/","text":"《数据统治世界》已经不是我第一次读与数据有关的书籍了，但是总感觉是不得其要领，比如说呢，你没有掌握学会用数据研判趋势的能力，但是我一直在路上，希望《信息分析与决策》和《数据、模型与决策》同时加上我炉火纯青的python造诣一定能够打通研判趋势任督二脉，哈哈哈哈，想想还有点小激动呢O(∩_∩)O~~。好了，废话不多，《数据数据统治世界》开喷： 《数据统治世界》这本书告诉你怎么怎么让数据自己说话，同时他会告诉你很多生活中看似不合理的安排，其实那都是有道理滴。本书中列举了大量的与统计式思维有关的例子，从中你可以感悟到数据已经统治了我们的世界，如果你读了这本书，同时你又是生活中的一个有心人，你会惊奇地发现在日常生活中，你也能运用数据来做决定了。 全书主要分为五章，第一章：“关注异常值而非平均值”，他会告诉你为什么迪士尼不去改变让游客牢骚满腹的长队。第二章：“相关比因果更重要”，主要举了疾病侦测和信用评分的例子。第三章：“分层与同类比较”。第四章：“假阳性与假阴性的博弈”。第五章：“小概率的力量”。如果你想给自己的数据分析入门找一个落脚点，这本书是一个不错的选择，他会告诉你，我们究竟是怎么运用数据的，我们该怎么运用数据，数据与我们的生活息息相关！","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ijiangnanbei.com/tags/读书笔记/"}]},{"title":"《0.5秒决定你的人生》","date":"2017-03-29T16:23:15.000Z","path":"2017/03/30/《0-5秒决定你的人生》/","text":"我这个人很少读鸡汤文，看书名很像是吧，其实不是的，这是一本教你练习微表情的书，这本书其实就想告诉你：一个好的第一印象取决于我们的表情是否能让对方看的舒服，而非我们长的是否漂亮。心动了吧，其实稍加练习，你也可以做到。下面简要的介绍一下这本书的内容： 什么才是真正的笑容呢？书中是这样说的:眼睛要笑的弯弯的，颧骨部位要抬起来，只露出上排牙齿，左右表情对称。 发自内心的笑容能让我们产生脱胎换股的变化，拥有迷人的笑脸能让你拥有更多的机遇，一个良好的印象能够让你人生的成功率提高九成，一张让人舒心的笑脸能让你卖掉手头的商品…… 用迷人的笑脸和对方说谢谢，经常微笑能让你获得好运，微笑能在相遇的瞬间表达谢意，笑容能够播散幸福，笑容能够大大改观你的人际关系……那怎样才能获得美丽迷人的笑容呢？其实很简单，你需要的仅仅是每天对着镜子练习三分钟，看看你的眼睛有没有笑的弯弯的，你的颧骨有没有抬起来，你有没有只露出上排牙齿，你的左右表情是否对称，只要注意坚持，就能养成良好的脸部习惯。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://ijiangnanbei.com/tags/读书笔记/"}]},{"title":"学习和智商有关系吗?","date":"2017-03-29T04:51:19.000Z","path":"2017/03/29/学习和智商有关系吗/","text":"相信你们看到这个标题就知道我要说学习和智商是没有关系的,是的,注意哦,我说的是学习. 学习关键是你要知道怎么去学习,否则你只能做一个笨蛋. 作为一个非科班出身的野生程序员,从我开始到现在的自学经验告诉我,学习应该是这样的:首先,你要知道哪里有问题,然后把大问题分解成小问题,最后再一个一个地去解决,最终你肯定会搞明白所有的问题. 学习的关键就是你每天都要进步,哪怕你每天只懂了一点点.要记住:学习不是百米赛跑,学习是看不到尽头的马拉松.你每天都向前走一点,越往前走你会发现你前面的人越少,当你发现你在前面已经看不到人的时候,你就已经非常非常非常厉害了.有一点我是确信的,那就是我知道”未来会牛逼”的”笨蛋”,一定是具有成长型思维的”聪明人”! 什么是成长型思维?就是我们在做一件事的时候,不要看当下会发生什么,我们要学会走进一个长的时时间维度,跨进一个大的空间尺度,看看未来会发生什么.“三十年河东,三十年河西”,老祖宗留下来的话不是没有道理的. 说一个聪明人和一个笨蛋同时做一道题,前者用了一分钟做出来了,做出来之后他就不想这个问题了,过一段时间就忘了,他印象不一定很深刻.然而即便后者用了10分钟做出了,他为什么用来10分钟才做出来?可能的原因有两个,第一个是他真的笨,第二个就是想多. 如果这个笨蛋还是不明白,这个时他还会去一直思考这个问题,所以笨蛋第一次花了10分钟,但是第二次就只用花3分钟,第三次一分钟不到就做出来了,重点是这个问题还一直在他的脑子里,在他的心里.以后再遇到类似的问题不但可以信手拈来还能提炼升华 所以这个笨蛋最后未必见得就比聪明人学的差. 恩,其实我就是那个笨蛋O(∩_∩)O.","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"工作中的请求处理 post","date":"2017-02-22T03:49:16.000Z","path":"2017/02/22/工作中的请求处理-post/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;script type=\"text/javascript\"&gt; window.onload=function()&#123; var oBtn=document.getElementById('btn'); oBtn.onclick=function()&#123; var xhr=null; try&#123; xhr=new XMLHttpRequest(); &#125;catch(e)&#123; xhr=new ActiveXObject('Microsoft.XMHTTP'); &#125; xhr.open('post','8post.php',true); //post方式：数据放在send（）方法里面传递过去 //如果你在用post传递数据的时候不告诉当前计算机你所传递的数据的格式，计算机就不会处理你传递的 //信息。通过设置请求头告诉浏览器你所发过去的文档是什么类型。 //post没有缓存问题，post是用来提交数据的，而提交数据而不会被缓存的，当你从服务器获取的时候它就可 //能被缓存 //不存在编码问题 xhr.setRequestHeader('content-type','application/x-www-form-urlencoded'); xhr.send('username=leo&amp;age=20'); xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if(xhr.status==200)&#123; alert(xhr.responseText); &#125;else&#123; alert('出错了,Err:'+xhr.status); &#125; &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" name=\"btn\" id=\"btn\" value=\"Button\"&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://ijiangnanbei.com/tags/Ajax/"}]},{"title":"工作中的请求处理 get","date":"2017-02-20T03:47:39.000Z","path":"2017/02/20/工作中的请求处理-get/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;script type=\"text/javascript\"&gt; window.onload=function()&#123; var oBtn=document.getElementById('btn'); oBtn.onclick=function()&#123; var xhr=null; try&#123; xhr=new XMLHttpRequest(); &#125;catch(e)&#123; xhr=new ActiveXObject('Microsoft.XMHTTP'); &#125; //get方法出现的问题： // 1.缓存问题：在url？后面连接在一个随机数或者时间戳都可以 // 2.乱码：编码encodeURI xhr.open('get','6.get.php?username='+encodeURI('刘伟')+'&amp;age=30&amp;'+new Date().getTime(),true); //提交 xhr.send(); xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if(xhr.status==200)&#123; alert(xhr.responseText); &#125;else&#123; alert('出错了,Err:'+xhr.status); &#125; &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" name=\"btn\" id=\"btn\" value=\"Button\"&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://ijiangnanbei.com/tags/Ajax/"}]},{"title":"定时刷新实例","date":"2017-02-20T03:46:27.000Z","path":"2017/02/20/定时刷新实例/","text":"12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;&lt;/title&gt;&lt;script type=\"text/javascript\" src='6ajax.js'&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn'); oBtn.onclick = function() &#123; setInterval(function() &#123; ajax('get', '6getNews.php', '', function(data) &#123; // JSON 是一个对象，ie 7 以下不支持 //利用 JSON.parse 将传进来的数据转换为一个数组 var data = JSON.parse(data); var oUL = document.getElementById('ul1'); var html = ''; for (var i = 0; i &lt; data.length; i++) &#123; html += '&lt;li&gt;&lt;a href=\"\"&gt;' + data[i].title + '&lt;/a&gt; [&lt;span&gt;' + data[i].date + '&lt;/span&gt;]&lt;/li&gt;' &#125; oUL.innerHTML = html; &#125;); &#125;, 1000); &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" name=\"btn\" id=\"btn\" value=\"Button\"&gt; &lt;!-- 从后端获取新闻，然后将获取到的新闻放到ul里面，不刷新页面就可以获取到 --&gt; &lt;ul id=\"ul1\"&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://ijiangnanbei.com/tags/Ajax/"}]},{"title":"获取数据","date":"2017-02-18T03:45:11.000Z","path":"2017/02/18/获取数据/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;script type=\"text/javascript\"&gt; window.onload=function()&#123; var oBtn=document.getElementById('btn'); oBtn.onclick=function()&#123; var xhr=null; try&#123; xhr=new XMLHttpRequest(); &#125;catch(e)&#123; xhr=new ActiveXObject('Microsoft.XMHTTP'); &#125; xhr.open('get','1.txt',true); xhr.send(); //readyState属性：请求状态 //0：（初始化）还没有调用open方法 //1：（载入）一调用send方法正在发送请求 //2：（载入完成）send（）方法以完成，以收到全部响应内容 //3：（解析）正在解析相应内容 //4：（完成）响应内容解析完成，可以在客户端调用了 //onreadystatechange：当状态值 readyState 改变的时候触发 xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; //status:服务器状态，http状态码 if(xhr.status==200)&#123;// responseText 这是一个属性，ajax请求返回的数据就被放到了这个属性的下面这里面的所有数据都是字符串类型的 alert(xhr.responseText); &#125;else&#123; alert('出错了,Err:'+xhr.status); &#125; &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" name=\"btn\" id=\"btn\" value=\"Button\"&gt;&lt;/body&gt;","tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://ijiangnanbei.com/tags/Ajax/"}]},{"title":"详解表单","date":"2017-02-16T03:44:17.000Z","path":"2017/02/16/详解表单/","text":"12345678910111213141516171819&lt;body&gt; &lt;!-- 表单：数据的提交 --&gt; &lt;!-- action : 数据提交的地址，默认是当前页面 --&gt; &lt;!-- method : 数据提交的方式，默认是get方式 --&gt; &lt;!-- 1.get --&gt; &lt;!-- 把数据名称和数据值用=连接，如果有多个的话，那么他会把多个数据组合用&amp;amp; --&gt; &lt;!-- 进行连接，然后把数据放到url?后面传到指定页面，url长度限制的原因，我们 --&gt; &lt;!-- 不要通过get方式传递过多的数据 --&gt; &lt;!-- 2.post --&gt; &lt;!-- 理论上无限制 --&gt; &lt;!-- enctype : 提交的数据格式，默认application/x-www-form-urlencoded --&gt; &lt;form action=\"1.get.php\" enctype=\"application/x-www-form-urlencoded\"&gt; &lt;input type=\"text\" name=\"username\" /&gt; &lt;input type=\"text\" name=\"age\" /&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; &lt;/form&gt;&lt;/body&gt;","tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://ijiangnanbei.com/tags/Ajax/"}]},{"title":"对象的创建和兼容性处理","date":"2017-02-14T03:42:51.000Z","path":"2017/02/14/对象的创建和兼容性处理/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;script type=\"text/javascript\"&gt;window.onload=function()&#123; var oBtn=document.getElementById('btn'); oBtn.onclick=function()&#123;/*利用 XMLHttpRequest 创建一个 ajax 对象，然后利用对象的属性和方法去完成一个数据交互的流程兼容性问题：ie6 及以下不支持 XMLHttpRequest ，用的是 newActiveXObject（'Microsoft.XMHTTP')，这是ie的一个插件*/ //首先定义一个对象 var xhr=null; //第一种兼容方式，ie下的兼容：/* 在 XMLHttpRequest前面加了 'window.' 在 ie6及 以下才不会报错，这时候 XMLHttpRequest 只是 window下面的一个属性，即使不存在也不会报错，只会返回undefine，代码如下：*/ /* if(window.XMLHttpRequest)&#123; xhr=new XMLHttpRequest(); &#125;else&#123; xhr=new ActiveXObject('Microsoft.XMHTTP'); &#125; */ //第二种兼容方式，用异常处理来做兼容 try&#123;//代码尝试执行这个块里面的内容，如果有错误，则会执行 catch 里面的代码,并且传入错误信息参数 xhr=new XMLHttpRequest(); &#125;catch(e)&#123; xhr=new ActiveXObject('Microsoft.XMHTTP'); &#125; /* open方法参数: 1.打开方式 2.地址 3.是否异步 异步:非阻塞 前面的代码不会影响后面代码的执行 同步:阻塞 前面的代码会影响后面代码的执行 */ xhr.open('get','1.txt',true); //提交 xhr.send(); //等待服务器返回内容 xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; alert(xhr.responseText); &#125; &#125; &#125; &#125;&lt;/script&gt;","tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://ijiangnanbei.com/tags/Ajax/"}]},{"title":"第一个 Ajax 程序","date":"2017-02-13T03:40:40.000Z","path":"2017/02/13/第一个-Ajax-程序/","text":"123456789101112131415161718192021222324252627282930313233&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); //当我点击按钮时候，我要通过`ajax`把`1.0.tex`里面的内容获取出来 oBtn.onclick = function() &#123; //打开浏览器 var xhr = new XMLHttpRequest(); //在地址栏输入地址 xhr.open('get','1.0.txt',true); //提交 xhr.send(); //等待服务器返回内容 xhr.onreadystatechange = function() &#123; if ( xhr.readyState == 4 ) &#123; alert( xhr.responseText ); &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"按钮\" id=\"btn\" /&gt;&lt;/body&gt; 12//1.0.txthello world! 源代码&amp;源代码","tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://ijiangnanbei.com/tags/Ajax/"}]},{"title":"什么是 Ajax？","date":"2017-02-12T03:38:27.000Z","path":"2017/02/12/什么是-Ajax？/","text":"什么是 ajax？ajax : Asynchronous JavaScript and XML 异步 JavaScript 和 XML，用 javascript 异步形式去操作 xml。 ajax 是用来做什么的？ajax 要做的事情就是，从某个接口取数据，然后把取出来的数据，根据不同的特性进行不同的处理，然后再将处理后的结果进行进一步的操作，比如说反馈给用户或者进行数据分析。 使用 Ajax 可以做到只更新页面中的一小部分。至于其他内容–标志、导航、头部、脚部、都不用重新加载。只有页面中的一小部分区域会更新，而不必再次加载整个页面。 Ajax 的优势Ajax 的主要优势就是对页面请求以异步方式发送到服务器。而服务器不会用整个页面来响应请求，它会在后台处理请求，与此同时用户还能继续浏览页面并与页面交互。 你的脚本可以按需加载和创建页面内容，而不会打断用户的浏览体验。利用 Ajax ， web 应用可以呈现出功能丰富、交互敏捷、类似桌面应用般的体验，就像你使用谷歌地图时的感觉一样。","tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://ijiangnanbei.com/tags/Ajax/"}]},{"title":"献给有野心以及想创业的朋友","date":"2017-02-07T04:49:04.000Z","path":"2017/02/07/献给有野心以及向创业的朋友/","text":"1、一个年轻人，如果三年的时间里，没有任何想法，他这一生，就基本这个样子，没有多大改变了。 2、成功者就是胆识加魄力，曾经在火车上听人谈起过温州人的成功，说了这么三个字，“胆子大”。这其实，就是胆识，而拿得起，放得下，就是魄力。 3、这个世界，有这么一小撮的人，打开报纸，是他们的消息，打开电视，是他们的消息，街头巷尾，议论的是他们的消息，仿佛世界是为他们准备的，他们能够呼风唤雨，无所不能。你的目标，应该是努力成为这一小撮人。 4、如果，你真的爱你的爸妈，爱你的女朋友，就好好的去奋斗，去拼搏吧，这样，你才有能力，有经济条件，有自由时间，去陪他们，去好好爱他们。 5、这个社会，是快鱼吃慢鱼，而不是慢鱼吃快鱼。 6、这个社会，是赢家通吃，输者一无所有，社会，永远都是只以成败论英雄。 7、如果你问周围朋友词语，如果十个人，九个人说不知道，那么，这是一个机遇，如果十个人，九个人都知道了，就是一个行业。 8、任何一个行业，一个市场，都是先来的有肉吃，后来的汤都没的喝。 9、这个世界上，一流的人才，可以把三流项目做成二流或更好，但是，三流人才，会把一流项目，做的还不如三流。 10、趁着年轻，多出去走走看看。读万卷书，不如行万里路，行万里路，不如阅人无数。 11、与人交往的时候，多听少说。这就是，上帝为什么给我们一个嘴巴两个耳朵的原因。 12、日常工作之外应当多注意自身修养的提高及自身技能的培训。随着计算机技术的广泛应用，为了不被社会所淘汰，就必须加强计算机技术的培训与提高。 13、不要装大，对于装大的人，最好的办法就是，捡块砖头，悄悄跟上去，一下子从背后放倒他。 14、不要随便说脏话，这会让别人觉得你没涵养，不大愿意和你交往。即使交往，也是敷衍。因为他内心认定你素质很差。15、想要抽烟的时候，先问下周围的人可不可以，要学会尊重别人。少在女生面前耍酷抽烟，你不知道，其实她们内心很反感。 16、买衣服的时候，要自己去挑，不要让家人给你买，虽然你第一第二次买的都不怎么样，可是，你会慢慢有眼光的。 17、要想进步，就只有吸取教训，成功的经验都是歪曲的，成功了，想怎么说都可以，失败者没有发言权，可是，你可以通过他的事例反思，总结。教训，不仅要从自己身上吸取，还要从别人身上吸取。 18、学习，学习，再学习，有事没事，去书店看看书，关于管理，金融，营销，人际交往，未来趋势等这些，你能获得很多。这个社会竞争太激烈了，你不学习，就会被淘汰。中国2008底，有一百多万大学生找不到工作。竞争这么激烈，所以，一定要认识一点，大学毕业了，不是学习结束了，而是学习刚刚开始。 19、如果你不是歌手，不是画家，也不是玩行为艺术的，那么，请在平时注意你的衣着。现在这个社会，衣着能表现出你属于哪一个群体，哪一个圈子。 20、记住，平均每天看电视超过三个小时以上的，一定都是那些月收入不超过两千元的，如果你想要月收入超过两千，请不要把时间浪费在电视上。同样的道理，那些平均每天玩网络游戏或聊天超过三个小时以上的，也都是那些月收入不超过两千的。 21、因为穷人很多，并且穷人没有钱，所以，他们才会在网络上聊天抱怨，消磨时间。你有见过哪个企业老总或主管经理有事没事经常在QQ群里闲聊的？ 22、无论你以后是不是从事销售部门，都看一下关于营销的书籍。因为，生活中，你处处都是在向别人推销展示你自己。 23、平时的时候，多和你的朋友沟通交流一下，不要等到需要朋友的帮助时，才想到要和他们联系，到了社会，你才会知道，能够认识一个真正的朋友，有多难? 24、如果你想知道自己将来的年收入如何。找你最经常来往的六个朋友，把他们的年收入加起来，除以六，就差不多是你的了。这个例子，可以充分的说明一点，物以类聚。 25、不要听信身边人的话，大一不谈恋爱，好的女孩子就被别人都挑走了。想想，刚上大一就耐不住寂寞，受不住诱惑，而去谈恋爱的女孩子，值得自己去追吗？大学里，可以有一场爱情，可是，不要固执地认为，刚上大一，就必须要谈恋爱。 26、记得，要做最后出牌的人，出让别人觉得出其不意的牌，在他们以为你要输掉的时候，这样，你才能赢得牌局。 27、关于爱情，有这么一句话，没有面包，怎么跳舞？无论什么时候，你决定去好好爱一个人的时候，一定要考虑给她你能给予的最好的物质生活。 28、给自己定一个五年的目标，然后，把它分解成一年一年，半年半年的，三个月的，一个月的。这样，你才能找到自己的目标和方向。 29、无论什么时候，记住尊严这两个字，做人是要有尊严，有原则，有底线的。否则，没有人会尊重你。 30、如果，我只能送你一句忠告，那就是，这个世界上没有免费的午餐，永远不要走捷径！","tags":[{"name":"创业","slug":"创业","permalink":"http://ijiangnanbei.com/tags/创业/"}]},{"title":"从矛盾中解决市场","date":"2017-02-06T04:45:54.000Z","path":"2017/02/06/从矛盾中解决市场/","text":"一些高层建筑中，窗户容易飘雨进屋，安装雨棚却又影响建筑外观，这个矛盾让人十分烦恼。就是从这个矛盾和烦恼中，赵红宇发现了市场和商机。 赵红宇付出了许多心血：首先，雨棚必须具有安全性，可以抵御12级台风；其次，要坚固耐用，他设计的雨篷使用寿命是传统雨篷的10倍以上，比传统产品更具吸引力；第三，要使用抗紫外线的特殊材料，防止雨滴噪音，还能有效过滤紫外线，这也是传统产品缺少的优点。 防雨、减少雨滴噪音、防紫外线、安全性高、使用寿命长……从一个小小的雨棚中，赵红宇一个个地发现问题，然后一个个地解决问题。正是因为切实解决了用户的麻烦，这种雨棚得到市场认可也就不奇怪了。","tags":[{"name":"创业","slug":"创业","permalink":"http://ijiangnanbei.com/tags/创业/"}]},{"title":"令人惊艳的说话技巧","date":"2017-02-05T07:55:10.000Z","path":"2017/02/05/令人惊艳的说话技巧/","text":"读书笔记：《世说新语》 会说话的人，都要懂得创造高潮。他先在前面慢慢营造气氛，把听众一点点带进去，再在大家情绪的高潮，把最精彩的呈现。 譬如一个晚会的节目主持人要介绍下一位歌星出场，她不直接说那歌星的名字，而用娓娓道来的方法说： 有一个女孩，从小就长得很甜美，尤其歌喉，才十岁，就参加黄梅调的歌唱比赛得了第一名，十四岁出了第一张唱片；十五岁上了电视；二十一岁开始在日本走红，一九八六年创下日本的三连霸纪录，每年除夕的红白大赛都有她。她的歌声更陶醉了整个华人世界。现在就让我们以热烈的掌声欢迎这位国际巨星──邓丽君小姐。 由于主持人一步步把现场的情绪炒热，像海浪般一波波带向高潮，可以想见邓丽君三个字说出来的时候，那掌声会有多响！ 相反的，如果那主持人不懂这说话的技巧，一开始就说： “现在让我们欢迎邓丽君小姐！”效果一定差得多。就算她接下来把邓小姐再介绍一番，也会有再而衰、三而竭的感觉。甚至大家急着听邓丽君唱歌，反而会嫌主持人太啰唆，赶主持人下场呢！ 知道了这一点，就算你主持公司的同乐会甚至只是股东会、庆生会、欢送会，都要学习这种一步步炒热场子的效果。譬如你可以说：”有个人怎么看怎么没情调，但是怎么挑也挑不出他毛病，平时他虽然不太说话，但是有他在，大家就觉得踏实。因为他老实、敦厚、沉稳，我们过去有多少大风大浪，也都因为有他，而平平安安地过来了。今天，他要走，我们怎么能舍得？怎么能不掉眼泪，让我们以热烈的掌声，欢迎将退休的老张、张老师，再给大家一次精彩的讲话。” 接着掌声雷动，老张出场，那气氛多好！多感性啊！老张又会多感动，觉得多有面子啊！因为这一番话，把平凡的老张硬是说得不平凡。 有一个人，命好像很苦，四个孩子，早死了三个；二十一岁经商失败，二十二岁竞选州议员又失败；二十六岁失恋，二十七岁精神崩溃；三十四岁竞选众议员，又败；再选，还败。四十五岁改选参议员，又没选上。直到五十二岁，他终于成功了。你们猜，他是谁？ 他是美国的第十六任总统──亚柏拉罕·林肯。 精彩吧！一点一点把你的心带上去，用一连串的失败，到最后对比出林肯的成功！ 这就是说话的艺术。","tags":[{"name":"貌似有知识","slug":"貌似有知识","permalink":"http://ijiangnanbei.com/tags/貌似有知识/"}]},{"title":"如何在生活中发现商机，自己创业？","date":"2017-02-05T04:42:50.000Z","path":"2017/02/05/如何在生活中发现商机，自己创业？/","text":"笼统说一句，基本上，绝大部分的抱怨，都是商机。 创业分两种：一种是技术型创业，一种是需求型创业。 需求离不开人，离不开衣、食、住、行（请把这四个字无极限的展开，仅“行”就涉及到交通，物流等方面）。最显著的需求型创业如陌陌，满足了大众什么需求我就不说了。 至于创业者需要做的，就是观察人，事。 从人的衣食住行日常生活中，找到创业者可以改进的地方，提供更好的服务，提供新型的商品或创造新的商业模式。（后者太难，网上太多文章是吹牛的，没几个能开创新的商业模式，商业模式的革新往往是商业世界的革命，如google ad，如itunes） 观察不同阶层不同人的需求，提供针对不同消费者的不同服务。这也是大多数底层创业者无法做富人生意的原因，不了解富人阶层的生活习惯。 例子太多，比比皆是。随便找找身边创业成功的例子都会明白，无非是通过观察人，思考人，找到其中人的需求，满足这种需求。 乔大神这种创造他人需求的不聊了，对绝大部分人来说既没有其资源能力，更没有其段位。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"},{"name":"创业","slug":"创业","permalink":"http://ijiangnanbei.com/tags/创业/"}]},{"title":"给人好印象的接电话技巧","date":"2017-02-04T07:59:54.000Z","path":"2017/02/04/给人好印象的接电话技巧/","text":"读书笔记：《世说新语》 人很聪明，每个人都会用各种资讯来组合，譬如你认识个新朋友，留他家的地址，他说住在某高级地区大厦的四十楼。 你心里很可能就浮现他家的画面，猜他家很富有。 又譬如，你打电话给朋友，发现那边非常吵，你会一边讲电话，一边猜：是宴会？电视？地铁车站？还是夜总会的嘈杂声？ 好！不谈这么多，讲个最简单的–如果你拨电话，铃还没响，对方就接了，你是不是可能问他：”您在等谁的电话吗？” 所以别以为打电话是”只有一线牵”，其实在还没说”喂”之前，可能已经传达了一些消息。 先从”电话铃几乎没响，就接电话”这件事来说吧！ 如果才响半声就接，人家以为你正急着等别人的电话。如果响一声就接，表示你一定不忙。如果响了三声再接，对方八成猜你在忙，或是由别的地方赶过来接。 第一印象真是太重要了。相信大家一定有过这样的经验──你打电话去某某公司或某单位，那接线小姐的声音既甜美又有礼貌，让你听着就舒服。相反的，如果你打电话，接电话的声音懒洋洋、一副不耐烦的样子，你是不是先有不悦。如果那是个大公司，你会不会想：”这个公司是不是太老化、太老大了。”如果那是某人的秘书，你是不是会想：”这长官为什么会用那么差的秘书？会不会物以类聚，长官更差！” 所以你要知道，有些公司会把最漂亮，甚至学历非常高，外文好极了的人，安排在门口的柜台。 我甚至发现有个朋友，经常把他的特别助理放在公司的接待处。那朋友说得很妙，他说：”你知道我的特别助理唬了多少客户吗？尤其是海外来的，进门到柜台，说英语，当别家公司的人吓得不知如何应付。我那特别助理，英文棒极了！对答如流，带着客户往里走，还一路以英语介绍。有时候外国客户好奇，问她外语为什么那样好，我助理说她是国外名校研究所的。” 那外国客户一听！天哪！名校的硕士，居然坐在门口当接待，可见这家公司水准有多高。立刻就对我公司刮目相看了！结果，还没见面，生意先做成了一半！ 听我举了这么多例子，你说，接电话重不重要？如果你是大老板，该不该好好想想，你用的人够不够好？如果你正是负责接线或接待的，你是不是该检讨一下，自己并没有代表公司，给人美好的第一印象？","tags":[{"name":"貌似有知识","slug":"貌似有知识","permalink":"http://ijiangnanbei.com/tags/貌似有知识/"}]},{"title":"问题就是你的机会","date":"2017-02-04T04:37:22.000Z","path":"2017/02/04/问题就是你的机会/","text":"1、公司的问题：就是你改善的机会； 2、客户的问题：就是你提供服务的机会； 3、自己的问题：就是你成长的机会； 4、同事的问题：就是你提供支持建立合作机会； 5、领导的问题：就是你积极解决获得信任的机会； 6、竞争对手的问题：就是你变强的机会。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"},{"name":"创业","slug":"创业","permalink":"http://ijiangnanbei.com/tags/创业/"}]},{"title":"任何能赚钱的方法都是利用了信息不对称","date":"2017-02-03T04:34:30.000Z","path":"2017/02/03/任何赚钱的方法都是利用了信息不对称/","text":"任何能赚钱的方法都是利用了信息不对称。而不对称的信息往往都是细节信息。想要挣钱就得有细节信息的交换。然而你连交换的资本都没有，你还想获得信息，这不是扯淡么？ 那你会问怎么获得这样的资本。这里有我总结的几个途径： 1.拿钱直接买信息。例如购买商业间谍的信息，例如花钱买别人的研究数据，例如你爸是人家想笼络的李刚… 2.拿时间直接换。例如新手天天在厨房混，混个一年半载学一些技能技巧没问题；又例如你天天去逛商场，把人家商品的价格的设定原因、摆放位置的道理、进货渠道的联系方式之类的关键信息抓住了，自己开个小商店也没问题。 3.拿身体换。就不举例子了。 绝大多数人会选择前两个方式。另外，读书在第二类。","tags":[{"name":"商业技巧","slug":"商业技巧","permalink":"http://ijiangnanbei.com/tags/商业技巧/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"说话的顺序","date":"2017-02-02T07:50:04.000Z","path":"2017/02/02/说话的顺序/","text":"读书笔记：《世说新语》 一位老板，下午去开会，才回公司，就见一个职员匆匆忙忙跑来：”不得了啦！不得了啦！我们的东西出问题了，因为手续少办一项，被押在海关上不了飞机。” 老板听到这儿，因为血压高，差点晕倒。 哪知道那职员继续说：”幸亏我跑去，托关系，把手续补办好，东西及时上了飞机，现在应该已经到了。 你说他可恨不可恨？如果你有这样的员工，或自己不懂说话的优先顺序，一定要改，免得造成很大的困扰。 记得我女儿上初中的时候，有一天电话响，我接起来，是女儿校长打来的。那校长没说她是校长，居然先说”没有急事！”然后讲：”我是某校长，只是要告诉你个好消息，你的女儿得奖了。” 她为什么不说：”我是校长，我要告诉你一件事，你的女儿在学校如何如何……” 因为她怕我着急，怕我吓一跳，以为孩子在学校出了事。 说话最重要的是要把握重点。对于需要引人入胜的题材，譬如形容你去旅游的经过，你可以按部就班、娓娓道来，但是对于急迫的事，则要开门见山。知道了这一点，你开会或演讲的时候可以先说你要谈什么主题，甚至告诉大家，你要分成几点来讲。因为如果你不先说，又在演讲的时候分成第一点、第二点、第三点，大家可能一边听，一边偷偷着急，怕你说上十几点。搞不好，你才讲第三点，已经有人看手表了。你甚至在打电话的时候，可以先说明会讲多久。 举个例子，你下午五点钟打电话，对方可能正要下班，不打算跟你谈，但是当你说只占用他三分钟时间的，他就同意了。结果你的竞争者隔天才能谈，你卻前一天已经把事情办妥。而且当你这样作的时候，会给人精确、有效率，并且为人考虑的好印象。","tags":[{"name":"貌似有知识","slug":"貌似有知识","permalink":"http://ijiangnanbei.com/tags/貌似有知识/"}]},{"title":"实话虚说","date":"2017-02-01T07:43:54.000Z","path":"2017/02/01/实话虚说/","text":"读书笔记：《世说新语》 虚说的实话，基本上还是实话，只是说得不够精确，或者说得松散。 有朋友突然造访，十二点半，正是吃中饭的时候。你问他吃了没有，他不直说，卻绕弯子：”我今天其实起得很早，也不知为什么，瞎忙，又接到一个电话，瞎扯了半天，突然想到有个东西早该交给你，匆匆忙忙赶过来，说实话，我连早饭都没吃，可饿死了！” 他何不直接说他没吃呢？八成因为客气，扯了一堆。 如果你说话有这种毛病，一定要检讨，因为实话虚说的人，非但不干脆，而且容易显得不诚恳。 譬如你问你的部属，前天交代他的报告作好没有？ 他不直接答，先说：”哎呀！报告长官，我最近是真倒楣，前天半夜下大雨，房子居然漏了，东边接水，西边接水，整夜没睡，昨天办公室又忙……” 他是不是才说三句，你已经猜到他没做好。问题是听他这么说，你特别火大。 因为他在答话之前，先找了一堆借口。 你注意，很多心里有鬼的人，都爱用这种说话的方法。 但是”实话虚说”也不是完全没用。很多人就用这种方法，既没有撒谎，说了实话，又能避免尴尬。 譬如有一位台湾政界的名人，为了选举拉票，不得不上一个很搞笑的电视节目，那主持人真够刁的，她居然问：”您都穿什么颜色的內裤啊？” 那位名人反应还真不错，一笑，说：”我都穿我太太知道的颜色。”最有意思的是三十多年前，当梁实秋跟他后来的太太韩菁清热恋，梁先生夜里回台北，我去机场采访他，问他什么时候结婚。 梁实秋抬头看看天，笑说：”总得等天亮了吧！” 要知道，人都很聪明，听对方这么一说，知道他不愿意答，往往就不继续问了。结果，答的人没撒谎，说的是实话，却又等于没答。 实话虚说最好的就是你能不撒谎。 我记得当我二十几岁的时候，听一个画廊老板说过一段话，印象十分深刻。 那老板说：”人何必撒谎呢？我虽然作生意，但我不撒谎，当人家问我往哪个方向去的时候，我不愿意告诉他我去西边，我可以说我没去北边，也没去南边。” 同样的道理，当你乔迁，大家来贺，有人居然问：”您这房子真不错，多少钱买的啊？” 他问得很唐突，你原来想说：”对不起！不能告诉你。”但是又怕让他尴尬。 于是你可以换个方法说：”哎呀！这房子虽然称不上豪宅，但比我上一栋贵多了。” 你上一栋如果值一百万，这栋花了一百五十万、两百万，甚至三百万，你不是都能这么说吗？ 再不然，如果那房子是一百五十万，你可以讲：”可花了一百多万呢！”或是说：”还好！不到两百万。” 相反的，如果你不懂这个技巧，又装阔，吹牛说一百九十万。偏偏前面有人问，你的另一半才说一百六十万。不是马上就穿帮，显示你们两口子说话不实在吗？ 实话虚说还有个特色，是你可以把”语气”或”语法”掉换一下，內容没改，感觉改了。 譬如老李、老张冲突，他们都是你朋友，也都找你抱怨是对方的错。 老李对你说：”老张应该向我道歉。” 你搞不清楚情況，又不愿意偏袒任何一方，你可以附和他的话说：”如果老张有错，当然应该道歉！” 老张又来对你说：”我绝不向老李道歉。” 你还是可以顺着他的话说：”没错的人当然不必道歉。” 乍听，你两边都没得罪，而且说得理直气壮，一副仗义直言的样子，但仔细想想：”有错当然该道歉”，或”没错当然不必道歉”。你只是说了实实在在、公公正正的话。这就是”实话虚说”的妙处。 还有一种方法，是用比喻。譬如去年台湾某杂志访问一位大陆著名的企业家，问了个很辣的问题：”请问您觉得两岸的大学，哪边比较强。” 这位企业家说：”台湾的大学在理工科很强，举例说，把台湾理工大学的任何一位教授放到大陆的一流大学，表现都会非常傑出” 他虽然没有正面答，但是听的人不太会觉得。这种实话虚答，你说高不高明？","tags":[{"name":"貌似有知识","slug":"貌似有知识","permalink":"http://ijiangnanbei.com/tags/貌似有知识/"}]},{"title":"考察市场八种另类方法","date":"2017-02-01T03:53:32.000Z","path":"2017/02/01/考察市场八种另类方法/","text":"如何准确调查市场需求一直是困扰中小投资者的难题之一。主要原因是教科书中的方法过于深奥和复杂。同时完成调查任务要花费大量的人力和物力，这是中小投资者无法承担的。以下一些被许多人不屑一提的方法却能让投资者取得意想不到的效果。 方法一：样板市场模拟法案例：长沙的马女士在2009年初看中了一个饰品类的项目。她从公司进了一小批货，然后到样板市场——苏州进行模拟实验。具体做法是，马女士先选择一家样板店附近且规格相近的饰品店，然后与店主协商，让对方代销产品。为了保证试验成功，马女士与商家签订协议，在代销过程中，补贴店家一定的费用。 结果：经过一个月的模拟实验，马女士发现店家代销的产品一件也没有卖出去。她认为该产品没有市场。2009年5月初，该项目宣告破产。 提示：该方法对于新奇特产品的市场验证有一定的效果，但是存在两个缺陷：一是，消耗精力大，既要寻找合作伙伴，又要考察样板市场;二是，前期投入较大。建议有一定经济实力的投资者选用此方法。同时投资者为了保证实验成功，一定要与合作者签订相关文字协议。 适用领域：饰品类、服饰类、保健类、食品类、新奇特电子产品类的加盟项目。 方法二：试销法案例：鞍山的李先生欲投资一款儿童玩具。为了验证产品的市场需求，他从厂家进了200件产品，并且在公园、游乐场、学校附近等不同的地点，进行不同价格的试销。 结果：经过试销，李先生发现这种玩具在鞍山颇受6~12岁儿童的欢迎，而且公园和游乐园是最佳试销地点。现在李先生均能销售近1500套玩具/月，月盈利超过4万元。 提示：试销时，投资者要量力而行，资金投入额度不能过大，一般投资者试销时的投入约是后期投入的三分之一，即项目总投资额约6万元时，试销时的投资额不能超过2万元。 适用领域：代理经销电子类、家居类、玩具类产品。 方法三：查看垃圾法案例：北京的何先生在某加盟展上看中了一个烤鱼项目。他为了考证该菜品是否有市场需求，在样板店的后门蹲了三天。他每天的工作就是查看样板店扔掉的垃圾。通过扔掉的鱼头、鱼骨等垃圾统计，哪种鱼点菜率高，多大的鱼受欢迎。 结果：何先生的餐馆开业一直都顾客盈门。不到一年的时间，不仅收回了前期50万元的投资，还赚取了近40万元的纯利润。 提示：这个方法要求投资者必须有丰富的相关从业经验。如何先生必须要熟悉各地鱼的特征，否则他看到鱼头或者鱼刺，也辨别不出来。 适用领域：餐饮类项目、生产加工类项目。 方法四：“潜伏”法案例：河南驻马店的李小姐想投资一个净水站，但是她不清楚市场需求究竟如何。于是她选择了“潜伏”法，主动到该公司应聘河南省业务员。并且进入公司第一天，就主动申请开拓市场。虽然“实习”中，她的业绩不是最好的，但却是最勤奋的一个。 结果：近5个月的“潜伏”，李小姐终于摸清了该项目的瓶颈——只适合经济发达的地区或是省会城市。于是，她将投资地点驻马店改成了郑州。现在她每月可以净赚3万元。 提示：投资者“潜伏”期间要积极主动，凡事都要主动学习、主动咨询，只有这样才能在最短的时间把项目的优缺点、市场存在的各种潜在问题弄清楚。同时投资者在“潜伏”期间，也能了解到一些公司运作的“秘密”，能有效避免投资陷阱。另外该方法耗时长，不适合短平快项目的考察。 适用领域：各种招商、加盟类项目(时尚类、餐饮类项目除外)。 方法五：考察产品上下游法案例：深圳的刘小姐对某建材类项目十分感兴趣。除了进行市场调研以外，她还专门跑到该生产商的上游企业——某原材料生产企业A进行调查。并通过与A 企业合作的物流公司了解到，该生产商每月都要从A企业购进大量的原材料。这在一定程度上说明该建材不滞销，刘小姐判定该项目有市场需求。 结果：现在刘小姐是该建材项目在深圳的总代理，年利润在百万元以上。 提示：该方法与查看垃圾法有异曲同工之处，其适合具有丰富从业背景的人使用。同时该方法最好与其他方法共同使用，效果会更理想。 适用领域：各种加盟类、招商类项目(时尚类、餐饮类项目除外)。 方法六：政策法规调研法案例：济南的王先生从某广告中看到了一个环保建材类项目。实地考察的结果让他十分满意。由于这个项目太完美了，王先生有些不放心，便向有关部门进行相关政策咨询。 结果：结果让王先生大失所望，原来各个地方对该项目支持力度不一样，有的地方还限制该项目的发展。济南地区虽然不限制，但是也不鼓励。最终王先生放弃该项目。 提示：该方法存在一个不足，很多项目都是新兴的，相关管理部门也无法及时出台相关的政策法规。建议投资者遇到政策不明时，暂缓投资。 适用领域：各类环保类项目、国家政策扶持的农林牧渔项目、特种养殖项目。 方法七：蹲点+问卷调查法案例：保定的梁先生想经销广东省某公司的家具用品。他跑到了石家庄某大型超市进行蹲点调查。后来，他发现光蹲点观察，效果不明显。他又请大学同学设计了一个简单的调查问卷。他“冒充”公司派来的调查员进行调查。主要调查消费者对产品功能、价格、包装以及与同类产品的看法。 结果：经过调查，梁先生认为该产品没有市场。事实上，梁先生的决策是正确的。因为梁先生放弃投资的第四个月，那家公司就倒闭了。 提示：该方法操作起来有一定难度，因为市场问卷调查的设计十分复杂，须由专业人士设计。同时投资者的蹲点和调查，会影响顾客的购买行为，很可能会引起商场、超市等零售终端的不满。做好“秘密”工作是这个方法成功的关键。 适用领域：家居用品、新奇特电子类招商项目。 方法八：虚张声势法案例：武汉的陈先生了解到，某系列的汽车养护产品性能不错。厂家宣称该产品市场前景广阔，但是陈先生觉得光听厂方介绍不可靠。他灵机一动，在“五一”前，突然致电厂家，告诉对方自己要大量进货，如果可以进货就合作。陈先生的目的是为了考察产品是否真的畅销。如果对方可以大量供货，说明产品不畅销，因为厂家有大量存货。 结果：陈先生现在成为厂家在湖北的代理商。原因很简单，对方无法及时向陈先生提供大量的现货。 提示：实用该方法需要注意以下事项：一是，投资者考察对象必须是生产企业，否则方法无效;二是，一定要在产品销售旺季时使用该方法;三是，在得到准确结论前，一定不要和厂家签订任何书面合同，否则会让自己陷入被动。 适用领域：各类招商代理类项目。","tags":[{"name":"商业技巧","slug":"商业技巧","permalink":"http://ijiangnanbei.com/tags/商业技巧/"}]},{"title":"实话实说 谁要你多那一句嘴","date":"2017-01-30T07:36:35.000Z","path":"2017/01/30/实话实说-谁要你多那一句嘴/","text":"读书笔记：《世说新语》 常常下面人多半句嘴，能整垮一整个公司。 不信我说个故事── 我有个朋友跟他合作厂商的负责人约好了吃饭。我的朋友先到，等了半天，另一人还没到。朋友就打电话去那人公司问，是员工接的，说看到老板匆匆忙忙赶到工厂去了。 我朋友心想：约吃饭的时间到了，除非有急事，不可能跑去工厂，会不会是为我生产的工厂啊？ 生意人，多敏感！立刻拨电话去工厂，问某某老板是不是在那儿。 工厂老板也笨，居然答：”他刚走，问题已经解決了。” 就这么几句话，我那朋友硬是挖出了內幕，知道工厂做的东西出了问题。虽然能补救，毕竟有过毛病，于是狠狠扣了一笔钱。 请问，这下面人一句话，是不是捅了大楼子？ 再举个很普通，却可能造成尴尬的例子。 你打电话给朋友，手机不通，拨去办公室，秘书说他去打高尔夫球了。你再拨手机，总算通了。于是你问他能不能碰面。对方回答：”对不起耶！我整个下午都开会。” 如果你当场拆穿，说：”您是开会吗？在高尔夫球场开会？”他尴不尴尬？如果你很有城府，不吭气，是不是更糟糕？因为你发现对方会撒谎，不老实，搞不好，原先你要找他合作，就因此放弃了。 结果，他吃了亏、失去了合作的机会，卻到头来完全不知道原因。 原因是什么？是他公司的人多嘴啊！说老板不在就成了，何必讲他去打球。 当然也怪老板自己，他说没空就成了，何必撒谎说正在开会。 知道了这一点，当有电话找你办公室的人，不在就是不在，除非绝对必要，千万别主动说那人去哪里了。 如果有人找你出去，你可以说不方便、没空，尽量不要编谎言。话说回来，除非找你的人是你长官，你没空就是没空，何必向他交代你的行程？当你对同一辈的朋友报告自己行程的时候，常常在气势上先输三分。 尤其今天这个时代，大家都有手机，如果你作主管，除非有原因，不需要在出门前对职员说你到哪儿去了，只要告诉他们有事打手机就成了。 问题是，有些人明明是大老板，却每次出门都好像小孩儿，向妈妈报告似的，一一告诉自己秘书，我先到哪儿，再到哪儿，搞不好还要秘书帮忙撒谎：”如果我老婆来电话，就说我去哪里了，就说我手机没电了……” 你这老板只要这么做，必定先矮一截，好像秘书成为你的上司，而且他知道了你的行踪，也就多一分说错话的可能性。 最后我要叮嘱： 今天这个时代，连家人、孩子都应该懂。就是当有人打电话来，爸爸妈妈不在就是不在，不必告诉对方，我爸爸去公司加班、妈妈出去打麻将这些细节。 切记！切记！小孩多说一句话，很可能害了父母，甚至害了自己、害了家！","tags":[{"name":"貌似有知识","slug":"貌似有知识","permalink":"http://ijiangnanbei.com/tags/貌似有知识/"}]},{"title":"帮老板档电话的技巧","date":"2017-01-27T23:44:43.000Z","path":"2017/01/28/帮老板档电话的技巧/","text":"读书笔记：《貌似有知识》 叮铃，电话响了，秘书接起来：”凤凰公司，请问您是哪一位？” “我是老张啊！” “张先生，我老板不在！” 碰上当天老张情绪不好，搞不好会说：”他真的不在吗？还是因为听说是我，就说他不在？” 相反的，如果那秘书把说话顺序换成：叮铃，电话响，接起来：”凤凰公司，请问您找哪一位？……真对不起！他不在耶！请问您是（我是老张）喔！是张总啊！我是不是留下您的电话，我老板回来好跟您连络？” 因为这秘书还没问对方名字，先说老板不在，对方就比较不会多心了。 还有一个技巧，是如果你老板在旁边，或不远的地方，当对方说”我是老张！”你可以立刻大声重复一遍：”喔！张总经理啊！” 而且一边说一边看你老板，老板如果立刻点头、伸手，意思是接。你就马上改口，说：”啊！张总，真巧，我老板正好进门，您稍等啊！” 跟着，老板把电话接起来：”喂！老张啊！” 请问那老张会怎么想？他可能早猜到接电话的副手原先是为老板挡电话，只怕他还会高兴呢：”因为显然你重视我，所以挡别人，却不挡我老张。”搞得好，原来作不成的生意还作成了。 所以，以后如果你为人挡电话，最好不要在问清楚对方是谁之后，才说老板不在。而要”先说”不在。 问题是有些人很有电话礼貌，他打电话会先报自己名字：”喂！某某公司吗？我是老张，请问王总在不在？”这时候，你又要用另一种方式答了。譬如：”对不起！他正在开会！能不能留下您的电话，等会完打回去给您。”再不然你说：”对不起！他现在不太方便接听电话，能不能让我留下您的电话……”。 还有个办法是：”对不起！他不在位子上，我帮您看看，对不起！您稍等啊！” 以上每种办法，都可以让你有时间去偷偷问你老板：”是某某人打来的，接不接？” 而且，最重要的是，你没有撒什么谎，就算对方接着就进来了，也没问题。 说到这儿，我要问各位，如果你家里有答录机，你录的是：”对不起，我不在家。”还是”对不起，我现在不能接听您的电话。” 常常你都是在家，只是不想接，你有必要叫你的机器也撒谎，说你不在家吗？就说”你不方便接听”或”你不能接”，不是既没撒谎，又达到同样效果了吗？","tags":[{"name":"貌似有知识","slug":"貌似有知识","permalink":"http://ijiangnanbei.com/tags/貌似有知识/"}]},{"title":"不要喧宾夺主","date":"2017-01-25T23:35:06.000Z","path":"2017/01/26/不要喧宾夺主/","text":"读书笔记：《世说新语》 聪明人尤其要避免爱出锋头和快人快语的毛病，有时候为了把光芒让给人，聪明人甚至得大智若愚，装笨！ 举个例子吧,某夫妻都是某大学电机系毕业的，太太在私人公司任职，丈夫在公家机构工作。有一天，丈夫陪他的主管到太太的公司参观，只见那主管一个劲地装內行，发表一知半解的高论，有时候真不懂了，才回头问下属。我那同学的丈夫明明应该都懂，却要想半天，才答出一点。 当天晚上，丈夫才进门，太太就火了，说：我原本以为今天碰上你的老本行，你会好好表现一番，让我在同事前很有面子，可你是怎么搞的？你脑袋坏了？把以前学的忘了？还是怯场？ 那丈夫一笑，说：”我只是聪明。因为老板自认为是行家，我不能多表现”。果然，没过多久，那老板另有高就，推荐了她的丈夫的丈夫。又隔不久，那丈夫再到他太太的公司参观，就突然变成十足的专家了。 要知道，这世界上有多少副手，比那正手强得多，只是懂得让一步，让他的长官去表现，直到最关键的时候才出手。我们常说”不是不报，时候未到”，在这儿可以改成”不是不秀，时候未到”。各位初入社会的朋友千万要懂得这一点。 或许有人说这些都跟我无关，我只是小女生、家庭主妇。那么让我再讲几个最最平常的例子。 如果你是美女，你最要好的姊妹淘要结婚，你是伴娘的第一人选。她来请你，你接不接？接，你可能太美丽、艳光盖了她，哪个新娘子会希望自己变成配角呢？ 不接，你又不够朋友。这时候就看你了，妳可以先注意观察那新娘子是基于礼貌而先请你，还是非你不可。 第二，如果你当伴娘，千万别挑太过照眼的礼服，让新娘穿得特华丽，你又穿得很保守，你这样作，新娘一定会点滴在心。 甚至在吃饭和开会的时候，你都得弄清楚主角。一定要让那当天的主客坐上位，把谈话的焦点放到主人和主客的身上。 至于开会的时候，你如果有不少好点子，不要全说是自己想的，也要照顾一下别人。譬如你可以说由于某某同事有天提到什么，使我想到可以如何如何，这都多亏他的提醒。你也可以把你前面发言的人的话带进来，附和几句，别把锋头一个人出尽了。你要想想，只得到一个长官的赞赏，却失去下面一堆同事，值不值？ 聪明人常作不聪明的事，别人十目看不了一行，聪明人一目十行；别人还猜呢！聪明人早看懂了，就好像有些天才学生，考卷才发下来不久，别人还在头痛的时候，他已经把卷子写完，大摇大摆出去了。搞不好还在外面吹口哨！你说这种人是不是容易遭同学忌？ 所以郑板桥说”聪明难、糊涂难，由聪明转入糊涂更难。”愈是聪明愈要懂得韬光养晦。愈是一脸聪明像的人，愈要懂得怎么遮掩自己的聪明，免得别人由妒生恨。","tags":[{"name":"貌似有知识","slug":"貌似有知识","permalink":"http://ijiangnanbei.com/tags/貌似有知识/"}]},{"title":"jQuery 初级总结","date":"2017-01-25T09:48:37.000Z","path":"2017/01/25/jQuery-初级总结/","text":"1.$(&#39;li.box&#39;) = $(&#39;li&#39;).filter(&#39;.box&#39;) 2.$(&#39;li&#39;).html();当一组元素的时候取的是第一个；$(&#39;li&#39;).html(&#39;hello&#39;);当一组元素的时候，给所有的元素赋值 3.innerWidth()=width+paddingouterWidth()=width+padding+border outerWidth(true)=width+padding+border+margin 4.赋值 css(&#39;width&#39;,&#39;200px&#39;);；取值 css(&#39;width&#39;) 5.可以编写多个事件，同时对应一个操作1$('ele').on('click mouseover',function()&#123;&#125;); 6.使用 json 编写不同的事件对应不同的操作12345$('ele').on(&#123; 'click' : function()&#123;&#125;, 'mouseover' : function()&#123;&#125;, 'mouseout' : function()&#123;&#125;&#125;); 7.使用 off() 阻止事件1234$('ele').on('click mouseover',function()&#123; $('ele').off('mouseover');&#125;);//会阻止 moseover 事件，但不会阻止 click 事件 8.scrollTop 滚动距离12345$(function()&#123; $document.click(function()&#123; alert($(window).scrollTop()); &#125;)&#125;) 9.阻止默认事件：ev.preventDefault();阻止冒泡事件：ev.preventPropagation();阻止默认事件+冒泡事件：return false; 10.one() 事件只执行一次1$('ele').one('click',function()&#123;&#125;); 11.获取到屏幕左的距离：offset().left获取到屏幕上的距离：offset().top 12.position().left; 到有定位的父级的 left 值（不包括 margin，同样只有 left 和 top）。 13.parent() 获取父级offsetparent() 获取有定位的父级 14.size() 获取长度 15.each()123$('li').each(function(i, elem)&#123; $(elem).html(i);&#125;) 16.下列函数都可以加上时间参数show() hide() fadeIn() fadeOut() slideDown() slideUp() fadeTo(时间，透明度值)","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://ijiangnanbei.com/tags/jQuery/"}]},{"title":"把光芒留给别人","date":"2017-01-24T23:31:46.000Z","path":"2017/01/25/把光芒留给别人/","text":"读书笔记：《世说新语》 要知道，这世界上不知有多少人，甚至已经入社会很久的老鸟，还不懂得怎么把光芒留给别人，结果他明明是去捧场、去帮忙，甚至去牺牲奉献，到头来卻得罪人，甚至掉了脑袋。 确实掉了脑袋唷！妳知道以前将军在前線打仗，眼看要攻下敌人的城池，听说皇帝要亲自出征，就非得停下攻击，等皇帝来吗？ 这一停可能让濒临瓦解的敌营喘口气，因此变得难攻许多，甚至得因此多死不少兄弟。将军为什么不一鼓作气，把城攻下，再等皇帝驾临，给皇帝一个惊喜呢？ 错了！各位要想想，皇帝明明知道马上攻下了，他为什么还要御驾亲征，他是要来抢头香，显示他是英主啊！你这将军不等皇上驾到，自己先攻了，不是抢功，抢主子的功吗？ 这也叫功高震主，你能不丟官、坐冷板凳，搞不好被砍头吗？","tags":[{"name":"貌似有知识","slug":"貌似有知识","permalink":"http://ijiangnanbei.com/tags/貌似有知识/"}]},{"title":"CSS一侧固定一侧自适应布局","date":"2017-01-22T01:43:06.000Z","path":"2017/01/22/CSS一侧固定一侧自适应布局/","text":"页面布局如下： 12&lt;div id=\"lt\"&gt;left&lt;/div&gt;&lt;div id=\"rt\"&gt;right&lt;/div&gt; 左边固定 右边自适应1.左边左浮动，右边加个overflow:hidden;12#lt&#123; float: left;width:200px; background: #ff0;&#125;#rt&#123; overflow: hidden; background: #f0f;&#125; 2.左边左浮动，右边加个margin-left;12#lt&#123; float: left; width:200px; background: #ff0;&#125;#rt&#123; margin-left: 200px; background: #f0f;&#125; 3.左边绝对定位，右边加个margin-left;12#lt&#123; position: absolute; top:0; left:0; width:200px; background: #ff0;&#125;#rt&#123; margin-left: 200px; background: #f0f;&#125; 左右两边绝对定位，右边加个width,top,left,right12#lt&#123; position: absolute; top:0 ; left:0 ;width:200px; background: #ff0;&#125;#rt&#123; position: absolute; top:0 ; left:200px; width: 100% ; rigth:0;background: #f0f;&#125;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://ijiangnanbei.com/tags/CSS/"}]},{"title":"前端面试 CSS 篇","date":"2017-01-21T14:43:51.000Z","path":"2017/01/21/前端面试-CSS-篇/","text":"为div设置的背景色默认会延伸到哪里?The background of an element is the total size of the element, including padding and border (but not the margin). height:100% 和 height:auto 的区别height:auto;根据内容自动调节高度。 height:100%;相对其父块的高度而定义的高度，也就是按照理她最近且有定义高度的父层的高度来定义高度。 CSS继承需要注意的问题由于字体和文本样式时刻是继承的，所以在使用相对字体单位时（比如百分比和em）时要格外小心。如果某个标签的字体大小被设置为80%，而他的一个后代的字体大小也被设置为80%，那么该后代最终的字体大小是：64%（80%的80%）。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://ijiangnanbei.com/tags/CSS/"}]},{"title":"行内元素 块级元素 空元素","date":"2017-01-20T14:38:00.000Z","path":"2017/01/20/行内元素-块级元素-空元素/","text":"1.行内元素：a b span img input select strong lable q textarea br 2.块级元素div ul ol li dl dt dd h1 h2 h3 h4… p address blockquote form hr table ul 3.空元素&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; &lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;embed&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://ijiangnanbei.com/tags/CSS/"}]},{"title":"CSS 浮动问题总结","date":"2017-01-18T14:36:08.000Z","path":"2017/01/18/CSS-浮动问题总结/","text":"1.在IE6或者IE7下，元素浮动要并在同一行的元素都要加浮动。 2.IE6下的双边距Bug问题：问题描述：在IE6下，块元素有浮动和横向的margin时，横向的margin值会被放大两倍解决办法：给要浮动的元素添加display:inline;属性 3.IE6和IE7下li有若干px的间隙问题：原因：在IE6和IE7下，li本身没浮动，但内容浮动了，li下面就会多出几px的间隙解决办法：1.给li加浮动（太麻烦，会造成后续一系列的问题） 2.给li添加 vertical-align:top;属性（最常用的解决办法） 4.在IE6下，高度小于19px的元素，高度会被当做19px来处理解决办法：1.给元素添加font-size:0;属性（缺点：最小只能处理到2px） 2.给元素添加 over-flow:hidden;属性（最常用的解决办法）","tags":[{"name":"CSS","slug":"CSS","permalink":"http://ijiangnanbei.com/tags/CSS/"}]},{"title":"CSS 小知识点","date":"2017-01-18T14:34:05.000Z","path":"2017/01/18/CSS-小知识点/","text":"1.给&lt;img&gt;标签的alt属性添加让人一听或者一看就能明白的内容。 2.搜索引擎会将&lt;h1&gt;视为仅次于&lt;title&gt;标签的另一个搜索关键词的来源。 3.几乎所有元素的display属性值要么为block，要么为inline。最明显买的一个例外是table元素，他有自己特殊的display属性值！ 4.无论你想了解哪一个html元素，第一个要问的问题都应该是：它是块级元素还是行内元素。 5.块级元素盒子会扩展到与父元素同宽，行内元素盒子会“收缩包裹”其内容，并且会尽可能抱紧。 6.blockquote元素会默认缩进。 7.&amp;ldquo和&amp;rdquo，使用这两个引号的实体，能让页面显得更加专业。 8.用HTML来构建DOM，最后使用CSS来修改DOM。 9.h1,h2,h3{color:blue}把三个选择符组合在一起，就可以减少重复输入。（如果你想在后面单独为h3应用一条规则，在后面添加即可） 10.上下文选择符是以空格作为分隔，而分组选择符是以逗号作为分隔。 11.p*{color:red;}这样会把p包含的所有元素的文本变为红色。section *a{color:red;}任何是section的孙子元素，而非子元素的a标签都会被选中。至于a的父元素是什么，没有关系。 12.没有默认样式的span，由于我们没有明确为其添加样式，所以就继承了其父元素的样式。 13.ID也可以用在页内的导航链接中，目标是同一页的另一个位置。 14.ID值得唯一性对js尤其重要，否则就会导致js行为异常。 15.类的目的是为了标识一组具有相同特征的元素。类可以应用给任意多个页面中任意多的HTML元素的公共标识符，以便我们为这些元素应用想用的样式。 16.继承和上下文选择符能让不同的标签共享样式，从而降低你需要编写和维护的css的量。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://ijiangnanbei.com/tags/CSS/"}]},{"title":"伪元素使用详解","date":"2017-01-16T14:29:09.000Z","path":"2017/01/16/伪元素使用详解/","text":"1. :after ::after 单双引号的区别其实无论是单引号还是双引号，他们的本质都是伪元素，只不过因为伪类使用的也是单引号，同时他们的写法类似，写法也相仿，但实际上 css3 为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。 但因为兼容性的问题，所以现在大部分还是统一的单冒号，但是抛开兼容性的问题，我们在书写时应该尽可能养成好习惯，区分两者。 2.使用伪元素需要注意的问题 在内容模块中提到，伪元素如果没有设置“content”属性，伪元素是无用的。 使用伪元素插入的内容在页面的源码里是不可见的，只能在css里可见。 插入的元素在默认情况下是内联元素（或者，在html5中，在文本语义的类别里）。因此，为了给插入的元素赋予高度，填充，边距等等，你通常必须显式地定义它是一个块级元素。 还要注意的是典型的 CSS 继承规则适用于插入的元素。例如，你有字体系列黑体，宋体，无衬线字体应用到 body 元素里，然后伪元素会像其他元素一样继承这些字体系列。 伪元素不会自然继承自父元素(如 padding margins)的样式。 你的直觉是 :before 和 :after 伪元素可能是插入的内容会被注入到目标元素的前或后注入。其实不是这样的，注入的内容将是有关联的目标元素的子元素，但它会被置于这个元素的任何内容的“前”或“后”。来看下面这样一个栗子： 1234567891011121314151617181920&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; p.box &#123; width: 300px; border: solid 1px black; padding: 20px; &#125; p.box:before &#123; content: \"#\"; border: solid 1px black; padding: 2px; margin: 0 10px 0 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"box\"&gt;Other content.&lt;/p&gt; &lt;/body&gt; 效果展示 外面的盒子是这个段落。围绕有散列符号的边框表示伪元素的边界。所以，不是插入“before”到段落，而是伪元素被置于到此段落的“Other content”的前面。 记住伪元素必须是被应用元素的子元素。 伪元素不会出现在DOM中，这些元素不是真正的元素。因此，它们不是可用的。所以，不要使用伪元素生成内容，是你的网页的可用性和可访问性的关键。 另外一件需要记住的是，开发工具，例如火狐，不要用伪元素显示内容。所以，如果使用了，伪元素会造成难以维护和调试缓慢。 3.使用 after 伪类清除浮动使用 after 伪类清除浮动也是目前清除浮动的主流方法，其使用方式如下： 未清除浮动之前：12345678910111213141516171819&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .container&#123; border: 1px solid; &#125; .subCon&#123; width: 100px; height: 100px; background-color: yellow; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"subCon\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 效果展示。可以看出此时因为给子级添加了浮动，所以父级并没有包住子元素。 使用 after 伪类清除浮动：12345678910111213141516171819202122232425&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .container&#123; border: 1px solid; &#125; .clear:after&#123; content: \"\"; display: block; clear: both; &#125; .subCon&#123; width: 100px; height: 100px; background-color: yellow; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container clear\"&gt; &lt;div class=\"subCon\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 效果展示。但是问题又来了，使用 after 伪元素在元素末尾添加内容在 IE6 和 IE7 下是不兼容的。 这个时候就要使用到 zoom 缩放来触发 IE 下的 haslayout ,使元素根据自身内容计算宽高。 要注意：在 IE6，IE7 下，父级元素有宽高是不用清浮动的。 兼容性处理：12345678910111213141516171819202122232425262728293031&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .container&#123; border: 1px solid; &#125; /*在这里请浮动*/ .clear:after&#123; content: \"\"; display: block; clear: both; &#125; /*在这里进行兼容性处理*/ .clear&#123; *zoom:1; &#125; .subCon&#123; width: 100px; height: 100px; background-color: yellow; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container clear\"&gt; &lt;div class=\"subCon\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 效果展示。 注意：是在父级上使用 after 伪类。 4.使用伪元素插入文本内容1234567891011121314151617181920&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; p.box &#123; width: 300px; border: solid 1px black; padding: 20px; &#125; p.box:before &#123; content: \"#\"; border: solid 1px black; padding: 2px; margin: 0 10px 0 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"box\"&gt;Other content.&lt;/p&gt; &lt;/body&gt; 效果展示 5.使用伪元素插入非文本内容1234/* 使用伪元素插入图片 注意：url里面的内容没有引号*/p:before&#123; content: url(image.jpg);&#125; 6.给一段文字打引号效果展示&amp;&amp;源代码 7.参考文献参考文献一&amp;&amp;参考文献二","tags":[{"name":"CSS","slug":"CSS","permalink":"http://ijiangnanbei.com/tags/CSS/"}]},{"title":"字符串函数详解","date":"2017-01-16T12:17:37.000Z","path":"2017/01/16/字符串函数详解/","text":"字符串长度函数字符串长度函数：strlen（）; 计算的是字符串的字节长度; mb_strlen（）; 是根据编码计算字符串的字符个数。 在 utf-8 编码规则中，一个中文占三个字节，gbk 编码格式中是一个汉字占两个字节。 查找字符串中子字符串位置的函数strpos ( string $haystack , mixed $needle [, int $offset = 0 ] ); 第二个参数的意思是可以传混合类型；（无论是在字符串中还是在数组中都是从零开始读取其中内容的）。 offset 的作用，除了第一次出现的字符，这个字符第二次还会不会出现？offset 的意思就是说，把光标先偏移一段距离，再查找，别从头开始查找。 在计算机里，ascll 字符集中，如果你的第二个参数写的是整形，则把它理解为 ascll 字符的编码。 注意，当你查找的字符在字符串中的第一个位置时，如果用简单的 if 判断，此时的函数并不能识别第一个找到的字符，因为字符串是从零开始识别的。所以这时候你要这样用：注意这里的===（去等于号）（在 strpos 这里三等于和两等于的区别很好的体现出来了）。 思考题：用for循环或while循环，配置strpos，计算某父串中子串的个数？1234567891011121314151617181920212223242526&lt;?php function subnum($str, $sub)&#123; //子串的长度 $sublen = strlen($sub); //父串的长度 $strlen = strlen($str); if($sublen &gt; $strlen)&#123; return 0; &#125; for($offset=0,$num=0; ($offset=strpos($str,$sub,$offset)) != false;)&#123; $num += 1; $offset += $sublen; &#125; return $num; &#125; $str = 'wo ni ta ta ni wo wo'; $sub = 'wo'; echo subnum($str,$sub);/*php的字符串函数非常强大，你要是不了解，可能会多花很多的冤枉时间，做很多的无用功，去费力写出一个函数，结果其实早就已经存在。其实只需要一个函数帮你解决问题了，所以一定要熟悉php的字符串函数（上面的那个思考题，可以直接用一个字符串函数实现，比如说substr_count()）。*/","tags":[{"name":"PHP","slug":"PHP","permalink":"http://ijiangnanbei.com/tags/PHP/"}]},{"title":"字符串定界符用法","date":"2017-01-13T12:16:31.000Z","path":"2017/01/13/字符串定界符用法/","text":"当你需要些一大段文本，甚至里面有好多行，又有单引号，又有双引号，导致转义的时候比较麻烦，这时候就可以用 heredoc 和 nowdoc 。 theredoc 的用法： &lt;&lt;&lt;标识符 中间的大段文本 标识符；。 注意： 标识符的名称和变量名的要求一样，叫什么都可以； 结束符独占一行，而且前面没有其他任何字符； 对文本的处理和双引号一样，可以解析\\r，\\t，\\n,变量等；123$str = &lt;&lt;&lt;content 中间的大段文本content; 对文本进行解析比如说单引号，到了 php5.3.0 之后出现了 nowdoc 可以达到上述要求，非常简单又不对变量做解析。 nowdoc 的写法和 heredoc 的写法以后，唯独在标识符的外面用单引号包起来，就和单引号一样的效果，不去转义r\\,t\\,\\n,变量等； 当别人问你怎么声明字符串变量的时候，你要知道我们有四种方法，单双引号，还有今天学的两种。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://ijiangnanbei.com/tags/PHP/"}]},{"title":"字符串定义及单双引号的区别","date":"2017-01-13T12:15:38.000Z","path":"2017/01/13/字符串定义及单双引号的区别/","text":"单双引号的区别？ 单引号，系统不做复杂转义，只转义 \\&#39; 和 \\\\，其他的一律原样输出。 双引号则转义的比较多，\\\\&quot;,\\\\,\\r,\\n,\\t,\\$… 单引号不对字符串的 $ 作变量解析。 双引号，会尝试将 $ 理解成变量名来解析。 单双引号定义字符串那个更快？单引号解析的更快，不用进行更多的转义和变量解析。 具体什么时间用单双引号？ 大段文本，新闻标题，文本内容，自我介绍，这样的大段话用单引号，解析更快。 需要在一段字符中夹杂变量，比如拼凑 sql 语句时：$id = 5; $sql = &quot;select * from user where id = $id&quot;;，如果此时使用单引号则无法解析 $ 变量，所以此时使用双引号更合适。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://ijiangnanbei.com/tags/PHP/"}]},{"title":"超全局变量","date":"2017-01-12T12:14:15.000Z","path":"2017/01/12/超全局变量/","text":"常量和超全局变量在函数的任何一处都可以访问到。 1234567$_GET //地址栏上的参数$_POST //接收 POST 型的表单参数$_REQUEST //当你不想区分 $_GET 和 $_POST 时，可以使用它$_FILES //文件上传$_COOKIE,$_SESSION //用户登录$_ENV,$_SERVER //服务器和访客的一些信息$_GLOBALS //所有变量的一个注册表，你可以在里面找到声明过的所有变量，我们可以通过它操作普通的全局变量。 1234567891011$var1 = 5;$var2 = 1;function get_value()&#123; $var1 = 0; $GLOBALS['var2]++;&#125;get_value();echo $var1;echo $var2;//result : 5 2 12345678910$age = 5;function t()&#123; //global 关键字，用在变量前面声明这个变量用是全局范围内的$age global $age; $age++;&#125;t();echo $age;//result : 6 函数和全局变量并不是水火不容的，我们可以： 通过引用传参影响全局变量 通过 global 声明，也能直接使用外部变量（不推荐，有风险） 直接操作超级全局变量","tags":[{"name":"PHP","slug":"PHP","permalink":"http://ijiangnanbei.com/tags/PHP/"}]},{"title":"引用传参","date":"2017-01-11T12:07:09.000Z","path":"2017/01/11/引用传参/","text":"123456789function t($num)&#123; $num += 5;&#125;$age = 19;t($age);echo $age;//19//注意这里的输结果是19 123456789101112function t(&amp;$num)&#123;//此处传的是实参的地址 $num += 5;&#125;$age = 19;t($age);echo $age;//24//注意这里的输出结果是24//函数的全局变量和局部变量并不是水火不容的，是有机会相互影响//的，比如说通过 `引用传参` 和 `超级全局变量`。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://ijiangnanbei.com/tags/PHP/"}]},{"title":"动态函数","date":"2017-01-10T12:07:09.000Z","path":"2017/01/10/动态函数/","text":"函数的命名规范和变量一样，但是不区分大小写，以后学到面向对象的方法时，也不区分大小写。 函数就像一台机器，比如说其中的一个函数是电饭锅，如果你没有加水（函数出错了），它就会发出响声（报错），但是如果你操作方法都正确的话，就会产生熟饭。 动态函数所谓动态函数，就是函数的名字用变量表示的函数。12345678910111213function wel()&#123; echo 'welcome';&#125;$result = \"wel\";$result();//welcome/*php中你可以动态调用函数，分为以下步骤：1. 定义一个函数 2. 将函数名（字符串）赋值给一个变量 3. 使用变量名代替函数名动态调用函数*/","tags":[{"name":"PHP","slug":"PHP","permalink":"http://ijiangnanbei.com/tags/PHP/"}]},{"title":"字符串运算及运算返回值","date":"2017-01-09T12:04:32.000Z","path":"2017/01/09/字符串运算及运算返回值/","text":"12345678910111213141516$str1 = 'hello';$str2 = ' ';$str3 = 'world';echo $str1.$str2.$str3;echo $str1,$str2,$str3;/*二者的输出结果相同：hello world原因：'.'先拼接再整个输出。 ','挨个把三个变量输出。*//*面试题：面对上述两种情况，用点好逗号那个输出快，效率高？答：逗号，省去了一次拼接计算的过程。*/","tags":[{"name":"PHP","slug":"PHP","permalink":"http://ijiangnanbei.com/tags/PHP/"}]},{"title":"比较运算及类运算","date":"2017-01-09T10:04:32.000Z","path":"2017/01/09/比较运算及类运算/","text":"123456789$a = true;$b = 5;$a = $b;//把整形转换成bool型/*在有些语言中语言中是没有布尔型的，都是 1 或 0 来充当 true 或 false，0 和 0.0 这两个值被转换为布尔值是 false，其他的转换为布尔值都是 true。*/ 在不同的数据类型进行比较时，PHP 程序本身会把变量转换成一致的类型，然后再比较。 布尔值-&gt;字符串。true-&gt;1;false-&gt;0; 字符串-&gt;数字。从字符串左端开始找数字，直到第一个非数字结束，取出的这部分，是转换后的值。eg : &#39;ab123&#39;-&gt;0。 字符串-&gt;布尔值。空字符串 和 &#39;0&#39; 转换为 false， 其余的转换成 true。 数字-&gt;字符串。原样输出。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://ijiangnanbei.com/tags/PHP/"}]},{"title":"常量","date":"2017-01-09T09:04:32.000Z","path":"2017/01/09/常量/","text":"常量为什么需要常量？某个重要的值赋值给变量容易被改变。 常量的特点 一旦定义不可修改。 不可重复定义。 全局有效性。 习惯上大写。（如果引用了一个未定义的常量，最终会把它当做字符串输出） 什么时候用到常量？网站根目录；网站配置文件。 如何定义常量？define(&#39;常量名&#39;,&#39;常量值&#39;); 输出常量：echo 常量名;（注意这里没有 $ 符） 常量类型整形；浮点型；字符串；布尔；Null。（五种标量类型） 动态常量想用动态常量，即想用变量名当常量的值，必须使用 constant() 函数。constant($var) 会把 $var 的值当成一个常量的名字，并解析出常量的值。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://ijiangnanbei.com/tags/PHP/"}]},{"title":"变量","date":"2017-01-08T09:04:32.000Z","path":"2017/01/08/变量/","text":"变量的概念及命名规范$i = 58; 变量 $i 表示在内存中开辟了一块空间，空间里面的值是58，$i 指向变量所在的地址。 PHP 的变量是区分大小写的。 变量类型1.整形。 2.浮点型。 3.字符串型。 4.布尔型。直接 echo 布尔型时，布尔型会被转换为字符串，true-&gt;&#39;1&#39; true 转化为字符串 1，false-&gt;&#39;&#39; false 转化为空字符串。 5.Null型。一个变量在三种情况下其值为 Null：给一个变量赋值为 Null时；当某个变量被 unset 时；只声明不赋值的时候。 动态变量所谓动态变量就是说，变量的名字还可以是一个变量。12345678$str = 'hello';$hello = 'hello world';echo $str .'&lt;/br&gt;'; //helloecho $hello .'&lt;/br&gt;'; //hello worldecho $$str .'&lt;/br&gt;'; //hello world//这里的 $$str 就是一个动态变量 变量检测用 isset 检测一个变量是否存在。 判断变量类型is_int, is_float, is_bool, is_null。 gettype 可以直接获取一个变量的类型。 变量的销毁unset(); 销毁变量名和变量值。 传值赋值1234567$a = 3;$b = 5;$b = $a;//这一步发生了什么，把$a的值拿出来，放到$b的空间里,就是把$a的值传递给$b，叫做传值赋值。echo $b; //3 ### 引用赋值123456$a = 3;$b = 5;$a = &amp;$b;echo $a.\" \".$b;// 5 5//为什么是 5 5,发生了什么？过程是把 $a 的指向指向了 $b 的地址空间，即$a,$b指向同一个地址，两把钥匙，指向同一个房间。 12345678$b = 5;$a = &amp;$b;unset($b);echo $a; //5//为什么销毁 $b 之后 $a 的值仍然是5，因为这个时候 $a $b 指向了同一个地址，即使 $b 被销毁了，但是此时 $a 所指向的仍然是内存中的那个地址，所以值仍然是5。//变量有一个机制，给某段地址存的值，有一个变量指向它的时候，这个地址所占的内存空间就不会被回收。 三个输出函数echo : 输出变量，适用于整形，浮点型，字符串这种标量类型。 print_r : 适合对象，数组，这种二维多维的数据。 var_dump : 不仅可以打印数据，还可以打印出数据的类型。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://ijiangnanbei.com/tags/PHP/"}]},{"title":"PHP 快速入门","date":"2017-01-06T09:04:32.000Z","path":"2017/01/06/PHP-快速入门/","text":"PHP快速入门首先,我们要明白什么是编程。所谓编程就是使用一种程序设计语言编写程序代码,让计算机解决某个问题的过程。 如此来看我们的生活中所做的任何事情都是在编程，比如说你想告诉别人一件事情，那你就要使用对方能听得懂的语言，把这件事情告诉对方，你所要达到的目的就是使对方能明白你所说的这件事。再比如说你想做一个鸡蛋炒西红柿，那你就要按照一定的顺序来完成这个炒菜的过程，最终的结果就是你做好了一盘西红柿炒鸡蛋。 PHP是一门程序设计语言，我们想要学习任何一门语言，最重要的就是把握三个地方：变量，运算和控制。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://ijiangnanbei.com/tags/PHP/"}]},{"title":"JS自定义属性及其应用","date":"2017-01-04T05:42:38.000Z","path":"2017/01/04/JS自定义属性及其应用/","text":"自定义属性JS 可以给任何一个 html 元素添加自定义属性，然而你可以使用这一特性做许多有意思的事情。 实例之图片开关123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;style type=\"text/css\"&gt; li&#123;width: 114px; height: 140px; list-style: none; background: url(images/normal.png); float: left; margin-left: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script type=\"text/javascript\"&gt; window.onload=function()&#123; var aLi=document.getElementsByTagName('li'); for(var i=0;i&lt;aLi.length;i++)&#123; aLi[i].onOff=true; aLi[i].onclick=function()&#123; if(this.onOff)&#123; this.style.background='url(images/active.png)'; this.onOff=false; &#125;else&#123; this.style.background='url(images/normal.png)'; this.onOff=true; &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Add custom property for every li. Attention: here we use custom property to attach switch for every li,in this way, we can control png switch freedom and don’t influence other li. 效果展示 获取自身递增数字123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" value=\"0\"&gt;&lt;input type=\"button\" value=\"0\"&gt;&lt;input type=\"button\" value=\"0\"&gt;&lt;script type=\"text/javascript\"&gt; window.onload=function()&#123; var aBtn=document.getElementsByTagName('input'); var arr=['A','B','C','D']; for(var i=0;i&lt;arr.length;i++)&#123; aBtn[i].num=0; aBtn[i].onclick=function()&#123; this.value=arr[this.num]; this.num++; if(this.num===arr.length)&#123; this.num=0; &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果展示 利用索引值做图片切换如何给一个特定的元素添加类？ 思路一：先全部清空然后添加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; p,ul&#123;margin: 0;padding: 0&#125; li&#123;list-style: none;&#125; body&#123;background: #333; &#125; #pic&#123;width: 400px; height: 500px; position: relative; margin: 0 auto; background: url(images/loader_ico.gif)no-repeat center #fff; &#125; #pic img&#123;width: 400px; height: 500px; &#125; #pic span&#123;height: 25px; top: 0; line-height: 25px; &#125; #pic p&#123;height: 30px; bottom: 0; line-height: 30px; &#125; #pic p,span&#123;width: 400px; text-align: center; color: #fff; position: absolute; background: #000; &#125; #pic ul&#123;width: 40px; position: absolute; top: 0; right: -50px; &#125; #pic li&#123;width: 40px; height: 40px; margin-bottom: 4px; background: #666; &#125; #pic .active&#123;background: #fc3; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"pic\"&gt; &lt;img src=\"\"&gt; &lt;span&gt;page is loading...&lt;/span&gt; &lt;p&gt;caption is loading...&lt;/p&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; window.onload=function()&#123; var oDiv=document.getElementById('pic'); var oImg=oDiv.getElementsByTagName('img')[0]; var oPage=oDiv.getElementsByTagName('span')[0]; var oCapt=oDiv.getElementsByTagName('p')[0]; var oUl=oDiv.getElementsByTagName('ul')[0]; var aLi=document.getElementsByTagName('li'); var arrUrl=['images/1.png','images/2.png','images/3.png','images/4.png']; var arrText=['1.png','2.png','3.png','4.png']; var num=0; var oldLi=null; var len = arrUrl.length; var str = ''; Init(); function Init() &#123; for(var i=0; i&lt;len; i++)&#123; str += '&lt;li&gt;&lt;/li&gt;'; &#125; oUl.innerHTML = str; fnTab(); &#125; function fnTab()&#123; //initialization oImg.src=arrUrl[num]; oPage.innerHTML=(1+num)+'/'+arrUrl.length; oCapt.innerHTML=arrText[num]; aLi[num].className = 'active'; Click(); &#125; function Click() &#123; for(var i=0;i&lt;len;i++)&#123; aLi[i].index=i; aLi[i].onclick=function()&#123; for(var i=0; i&lt;len; i++) &#123; aLi[i].className = ''; &#125; num=this.index; this.className='active'; fnTab(); &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果展示 利用索引值做图片切换如何给一个特定的元素添加类？ 思路二：先去除前一个，然后添加当前的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; p,ul&#123;margin: 0;padding: 0&#125; li&#123;list-style: none;&#125; body&#123;background: #333; &#125; #pic&#123;width: 400px; height: 500px; position: relative; margin: 0 auto; background: url(images/loader_ico.gif)no-repeat center #fff; &#125; #pic img&#123;width: 400px; height: 500px; &#125; #pic span&#123;height: 25px; top: 0; line-height: 25px; &#125; #pic p&#123;height: 30px; bottom: 0; line-height: 30px; &#125; #pic p,span&#123;width: 400px; text-align: center; color: #fff; position: absolute; background: #000; &#125; #pic ul&#123;width: 40px; position: absolute; top: 0; right: -50px; &#125; #pic li&#123;width: 40px; height: 40px; margin-bottom: 4px; background: #666; &#125; #pic .active&#123;background: #fc3; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt;&lt;div id=\"pic\"&gt; &lt;img src=\"\"&gt; &lt;span&gt;page is loading...&lt;/span&gt; &lt;p&gt;caption is loading...&lt;/p&gt; &lt;ul&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; window.onload=function()&#123; var oDiv=document.getElementById('pic'); var oImg=oDiv.getElementsByTagName('img')[0]; var oPage=oDiv.getElementsByTagName('span')[0]; var oCapt=oDiv.getElementsByTagName('p')[0]; var oUl=oDiv.getElementsByTagName('ul')[0]; var aLi=document.getElementsByTagName('li'); var arrUrl=['images/1.png','images/2.png','images/3.png','images/4.png']; var arrText=['1.png','2.png','3.png','4.png']; var num=0; var oldLi=null; for(var i=0;i&lt;arrUrl.length;i++)&#123; oUl.innerHTML+='&lt;li&gt;&lt;/li&gt;'; &#125; oldLi=aLi[num]; //initialization oImg.src=arrUrl[num]; oPage.innerHTML=(1+num)+'/'+arrUrl.length; oCapt.innerHTML=arrText[num]; aLi[num].className='active'; for(var i=0;i&lt;aLi.length;i++)&#123; aLi[i].index=i; aLi[i].onclick=function()&#123; oImg.src=arrUrl[this.index]; oCapt.innerHTML=arrText[this.index]; oPage.innerHTML=(this.index+1)+'/'+arrUrl.length; oldLi.className=''; oldLi=this; this.className='active'; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果展示","tags":[{"name":"JS","slug":"JS","permalink":"http://ijiangnanbei.com/tags/JS/"}]},{"title":"自增自减运算符","date":"2017-01-03T10:48:29.000Z","path":"2017/01/03/自增自减运算符/","text":"分类 前自增后自增 前自减后自减 二者的异同相同：最终都使 i 的值加一 不同：前自增整体表达式的值是i加1之后的值；后自增整体表达式的值是i加1之前的值。1234567891011#include &lt;stdio.h&gt;int main(void)&#123; int i,j,k,m; i = 3; j = 3; k = i++; m = ++j; printf(\"%d %d %d %d\",i,j,k,m);&#125;//result : 4 4 3 4 123int i = 3;printf(\"%d %d %d\",i++,++i,i);//result : 4 5 5 为什么会出现自增？有i += 1;不就可以了吗?为什么还有出现i++?原因:代码更精炼,自增的速度更快。 学习自增时要明白的几个问题我们编程时应该尽量屏蔽掉前自增和后自增的区别，自增表达式单独成一个语句,最好不要作为一个更大的表达式的一部分来使用。 比如：int m = i++ + ++i + i + i++;,这样写不但是不规范的代码,而且是不可移植的代码。 这个程序在不同的机器上的运行结果是不一样的,这里面牵扯到一个叫做顺序点的问题,因为我们不知道i++执行结束之后,这一步是否立即生效,就是在我执行++i的时候,前面的i有没有立即加1是不知道的,我们只有顺序点才能明确的知道这个操作是否生效,而顺序点只有三个:逗号,括号,分号。 作为一个优秀的程序员,在你的程序里面不应该体现出i++和++i的区别。","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ijiangnanbei.com/tags/C-C/"}]},{"title":"sublime 快捷键总结","date":"2017-01-02T14:01:37.000Z","path":"2017/01/02/sublime-快捷键总结/","text":"选择1.Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。2.Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。3.Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。4.Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。5.Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。6.Ctrl+M 光标移动至括号内结束或开始的位置。7.Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。8.Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。9.Ctrl+Shift+[选中代码，按下快捷键，折叠代码。10.Ctrl+Shift+] 选中代码，按下快捷键，展开代码。11.Ctrl+K+0 展开所有折叠代码。12.Ctrl+←向左单位性地移动光标，快速移动光标。13.Ctrl+→ 向右单位性地移动光标，快速移动光标。 编辑类1.Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。2.Ctrl+Shift+D 复制光标所在整行，插入到下一行。3.Ctrl+K+K 从光标处开始删除代码至行尾。4.Ctrl+Shift+K 删除整行。5.Ctrl+Shift+/注释多行。6.Ctrl+K+U 转换大写。7.Ctrl+K+L 转换小写。8.Ctrl+Y 恢复撤销。9.Ctrl+F2 设置书签10.F6单词检测拼写 搜索类1.Ctrl+F 打开底部搜索框，查找关键字。2.Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。3.Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。4.Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。5.Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。6.Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 显示类1.Ctrl+PageDown 向左切换当前窗口的标签页。2.Ctrl+PageUp 向右切换当前窗口的标签页。3.Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字）4.Alt+Shift+2 左右分屏-2列5.Ctrl+K+B开启/关闭侧边栏。6.Shift+F11 免打扰模式","tags":[{"name":"编程","slug":"编程","permalink":"http://ijiangnanbei.com/tags/编程/"}]},{"title":"浮点数存储所带来的问题","date":"2017-01-01T10:47:31.000Z","path":"2017/01/01/浮点数存储所带来的问题/","text":"存储精度的问题float 和 double 都不能保证精确的存储每一个小数， 浮点数存放的只是一个近似值。 面试题:如何判断一个浮点型变量x的值是否是0?答：if(|x-0.000001|&lt;=0.000001)--&gt;x=0 为什么循环更新的变量不能定义成浮点型？由于浮点型存储的是一个近似值,所以在进行循环的判断条件的求值的时候,其值会影响判断条件的结果。 比如说:i&lt;=100,如果这个时候i的值是100.000001,于是这一步就没有加入循环,这个时候就会影响整个循环的执行，我们更新部分的值只能是一个整数。 强制类型转换格式：(数据类型)(表达式)eg:(float)(5) == 5.00000","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ijiangnanbei.com/tags/C-C/"}]},{"title":"变量的作用域和存储方式","date":"2017-01-01T10:46:21.000Z","path":"2017/01/01/变量的作用域和存储方式/","text":"按作用域划分 全局变量。在所有函数外部定义的变量叫做全局变量；如果你的函数声明在了全局变量的前面,那你的函数里也是不可以使用全局变量的；全局变量的使用范围:从定义开始到整个程序结束。 局部变量。在一个函数内部定义的变量或者是函数的形参统称为局部变量。 全局变量和局部变量命名冲突的问题:在一个函数内部,如果定义的局部变量的名字和全局变量的一样,局部变量会屏蔽掉全局变量。 按变量的存储方式划分 静态变量 自动变量 寄存器变量","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ijiangnanbei.com/tags/C-C/"}]},{"title":"函数","date":"2016-12-30T10:45:15.000Z","path":"2016/12/30/函数/","text":"什么叫函数？ 逻辑上：能够完成特定功能的独立的代码单元。 物理上：能够接收数据,能够对接受的数据进行处理,能够将处理的结果返回。 总结:函数是一个工具,是为了解决大量的类似问题而设计的。函数可以当做一个黑匣子，只告诉你如何去使用,但是不给你内部的东西。 为什么需要函数？ 之所以需要函数是为了避免重复性操作。 学完函数就非常容易理解什么是面向过程的思想。 有利用程序的模块化。 面向过程的一个特点,就是把大问题分解成小问题,小问题再分解成更小的问题，整个程序是由很多个模块组成的,我修改这一个模块,不会影响另一个模块,这就提高了程序的健壮性。(C语言的基本单位是函数) 如何定义函数？12345函数的名字 函数的返回值 (函数的形参列表)&#123; 函数的执行体;&#125;//函数定义的本质是详细描述函数之所以实现某个特定功能的具体方法。 函数返回值的类型也称为函数的类型,因为如果函数名前的返回值类型和函数执行体中的 return 表达式中的返回值类型不同的话,则最终函数返回值的类型以函数名前的返回值类型为准(会自动进行类型转换)。 函数的分类？ 有参函数和无参函数。 有返回值函数和无返回值函数。 库函数 和 用户自定义函数。 普通函数 和 主函数(main函数)。 一个程序必须有且只能有一个主函数，主函数既是程序的入口也是程序的出口；主函数可以调用普通函数,反之则不可以，但是普通函数之间可以相互调用。 注意的问题 函数如何去定义，就看你如何去实现功能。 如何函数调用写在了函数定义的前面，则必须加函数前置声明，函数声明的作用就是告诉编译器即将出现的若干个字母是函数名，同时告诉编译器形参和返回值的具体情况。 函数声明是一个语句，所以末尾必须加分号。 对库函数的声明是通过#include &lt;库函数的名字.h&gt;来实现的。 12345678910111213141516171819202122#include &lt;stdio.h&gt;//判断一个数是不是素数的函数bool isPrime(int val)&#123; int i; for(i=2; i&lt;val; i++) &#123; if(val % i == 0) break; &#125; if(i == val) return true; /* 我们在写一个函数的时候，功能要尽量单一，内部最好不要 编写对结果处理的代码，（所以我们这里写的是return true）结果交给主调用函数去处理，这个函数的功能就是判 断一个数是不是素数，至于判断的结果该怎么处理，这 个就交给主调函数去处理了。 */ else return false;&#125; 如何合理设计函数来解决实际问题？ 一个函数的功能应该尽可能的单一,不要把过多的功能在一个函数中体现出来。 多学习,多模仿牛人的代码,用心的去看,用心的去模仿。","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ijiangnanbei.com/tags/C-C/"}]},{"title":"数组","date":"2016-12-30T10:42:35.000Z","path":"2016/12/30/数组/","text":"为什么需要数组？ 数组可以用来保存大量同类型的数据 一维数组可以模拟线性事物 二维数组可以模拟平面事物 三维数组可以模拟立体事物 利用数组可以模拟现实的世界 我们这里为什么不详细讲数组？数组的操作太麻烦，我们一般不直接操作语言级别的数组，而是通过别人提供的一种以数组为内核的工具去方便的操作数组。 一维数组的使用如何定义一维数组？一维数组是为 n 个变量连续分配存储空间；所有变量的数据类型必须相同；所有变量所占的字节大小必须相同。 一维数组的初始化完全初始化：int a[5] = {1,2,3,4,5};不完全初始化：int a[5] = {1,2,3};(未初始化的元素为0）不初始化：int a[5];(所有的元素都是垃圾值）清零：int a[5] = {0};（数组内的所有元素均为0） 初始化的错误写法1234567891011121314151617181920//第一个错误写法int a[5];a[5] = &#123;1,2,3,4,5&#125;;/*这里我们就没有 a[5] 这个元素，同时你把多个值赋值给一个元素肯定也是不可以的，只有在定义数组的同时才可以整体赋值。*///第二个错误写法int a[5] = &#123;1,2,3,4,5&#125;;int a[5] = 100;//我们没有 a[5] 这个元素//第三个错误写法int a[5] = &#123;1,2,3,4,5&#125;;int b[5];b = a;/*这样做是不可以把数组a的值全部赋值给数组b的，数组名代表的是数组第一个元素的地址。*/ 二维数组的使用二维数组的初始化12345678910int a[3][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;int a[3][4]=&#123; &#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;&#125;//总共十二个元素可以当做三行四列来看待a[i][j];//表示的是第i+1行第j+1列的元素。","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ijiangnanbei.com/tags/C-C/"}]},{"title":"使用toString做类型判断","date":"2016-12-28T07:33:21.000Z","path":"2016/12/28/使用toString做类型判断/","text":"使用 toString 做类型判断不管是系统对象还是我们自己写的对象都可以找到 toString，系统对象下面都是自带的，但是自己写的对象都是通过原型链找到 Object 下面的。 toString 的作用toString 的作用就是把对象转成字符串。 1234567var arr = [1,2,3];//更改toString的输出形式Array.prototype.toString = function()&#123; return this.join('+');&#125;alert(arr.toString());//1+2+3 toString 进制转换我们可以利用进制转换来转颜色值，比如说把rgba转换成16进制,或者相反。 12var num = 255;alert(num.toString(16));//ff toString 类型判断123456var arr = [];alert(Object.prototype.toString.call(arr));//[object Array]//这才是我们判断是不是数组最完美的方法alert(Object.prototype.toString.call(arr) == '[object Array]');//true 为什么使用 toString 做类型判断是最准确的？1234567891011121314151617window.onload = function()&#123; var oF = document.createElement('iframe'); document.body.appendChild(oF); //frames[]是iframe的一个集合 var ifArray = window.frames[0].Array; //你创建出来的这个数组其实就是iframe里面的数组 //这个时候你其实就跨页面了 var arr = new ifArray(); //这个时候虽然跨页面了,但是这个时候arr仍然是一个数组 // alert(arr.constructor == Array);//false // alert(arr instanceof Array);//false alert(Object.prototype.toString.call(arr) == '[object Array]');//true&#125;","tags":[{"name":"面向对象&组件开发","slug":"面向对象-组件开发","permalink":"http://ijiangnanbei.com/tags/面向对象-组件开发/"}]},{"title":"instanceof 运算符的使用","date":"2016-12-27T07:33:21.000Z","path":"2016/12/27/instanceof-运算符的使用/","text":"instanceof 运算符instanceof:判断对象与构造函数在原型链上是否有关系。 123456789function Fn()&#123;&#125;var fn1 = new Fn();//看看对象和构造函数是不是在同一个原型链上alert(fn1 instanceof Fn);//true//每一个对象的最外层都是 Object.protoalert(fn1 instanceof Object);//true 用 instanceof 做类型判断123var arr=[];alert(arr instanceof Array);//true 面试题如何判断一个变量是不是数组？首先你肯定不能用 typeof 因为它区分不开很多东西。像 ‘constructor和 &#39;instanceof 都能区分开来数组，但是他们并不是最好的方案。最好的方案其实是 toString()。","tags":[{"name":"面向对象&组件开发","slug":"面向对象-组件开发","permalink":"http://ijiangnanbei.com/tags/面向对象-组件开发/"}]},{"title":"continue 概述","date":"2016-12-26T10:41:07.000Z","path":"2016/12/26/continue-概述/","text":"通过下面三个例子我们来看看 continue 的作用1234567891011121314151617int main()&#123; int i=0,s=0; do &#123; if(i % 2) &#123; i++; continue; //continue 执行完之后将会转向执行 while 判断 &#125; i++; s += i; &#125;while(i &lt; 7); printf(\"%d\\n\",s); return 0;&#125; 123456789for(1;2;3)&#123; A; B; continue; //执行完 continue 之后不会执行C,D会转而执行for循环的判断条件 C; D;&#125; 123456789101112131415161718int main()&#123; int a=1,b; for(b=1; b&lt;=10; b++) &#123; if(a &gt;= 8) break; //如果要是执行 break 语句则会转而执行第 17 行 if(1 == a%2) &#123; a += 5; continue; //如果要是执行 continue 语句,则会转而执行for循环的判断条件 &#125; a -= 3; &#125; printf(\"b=%d\",b);&#125;","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ijiangnanbei.com/tags/C-C/"}]},{"title":"break 详解","date":"2016-12-26T10:39:42.000Z","path":"2016/12/26/break-详解/","text":"break 如果用于循环是用来终止循环的1234567891011for(int i=1; i&lt;=3; i++)&#123; if(3 &gt; 2) break; //break 在这里是用于终止 for 循环的 printf(\"这条语句永远不会输出\"); //break 虽然是 if 内部的语句，但却是用来终止整个for循环的， //所以 printf 里面的内容永远不会输出。&#125; 12345678910111213for(int i=0; i&lt;3; i++)&#123; for(int j=1; j&lt;4; j++) break; //在多层循环中，break 只能终止离它最近的那个循环 print(\"hello\\n\");&#125;/*result:hellohellohello*/ break 如果用于 switch 是用来终止 switch 的，在多层 switch 嵌套中，break 只能终止离它最近的 switch。 break 不能直接用于 if，除非 if 属于循环内部的一个句子。 return 和 break 的区别return 是用来终止函数用的，一执行 return，return 所在的函数就立即终止了；return 可以终止被调函数，向主调函数返回表达式的值，如果表达式为空，则只终止函数，不向主调函数返回任何值。","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ijiangnanbei.com/tags/C-C/"}]},{"title":"流程控制","date":"2016-12-26T10:37:26.000Z","path":"2016/12/26/流程控制/","text":"流程控制的分类:顺序执行；选择执行；循环执行。 流程控制为什么重要?图灵认为在现实世界中无论多么复杂的问题,你都可以用顺序,选择和循环三种结构去实现。计算机领域所有的问题都有流程控制的思想,比如说数据库。 if 语句If 的范围问题if(表达式) 语句a; 语句b; 解释: if 默认只能控制语句 a 的执行或者不执行,也就是说语句 b 一定会执行, if 语句在没有加大括号的情况下只能控制紧邻其后的那一条语句的执行。 常见问题解析123456789int main(void)&#123; if(1 &gt; 2); prinft(\"aaa\"); printf(\"bbb\\n\");&#125;result: aaa bbb//解析：之所以导致这样的结果，是因为你在 if 语句的结尾加了一个分号 1234567//下面这两个语句是等价的else(5&gt;10); printf(\"ccc\"); else (5&gt;10);printf(\"ccc\"); 123456789if()&#123;&#125;else if()&#123;&#125;else if()&#123;&#125;//这样写语法不会出错但是逻辑上有漏洞 for 循环for 循环的执行流程123456for(1;2;3)&#123; 4;&#125;//执行流程：先执行1,1执行完了开始执行2,2执行完了标志着循环成立，这个时候就开始执行循环体4，然后再执行3，3执行完了才标志着一次循环的结束。3执行完之后继续执行2，然后执行4，然后执行3... 多层 for 循环的嵌套使用1234567891011121314151617for(1;2;3) for(4;5;6) a; b; //上面这个 for 循环等价于for(1;2;3)&#123; for(4;5;6) &#123; a; &#125;&#125;b;//其执行流程为：1-&gt;2-&gt;如果2成立，执行内部循环-&gt;3-&gt;2-&gt;如果2成立，执行内部循环。（只有当2不成立的时候才会执行b；内部循环的执行逻辑和外部循环是一样的；每当执行内部循环的时候，4 都会执行。） for 循环举例123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int i,j; for(i=0; i&lt;3; i++) printf(\"aaa\\n\"); for(j=0; j&lt;3; j++) printf(\"bbb\\n\");&#125;/*输出结果为：（注意这个输出结果）aaaaaaaaabbbbbbbbb while 概述while 语句格式12while(表达式) 语句； while 与 for 的比较（二者可以互换）12345678910111213141516171819for(i=1; i&lt;=1000; i++) sum += i;while(i &lt;= 1000)&#123; sum += i;//(这两个语句顺序不可以互换) i++;//(这两个语句顺序不可以互换)&#125;//同理下面这两个语句也是等价的for(1;2;3) a;while(2)&#123; a; 3;&#125; do…while… 语句主要是用于人机交互。 switch 语句switch 语句的格式123456789101112131415161718switch(表达式)&#123; case 常量表达式1：语句1； case 常量表达式2：语句2； case 常量表达式3：语句3； default：语句4；&#125;/*第一：所有case后面的常量表达式为便于描述我们姑且称之为标签，这些标签只能都是：枚举常量；数值常量；字符常量；常变量；宏名中的一种，注意普通变量，枚举变量是不可以作为便签使用的。（常变量：是一个变量，只能被赋予一个值，一般用const定义。）第二：switch 后面括号里的表达式允许是任何类型。（但是 vc++ 中只允许是 int 或 char 型。）第三：执行文一个 case 语句后，流程控制就转移到下一个 case 语句继续执行。case 常量表达式只是起语句标号的作用，并不是在该处进行条件判断。在执行 switch 语句时，根据 swtich() 中表达式的值找到与之匹配的 case 语句，就从此 case 子句开始执行下去，不再进行判断。 第四：switch 是选择不是循环，如果在 switch 中出现了 break 语句。该语句的功能只是退出 switch 语句转去执行它下面的语句。在 switch 出现 continue 是错误的，除非 switch 本身就属于 for 或 while 循环的一部分。*/","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ijiangnanbei.com/tags/C-C/"}]},{"title":"hasOwnProperty 和 constructor 的使用","date":"2016-12-26T07:33:21.000Z","path":"2016/12/26/hasOwnProperty-和-constructor-的使用/","text":"hasOwnProperty() 方法hasOwnProperty():检测是不是对象自身下面的属性。 123456789var arr = [];arr.num = 10;Array.prototype.num2 = 20;//true,说明num这个属性是arr独享的alert(arr.hasOwnProperty('num'));//false,这个属性不是arr独享的alert(arr.hasOwnProperty('num2')); constructor 属性constructor:查看对象的构造函数 。 12345678function Aaa()&#123;&#125;var a1 = new Aaa();alert(a1.constructor);//function Aaa()&#123;&#125;var arr = [];//我们可以利用这个属性来做类型的判断alert(arr.constructor == Array); constructor 是哪来的？12345678910111213141516171819function Aaa()&#123;&#125;//当我们写完一个函数的时候,不管是我们自己写的函数,还是系统自带的函数//程序都会自动帮我们生成一句话,只有它才是每一个函数都会自动生成的// Aaa.prototype.constructor = Aaa; //我们来修改一下看看 Aaa.prototype.constructor = Array; var a1 = new Aaa(); //function Array()&#123;[navtive code]&#125; alert(a1.constructor); // hasOwnProperty是加在最外层 Object.prototype 上面的 // function hasOwnProperty()&#123;[native code]&#125; alert(a1.hasOwnProperty); //我们来验证一下 alert(a1.hasOwnProperty == Object.prototype.hasOwnProperty);//true 你是如何不经意间修改 constructor 的？constructor 是在你创建完函数之后,系统自动生成的,我们最好不要去动他，但是有时候你会在不经意之间就把它修改了。 123456789101112131415161718192021222324function Aaa()&#123;&#125; // Aaa.prototype.name = \"xiaoming\"; // Aaa.prototype.age = 20; //我们可以把上面两句改成json的形式,表面上看这种表达方式似乎是一样的 //但是当我们使用json的形式的时候,我们已经在不经意间修改了constructor //当你用json表示的时候,代表的是给Aaa.prototype赋值, //所以系统自动生成的Aaa.prototype.constructor = Aaa; //就被你给覆盖掉了,这时当你再去找constructor的时候 //你找到的就是json对应的constructor Aaa.prototype = &#123; //所以,当你使用简写的时候,被忘了修正指向 constructor : Aaa, name : \"xiaoming\", age : 20 &#125;; var a1 = new Aaa(); //function Aaa()&#123;&#125; alert(a1.constructor); for-in 找不到系统自带属性在使用 for-in 的时候，其实系统自带的属性都是循环不到的。 12345678910function Aaa()&#123;&#125;Aaa.prototype.age = 10;for(var attr in Aaa.prototype)&#123; alert(attr);&#125;//你自己添加的属性用for in是可以找到的,但是系统属性比如自动生成的//constructor就是找不到的，即使你自己重新写了constructor也是找不到的//Aaa.prototype.constructor = Aaa;","tags":[{"name":"面向对象&组件开发","slug":"面向对象-组件开发","permalink":"http://ijiangnanbei.com/tags/面向对象-组件开发/"}]},{"title":"面向对象中的原型链","date":"2016-12-25T07:33:21.000Z","path":"2016/12/25/面向对象中的原型链/","text":"什么是原型链？实列对象与原型之间的链接，叫做原型链。 __proto__(隐式连接) Object 对象类型是原型链的最外层. 面向对象中的原型链123456789101112function Aaa()&#123;&#125;Aaa.prototype.num = 10;var a1 = new Aaa();//num是Aaa.prototype对象下面的属性,但是a1却是另一个对象//那么a1是如何找到Aaa.prototype下面的属性的呢?通过原型链。//在这里实列对象:a1;原型是Aaa.prototype//这个原型链我们是看不到的,但是可以在firbug下面找到,他的英文名字是://__proto__(隐式连接)alert(a1.num); 123456789101112function Aaa()&#123; this.num = 20;&#125;Aaa.prototype.num = 10;var a1 = new Aaa();alert(a1.num);//20//这里最终弹出来的是20,其实只要理解了原型链你就很容易搞明白//原型链是从内层一层一层的往外层查找的,所以弹出来的是20 上面的程序为什么最终出现的结果是20呢？我们可以做个类比，你可以把普通的方法和普通的属性看作是内联样式，把原型下面的属性和方法看作是内部样式，内联样式的优先级要高于内部样式的优先级。 原型链的在最外层原型链的的最外层是: Object.prototype。 12345678function Aaa()&#123; this.num = 20;&#125;Aaa.prototype.num = 10;Object.prototype.num = 30;var a1 = new Aaa();alert(a1.num);//20","tags":[{"name":"面向对象&组件开发","slug":"面向对象-组件开发","permalink":"http://ijiangnanbei.com/tags/面向对象-组件开发/"}]},{"title":"scanf 和 printf 的用法","date":"2016-12-24T10:34:57.000Z","path":"2016/12/24/scanf-和-printf-的用法/","text":"scanf 用法用法一:scanf(&quot;输入控制符&quot;,输入参数);功能:将从键盘输入的字符转化为输入控制符所规定格式的数据,然后存入以输入参数的值为地址的变量中。 举例：scanf(&quot;%d&quot;,&amp;i);这里之所以要用%d是因为来自你键盘的所有输入都是以字符的形式保存的,所以在这里我们用%d将其转化为一个十进制的数。 用法二:scanf(&quot;非输入控制符 输入控制符&quot;,输入参数);功能:非输入控制符必须原样输入。 举例：scanf(&quot;m%d&quot;,&amp;i);在这里%d前面有一个非输出控制符,所以这里就要求你在输入的时候,你的输入前必须要有一个非输出控制符。比如说你直接输入123就是错的,但是如果你输入m123就是对的,这个时候最终i的值就是 123，但是如果你输入m123n也是对的，但是我们一般不会在前面加一个非输出控制符,目的是让用户输入的越简单越好。 如何用 scanf 编写出高质量的程序？使用 scanf 之前最好先使用 printf 提示用户以什么要的方式来输入。 scanf 中尽量不要使用非输入控制符,尤其是 \\n 。 printf 用法1.printf (“字符串\\n”); 2.printf(“输出控制符”,输出参数);为什么要指定输出控制符?因为所有的东西都是以二进制保存在计算机中的。 3.printf(“输出控制符1 输出控制符2 …”,输出参数1,输出参数2….);。 4.printf(“输出控制符 非输出控制符”,输出参数); 输出控制符有:%d，%ld,%c,%f,%lf,%x(%X,%#x,%#X)。 为什么需要输出控制符？ 0和1 组成的代码可以表示数据也可以表示指令，如果 0和1 组成的代码表示的是数据的话,那么同样的 0和1 代码组合以不同的输出格式输出就会有不同的输出结果。","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ijiangnanbei.com/tags/C-C/"}]},{"title":"预备编程基础知识","date":"2016-12-24T10:32:13.000Z","path":"2016/12/24/预备编程基础知识/","text":"代码规范化写出规范的代码不但方便你自己观看同时也方便别人观看,最重要的是当你的程序写的很大的时候，规范的代码使你的程序不容易出错。 为什么创建文件的时候要选择C++？因为C++是完全兼容C的，所以我们创建文件的时候选择的是C++的格式。 什么是字节？字节就是存储数据的单位,并且是我们硬件所能访问的最小单位。硬件上不能精确到位只能精确到字节,一个字节等于八位,硬件通过我们的地址总线确定的是字节,要精确到位需要用软件来实现(C语言里面字符占一个字节,java里面字符占两个字节)。 1字节=8位；1k=1024个字节；1M=1024k；1G=1024M。 说到字节，你肯定会有这样的一个经历：你买一个硬盘内存总是会比实际的要小，这是为什么呢？ 商家是按 1k=1000字节 为单位计算的,而计算机是以 1k=1024字节 为单位计算的，两种换算单位的不一样就导致了我们实际使用的内存比产品标注的内存要小。 char 使用的常见问题char ch=&quot;ab&quot;;//error 不能把一个字符串放到字符里面。 char ch=&quot;a&quot;;//error 这个双引号里面其实有两个字符a\\0，所以这样书写也是错的。 在C语言里面字符串有两种保存方式，其一是通过指针，其二是通过数组。 什么是 Ascii 码？Ascii 码不是一个值,而是一种规定,规定了不同的字符用哪个整数值去表示。 什么是进制？所谓进制就是逢几进一，我们生活中导出都有进制的影子。比如说一周七天就是逢七进一；一分钟60秒就是逢60进一；一天24小时就是逢24进一；一年12个月就是逢12进一… 如何把 r 进制转化为十进制？ 5进制的234转成10进制: 41+35+255 16进制的234转成10进制:41+316+21616 如何把十进制转化成 r 进制？关于如何把 十 进制转化成 r 进制，总结成一句话就是：对其不停的用 r 求余，然后取“倒”。 不同的进制所代表的的数值之间的关系？本质上都是同一个数字 逗号表达式格式：(a,b,c,d) 功能：从左到右执行，最终表达式的值是最后一项的值。 12345678int i = (1,2,3);printf(\"%d\\n\",i);//最终的结果是：3int i,j=2;i = (++j,j++,j+2,j-3);printf(\"%d\\n\",i);//最终的结果是：1 12345int a,b,c,d,e,f,i;//i 的值是最后一个逗号表达式的值i = (a=1,b=2,c=3,d=4,e=5,f=6);printf(\"%d\",i);//result : 6 不推荐使用逗号表达式的写法","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ijiangnanbei.com/tags/C-C/"}]},{"title":"预备计算机专业基础知识","date":"2016-12-24T10:29:26.000Z","path":"2016/12/24/预备计算机专业基础知识/","text":"CPU,内存条,硬盘,显卡,主板和显示器之间的关系?我们来看一个电影是如何运行的?当你双击一部电影的时候,操作系统就会把硬盘上的这部电影的数据掉入内存条中,因为 CPU 不能直接处理硬盘上的数据,所以当数据存储到内存条中之后, CPU 再去处理内存条中的数据(电影),然后把其中的一些数据变成图像,一些数据变成声音,图像数据通过显卡在显示器显示出来,声音数据发送给声卡,声卡将其变成声音输出。 主板将CPU,内存条,硬盘,显卡连接在一起,并在他们之间传递数据。 hellow word 这个程序是如何被运行起来的?在 VC++6.0 中编程,点击 compile 和 build 按钮之后会产生一个.exe文件,这里需要说明的是我们的软件是不能直接执行.exe文件的,这个文件在后台是靠操作系统来执行的,操作系统调用CPU,CPU来执行这个程序。 所有软件的运行都是建立在操作系统的基础之上的。 什么是数据类型?编程语言就是要解决实际的问题,你解决问题的第一步就是把数据保存到计算机里面,存储的时候就要按照数据类型进行分类.(在你编程的过程中,一定要时刻记住”内存”这一个概念,最终你会发现编程的许多问题,其实都是内存的问题.) 基本数据类型:整数(整形 int ,短整形 short int,长整形 long int ),浮点数(单精度浮点数 float ,双精度浮点数 double),字符( char )(C语言里面是没有一个类型可以直接存储字符串的,如果你要存储一个字符串的话可以使用一个字符数组) 组合数据类型:结构体;枚举;共用体(所谓组合类型就是把基本类型拼凑到一起)。 CPU ,内存条, vc6.0 和操作系统之间的关系?在 VC++6.0 中当你编号程序,点击 compile 和 build 按钮之后会产生一个.exe文件,这里需要说明的是我们的软件是不能直接执行.exe文件的,在后台是靠操作系统来执行的,操作系统调用CPU,CPU来执行这个程序。 所有软件的运行都是建立在操作系统的基础之上的。 比如:i=3;,软件发出请求,操作系统为其在内存条中分配一块空间,然后把这块空闲的空间与字母i产生关联,你所使用的子母i,实际上使用的就是字母i所对应的存储空间。 变量为什么必须初始化?所谓初始化就是赋值的意思,之所以要初始化数据,是为了防止内存里面存储的数据并不是你想要的数据,内存里面可能是上一个程序遗留下来的垃圾数据。 所谓释放内存就是可以把这个空间的使用权限分配给其他程序去使用,如果你没有给一个变量赋初值,他就会自动的把一个很大的数字放进去,这个数字叫做”填充字”,这个填充字的作用就是在你没有初始化就使用的时候,给你一个错误提示.所以说任何一个变量在使用之前要进行初始化。 软件运行与内存的关系?内存是在操作系统的统一管理下使用的。 软件在运行前需要向操作系统申请运行空间,在内存空闲空间足够时,操作系统将分配一段内存空间并将外存中软件拷贝一份存入该内存空间中,并启动该软件的运行。 在软件运行期间,该软件所占内存空间不再分配给其他软件.当软件运行完毕后,操作系统将回收该内存空间(注意:操作系统并不清空该内存空间遗留下来的数据)以便再次分配给其他软件使用。 综上所述:一个软件所分配到的内存空间中极可能存在着以前其他软件使用过后的残留数据,这些数据被称之为垃圾数据.所以通常情况下我们为一个变量,一个数组,分配好存储空间之后都要对该内存空间初始化。 什么叫进制?来说一说我们生活中用到的进制:一周七天七进制,一年十二个月十二进制,一小时六十分钟六十进制,电脑中的数据二进制.在我们生活中随处都可以见到进制的影子。 所谓进制就是逢几进一,八进制在前面加一个0(零),十六进制前面加0x。 十进制:基数0,1,2,3,4,5,6,7,8,9。 十进数制举例:0,1,2,3,4,5,6,7,8,9,(逢十进一)10…19,(逢十进一),20…29…。 二进制:基数0,1。 二进制数举例:0,1(加1,逢二进1),10,(0加1没有进位)11,(11加1有进位)100,101,110(他们对应的十进制数字分别是0,1,2,3,4,5,6,),无论是十进制还是二进制它都是一个数值不同的计算方式,本质上都是一样的. 八进制:基数0,1,3,4,5,6,7. 八进制数举例:0,1,3,4,5,6,7,10(10-&gt;8),11(11-&gt;9)…. 十六进制:基数 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F. 十六进制数举例:0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,(10–1F),(20–2F)….(F0-FF). %d 表示以十进制输出；%x 表示以十六进制输出；%o 表示以八进制输出。 为什么现在的计算机使用二进制?因为从硬件上比较容易实现对数据的操作。 常量在计算机中是如何表示的?整数:十进制,十六进制,八进制。 浮点数:传统写法,科学计数法。 字符:单个字符用单引号括起来，字符串用双引号括起来。 常量以什么样的二进制代码存储在计算机中?整数是以补码的形式转化为二进制代码存储在计算机中的。 实数是以IEEE754标准….。 字符的本质实际上与整数的存储方式相同。","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ijiangnanbei.com/tags/C-C/"}]},{"title":"C语言简介","date":"2016-12-24T10:24:22.000Z","path":"2016/12/24/C语言简介/","text":"这是我学习过程中自己整理出来的C语言入门简明教程,希望它能让你轻松入门,这只是开始,后面的路还很长,加油,程序人! 入门的最基本的方法就是从C语言入手,当你成为C语言的高手,那么你就很容易进到操作系统的平台里面去;当你进入到操作系统的平台里面去实际做程序的时候,就会懂得进行调试;当你懂得调试的时候,你就会发现能轻而易举的了解整个平台的架构.这个时候,计算机基本上一切都在你的掌握之中了,没有什么东西能逃得出你的手心—梁肇新 C语言的起源和发展程序设计语言的发展过程:第一代机器语言；第二代汇编语言；第三方代高级语言。高级语言中又分为 结构化语言 和 面向对象语言，其中结构化语言的代表有:Basic ,Fortran , Pascal ,C. 面向对象小对象语言的代表有:C++ , java ,C#. C 语言是结构化语言, C++ 是面向对象的语言。结构化语言的缺陷：数据和操作是分离的，导致你写大项目的时候,会出现意想不到的问题。 C++ 是面向对象里面最难的语言，如果你学会了C++，其他的面向对象的语言你可以很轻松的就掌握了。 C语言的优点:速度快,代码量小,功能强大.(Java里面没有指针,不能直接访问我们的硬件). C语言的缺点：危险性高,在Ｃ语言中只要你写一个程序错的不是很离谱，他都认为你写这个程序有特殊的含义，不会给你报错；开发周期长,Ｃ语言是一个面向过程的语言，当代码上了十万行之后就很容易奔溃，会出现各种各样的错误；可移植性弱,Ｃ语言写的程序有的机器可能不能跑，即便能很多的运行结果也是不一样的. Ｃ语言的应用领域：系统软件开发,操作系统:windows,Linux,nuix;驱动程序:主板驱动,显卡驱动,摄像头驱动;数据库:DB2,Oracle,Sql. 应用软件开发,办公软件:wps;图形图像多媒体:ps;嵌入式软件开发:智能手机,掌上电脑;游戏开发:2d,3d游戏. C语言的重要性:一名合格的黑客必须掌握的语言,比如说你要制造一个病毒,病毒一个最基本的特征就是感染我们的操作系统,你要编写病毒,你就要首先找到用C语言编写的操作系统的漏洞. 任何一个想终生从事程序设计和开发的人员必须熟练掌握的语言.大企业,外企招聘必考的语言.为学习数据结构,C++,java,奠定基础. 学习的目标?本教程只是在学习数据结构之前的简明 C 语言入门教程,希望你学完之后能熟练掌握C语言的语法规则;掌握简单的算法;理解面向过程的思想,这非常有助于将来面向对象思想的学习;能看懂程序;会调试程序;掌握将大问题化为一系列小问题来解决的思想;为学习C++,java和数据结构打下良好的基础. 学习java为什么要先学习C语言?学习C就是在学习java,因为C语言至少有80%的语法知识都被java继承了.C是面向过程语言的代表,学好C有助于学习java里面面向对象的思想的学习. 学好C的指针是理解java中引用的基础,如果不懂指针就不可能对java中的引用有深刻的理解,而引用是java 中一个最基本但又十分重要的 概念.(如果你不懂java里面的引用,那么很复杂的程序你就看不懂了) 怎样学习C语言?多思考,多问为什么,学完之后必须要实践. 我们都有过这样的体验,上课即便你听懂了,下课之后当你自己敲的时候,敲出来的也一定是错的,即便你敲对了,也是蒙对的.这个程序从你看懂到你把它敲正确是需要一个过程的,没有一个人看懂之后可以直接把程序敲正确,即便是天才也不行. 如果你学习一门新课,在没有人给你讲的情况下,你要能把一本书给看懂,那这本书可以说写的是非常好的,下面是几本不错的学习C语言的书籍: 入门书籍: 《C语言程序设计》系统学习语法: 《C primer plus》深入研究指针: 《C和指针》C语言高手: 《C专家编程》《C缺陷与艺术》","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ijiangnanbei.com/tags/C-C/"}]},{"title":"包装对象","date":"2016-12-24T07:33:21.000Z","path":"2016/12/24/包装对象/","text":"包装对象基本类型都有自己对应的包装对象:String Number 和 Boolean 。 基本类型的方法12345678var str = 'hello';alert(typeof str);//string//注意,这个方法是str的方法,但是我们知道基本类型是没有方法的,那这个在源码中究竟是怎么设计的呢?str.charAt(0);alert(str.charAt(0));//h 源码里面是怎么给基本类型设置方法的123456789var str = new String('hello');alert(typeof str);//obj//此时str是对象,它再拥有方法就是很自然的事情了.alert(str.charAt(0));//h//源码里面是这么设计的String.prototype.charAt = function()&#123;&#125; 基本类型与包装对象的关系123456//当你执行这句话的时候,str确实是字符串var str = 'hello';//但是当你执行这句话的时候,基本类型会找到对应的包装对象类型,//然后包装对象把所有的属性和方法给了基本类型,然后包装对象消失str.charAt(0); 123456789var str = 'hello';//我们给基本类型添加方法的时候,也是把方法添加到基本类型对应的包装对象下面String.prototype.lastValue = function()&#123; return this.charAt(this.length-1);&#125;alert(str.lastValue()); 一道面试题123456789101112//执行这句话的时候就是一个基本类型var str = 'hello';//执行这句话的时候,这个时候基本类型要添加一个属性，就会在基本类型所对//应的包装对象下面创建一个对象,然后把10添加到对象的下面.//注意:添加完之后包装对象就消失了str.number = 10;//添加完之后包装对象就消失了，当你再去调用str的属性的时候,这个时候又//重新的创建了一个对象，但是这个对象和前面的那个对象并不同一个对象,这//个时候新的对象下面的属性是空的.alert(str.number);//undefined str.number 和 在原型下面添加方法是不一样的，在原形中不管你的创建了多少个对象它都可以找到原型下面的方法，原型下面的方法是共享的。","tags":[{"name":"面向对象&组件开发","slug":"面向对象-组件开发","permalink":"http://ijiangnanbei.com/tags/面向对象-组件开发/"}]},{"title":"隐藏页面元素的几个技巧","date":"2016-12-23T09:53:20.000Z","path":"2016/12/23/隐藏页面元素/","text":"每一个方法的背后其实都是一个效果的实现原理。你的方法越多，你所做出来的效果也就越多。 display：none；显示为无,不占据文档流。得到它的高很麻烦。 visibility：hidden；隐藏，仍然占据文档流，很容易就可以得到它的高。 width / height;宽高改为 0，去除边框。如果你能想到用高去控制，你就可以做出让一个元素慢慢打开的动画效果。比如说，移动到导航栏上，导航的内容慢慢的下来。 透明度把透明度改为 0 就看不到了。利用透明度你可以做一个淡入淡出的效果。 通过定位移出布局 left/top 值利用定位的原理，你可以做“弹出”的效果，用一个 div 将其覆盖，然后慢慢地将其从 div 下方弹出，很多门户网站常常用这个技巧来做新闻“弹出”的效果。 拿另一和背景色一样的 div 将其盖住，拿另一和背景色一样的 div 将其盖住，然后用各种方式移开和背景色一样的 div，就可以得到各种各样的动画效果。比如说，你可以让和背景色一样的 div 四周不停的缩小，就可以做出一个类似于“回”字的效果。 很多你所看到的惊讶的效果背后，其实就是这样出来的。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://ijiangnanbei.com/tags/CSS/"}]},{"title":"面向对象的写法","date":"2016-12-23T07:33:21.000Z","path":"2016/12/23/面向对象的写法/","text":"面向对象的写法1234567891011//构造函数function construct()&#123; this.property&#125;//原型方法construct.prototype.method=function()&#123;&#125;//实例对象并调用var obj1 = new construct();obj1.method(); 系统对象的设计在 js 源码中,系统对象也是基于原型的程序，我们可以推测出来，在 js 的源码中 js 的数组是这样设计的： 123456789101112//构造函数function Array()&#123; this.length = 0;&#125;//原型方法Array.prototype.push = function()&#123;&#125;;Array.prototype.sort = function()&#123;&#125;;var arr = new Array();arr.push();arr.sort(); 使用系统对象的注意点既然我们了解了系统对象的原理，那我们在用系统对象的时候就不要去修改其属性和方法。下面就是一个错误的示例： 12345678var arr = [1,2,3];Array.prototype.push = function()&#123;&#125;arr.push(4,5,6);//只能弹出来[1,2,3]alert(arr); 尽量不要去修改或者添加系统对象下面的方法或者属性。 完善系统对象123456789101112131415var arr = [1,2,3];Array.prototype.push = function()&#123; //this就是arr,arr就是1,2,3 //arguments就是实参的集合,所以argumengs就是4,5,6 for(var i=0;i&lt;arguments.length;i++)&#123; this[this.length] = arguments[i]; &#125; return this.length;&#125;arr.push(4,5,6);alert(arr);//1,2,3,4,5,6","tags":[{"name":"面向对象&组件开发","slug":"面向对象-组件开发","permalink":"http://ijiangnanbei.com/tags/面向对象-组件开发/"}]},{"title":"拖拽之面向对象","date":"2016-12-22T07:33:21.000Z","path":"2016/12/22/拖拽之面向对象/","text":"普通方法编写拖拽123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123;margin: 0;padding: 0;&#125; /* 编写拖拽的时候，使用的是相对定位 */ #drag&#123;width: 100px;height: 100px;background-color: red;position: relative;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"drag\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var oDrag = document.getElementById('drag'); var disX = 0; var disY = 0; oDrag.onmousedown = function(ev) &#123; var ev = ev || window.event; disX = ev.clientX - oDrag.offsetLeft; disX = ev.clientY - oDrag.offsetTop; document.onmousemove = function(ev) &#123; var ev = ev || window.event; oDrag.style.left = ev.clientX - disX + 'px'; oDrag.style.top = ev.clientY - disY + 'px'; &#125; document.onmouseup=function()&#123; document.onmousemove=null; document.onmouseup=null; &#125; return false; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 拖拽之变形变形方法： 尽量不要出现函数嵌套；可以有全局变量；把onload中不是赋值的语句放到单独的函数中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #div1&#123;width: 100px;height: 100px;background: red;position: relative;&#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var disX = null; var disY = null; var oDiv=null; window.onload=function()&#123; oDiv=document.getElementById('div1'); init(); &#125; function init()&#123; oDiv.onmousedown=fnDown; &#125; function fnDown(ev)&#123; var ev = ev || window.event; disX = ev.clientX - oDiv.offsetLeft; disY = ev.clientY - oDiv.offsetTop; document.onmousemove=fnMove; document.onmouseup=fnUp; return false; &#125; function fnMove(ev)&#123; var ev = ev || window.event; oDiv.style.left = ev.clientX - disX + 'px'; oDiv.style.top = ev.clientY - disY + 'px'; &#125; function fnUp()&#123; document.onmousemove=null; document.onmouseup=null; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 拖拽之面向对象the first thing you should to know is all of the “this” in oop stands obj not dom. 编写原则：全局变量就是属性；函数就是方法；onload 中创建对象；改 this 指向问题，面向对象都是关于”对象”的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #div1&#123;width: 100px;height: 100px;background: red;position: relative;&#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt;&lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; window.onload=function()&#123; var d1 = new Drag('div1'); d1.init(); &#125;; function Drag(id)&#123; this.oDiv = document.getElementById(id); this.disX = 0; this.disY = 0; &#125; Drag.prototype.init = function()&#123; var This = this; this.oDiv.onmousedown=function(ev)&#123; //event只能出现在事件函数中 var ev = ev || window.event; This.fnDown(ev); //出现在事件函数中,阻止默认事件 return false; &#125; &#125; Drag.prototype.fnDown = function(ev)&#123; //event只能出现在事件函数中 //当你嵌套了一层之后,这个函数就不再是事件函数了 //只有和事件相连接的函数才叫事件函数 // var ev = ev || window.event; var This = this; this.disX = ev.clientX - this.oDiv.offsetLeft; this.disY = ev.clientY - this.ODIV.offsetTop; document.onmousemove=function(ev)&#123; //event只能出现在事件函数中 //onmousemove 没有被嵌套在事件函数中，所以它仍然是一个事件函数 var ev = ev || window.event; This.fnMove(ev); &#125; document.onmouseup=this.fnUp; &#125; Drag.prototype.fnMove = function(ev)&#123; //fnMove 被嵌套在事件函数中，所以它不再是事件函数 // var ev = ev || window.event; this.oDiv.style.left = ev.clientX - this.disX + 'px'; this.oDiv.style.top = ev.clientY - this.disY + 'px'; &#125; Drag.prototype.fnUp = function()&#123; document.onmousemove=null; document.onmouseup=null; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"面向对象&组件开发","slug":"面向对象-组件开发","permalink":"http://ijiangnanbei.com/tags/面向对象-组件开发/"}]},{"title":"控制多个选项卡自动播放","date":"2016-12-21T07:33:21.000Z","path":"2016/12/21/控制多个选项卡自动播放/","text":"我们使用组件开发的好处就是可以根据不同的需求，快速的做出可扩展可复用的组件，提高团队协同开发的效率。 在下面的这个例子中，我复用原来的组件，在原来的组件的基础上扩展出了一个可自动播放的功能： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; input&#123;padding: 0;width: 20px;height: 30px;&#125; .active&#123;background-color: red;&#125; #tab1 div&#123;width: 300px;height: 250px;position: relative;border: 1px solid;display: none;&#125; #tab2 div&#123;width: 300px;height: 250px;position: relative;border: 1px solid;display: none;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"tab1\"&gt; &lt;input type=\"button\" value=\"1\" class=\"active\"&gt; &lt;input type=\"button\" value=\"2\"&gt; &lt;input type=\"button\" value=\"3\"&gt; &lt;div style=\"display: block\"&gt;111&lt;/div&gt; &lt;div&gt;222&lt;/div&gt; &lt;div&gt;333&lt;/div&gt;&lt;/div&gt;&lt;div id=\"tab2\"&gt; &lt;input type=\"button\" value=\"1\" class=\"active\"&gt; &lt;input type=\"button\" value=\"2\"&gt; &lt;input type=\"button\" value=\"3\"&gt; &lt;div style=\"display: block\"&gt;111&lt;/div&gt; &lt;div&gt;222&lt;/div&gt; &lt;div&gt;333&lt;/div&gt;&lt;/div&gt;&lt;script&gt;function Tab(id) &#123; this.doc = document; this.tab = this.doc.getElementById(id); this.aBtn = this.tab.getElementsByTagName('input'); this.aDiv = this.tab.getElementsByTagName('div'); this.iNow = 0;&#125;Tab.prototype.init = function() &#123; var This = this; for(var i=0,len=this.aBtn.length; i&lt;len; i++) &#123; this.aBtn[i].index = i; this.aBtn[i].onclick = function() &#123; This.change(this); &#125; &#125;&#125;Tab.prototype.change = function(obj) &#123; for(var j=0,len=this.aBtn.length; j&lt;len; j++) &#123; this.aBtn[j].className = ''; this.aDiv[j].style.display = 'none'; &#125; this.aBtn[obj.index].className = 'active'; this.aDiv[obj.index].style.display = 'block';&#125;Tab.prototype.autoplay = function() &#123; var This = this; setInterval(function()&#123; for(var i=0,len=This.aBtn.length; i&lt;len; i++) &#123; This.aBtn[i].className = ''; This.aDiv[i].style.display = 'none'; &#125; This.aBtn[This.iNow].className = 'active'; This.aDiv[This.iNow].style.display = 'block'; This.iNow++; This.iNow &gt; 2 ? This.iNow = This.iNow % This.aBtn.length : This.iNow; &#125;,500)&#125;var tab1 = new Tab('tab1');tab1.init(); var tab2 = new Tab('tab2');// 复用原来的组件tab2.init();// 在原来的组件基础上，增加自动播放功能tab2.autoplay();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果展示","tags":[{"name":"面向对象&组件开发","slug":"面向对象-组件开发","permalink":"http://ijiangnanbei.com/tags/面向对象-组件开发/"}]},{"title":"this指向","date":"2016-12-20T07:33:21.000Z","path":"2016/12/20/this指向/","text":"能清楚的知道 this 的指向，对于编写面向对象的程序来说是至关重要的。下面我们来看两个小例子： 1.第一个例子12345oDiv.onclick = show;function show()&#123; // 此时 this 指向 oDiv;&#125; 2.第二个例子1234567oDiv.onclick = function()&#123; show();&#125;function show()&#123; // 这个时候 this 指向 window&#125; 对于 this 指向，我们在编写面向对象程序的时候要记住，在事件处理程序和定时器事件中，this 的指向会发生改变。","tags":[{"name":"面向对象&组件开发","slug":"面向对象-组件开发","permalink":"http://ijiangnanbei.com/tags/面向对象-组件开发/"}]},{"title":"传统选项卡和面向对象选项卡的编写","date":"2016-12-17T07:33:21.000Z","path":"2016/12/17/传统选项卡和面向对象选项卡的编写/","text":"1.传统方式编写选项卡123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123;margin: 0;padding: 0&#125; #box&#123; height: 100px; width: 250px; margin: 50px auto; &#125; #box input[type=button]&#123; width: 20px; height: 20px; &#125; #box .backcolor&#123; background-color: red; &#125; #container&#123; width: 250px; height: 100px; &#125; #container div&#123; width: 250px; height: 100px; border: 1px solid; position: absolute; display: none; &#125; #container .active&#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"box\"&gt; &lt;input type=\"button\" value=\"1\" class=\"backcolor\"&gt; &lt;input type=\"button\" value=\"2\"&gt; &lt;input type=\"button\" value=\"3\"&gt; &lt;div id=\"container\"&gt; &lt;div class=\"active\"&gt;111&lt;/div&gt; &lt;div&gt;222&lt;/div&gt; &lt;div&gt;333&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324&lt;script type=\"text/javascript\"&gt; var aBtn = document.getElementsByTagName('input'); var oDiv = document.getElementById('container'); var aCon = oDiv.getElementsByTagName('div'); for(var i=0; i&lt;aBtn.length; i++)&#123; aBtn[i].index = i; aBtn[i].onclick = function()&#123; for(var i=0; i&lt;aBtn.length; i++)&#123; aBtn[i].className = ''; aCon[i].style.display = 'none'; &#125; this.className = 'backcolor'; aCon[this.index].style.display = 'block'; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果展示 2.传统选项卡的变形123456789101112131415161718192021222324252627282930313233343536373839&lt;script type=\"text/javascript\"&gt; /** * 变形方法: * 尽量不要出现函数嵌套 * 可以有全局变量 * 把 onload 中不是赋值的语句放到单独的函数中 */ //全局变量 var aBtn = null; var oDiv = null; var aCon = null; window.onload = function()&#123; aBtn = document.getElementsByTagName('input'); oDiv = document.getElementById('container'); aCon = oDiv.getElementsByTagName('div'); init(); &#125; function init()&#123; for(var i=0; i&lt;aBtn.length; i++)&#123; aBtn[i].index = i; aBtn[i].onclick = change; &#125; &#125; function change()&#123; for(var i=0; i&lt;aBtn.length; i++)&#123; aBtn[i].className = ''; aCon[i].style.display = 'none'; &#125; this.className = 'backcolor'; aCon[this.index].style.display = 'block'; &#125;&lt;/script 效果展示 3.用面向对象封装传统选项卡1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script type=\"text/javascript\"&gt; /** * 改成面向对象 * 全局变量就是属性 * 函数就是方法 * onload中创建对象 * 改this指向问题--&gt;面向对象都是关于\"对象\"的 */ var aBtn = null; var oDiv = null; var aCon = null; function Tab()&#123; //全局变量就是属性,是对象的属性,这个时候对象就是 this this.aBtn = document.getElementsByTagName('input'); this.oDiv = document.getElementById('container'); this.aCon = this.oDiv.getElementsByTagName('div'); &#125; Tab.prototype = &#123; //函数就是方法 init : function()&#123; var This = this; for(var i=0; i&lt;this.aBtn.length; i++)&#123; this.aBtn[i].index = i; this.aBtn[i].onclick = function()&#123; //'This' is obj,'this' is aBtn This.change(this); &#125; &#125; &#125;, change : function(obj)&#123; //尽量让面向对象中的 this 指向对象 for(var i=0; i&lt;this.aBtn.length; i++)&#123; this.aBtn[i].className = ''; this.aCon[i].style.display = 'none'; &#125; obj.className = 'backcolor'; this.aCon[obj.index].style.display = 'block'; &#125; &#125; var t1 = new Tab(); t1.init(); &lt;/script&gt; 效果展示","tags":[{"name":"面向对象&组件开发","slug":"面向对象-组件开发","permalink":"http://ijiangnanbei.com/tags/面向对象-组件开发/"}]},{"title":"工厂模式之原型","date":"2016-12-15T07:33:21.000Z","path":"2016/12/15/工厂模式之原型/","text":"我们创建的每一个函数都有一个 prototype 属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。1234567891011121314151617&lt;script type=\"text/javascript\"&gt; //能够共享的放在构造函数里面 function CreatePerson(name)&#123; this.name=name; &#125; //不能够共享的放在原型里面 CreatePerson.prototype.showName=function()&#123; alert(this.name); &#125; var p1 = new CreatePerson('xiaoming'); var p2 = new CreatePerson('xiaoqiang'); alert(p1.showName == p2.showName);//true--&gt;they have same address. //这就是原型模式和构造函数模式的不同之处，即这些属性和方法是由所有实例共享的&lt;/script&gt; 原型模式的写法：1234567891011121314151617181920&lt;script type=\"text/javascript\"&gt; // function 构造函数() // &#123; // this.属性; // &#125; function construct()&#123; this.property &#125; // 构造函数.原型.方法 = function()&#123;&#125; construct.prototype.method=function()&#123;&#125; // var 对象1 = new 构造函数(); var obj1 = new construct(); // 对象1.方法(); obj1.method();&lt;/script&gt;","tags":[{"name":"面向对象&组件开发","slug":"面向对象-组件开发","permalink":"http://ijiangnanbei.com/tags/面向对象-组件开发/"}]},{"title":"普通方法与原型方法","date":"2016-12-14T07:33:21.000Z","path":"2016/12/14/普通方法与原型方法/","text":"1.普通方法1234567891011121314151617181920212223242526&lt;script type=\"text/javascript\"&gt; var arr1 = [1,2,3,4,5]; var arr2 = [2,2,2,2,2]; arr1.sum = function()&#123; var result = 0; for(var i=0;i&lt;this.length;i++)&#123; result+=this[i]; &#125; return result; &#125; alert(arr.sum()); arr2.sum = function()&#123; var result = 0; for(var i=0;i&lt;this.length;i++)&#123; result+=this[i]; &#125; return result; &#125; alert(arr2.sum());&lt;/script&gt; 从上面的例子可以看出，对于普通方法而言我们要对每一个对象分别创建一个方法。 2.原型方法123456789101112131415161718&lt;script type=\"text/javascript\"&gt; var arr = [1,2,3,4,5]; var arr2 = [2,2,2,2,2]; //使用原型方法这个时候你只需要借用构造函数创建一个函数 Array.prototype.sum = function()&#123; var result = 0; for(var i=0;i&lt;this.length;i++)&#123; result+=this[i]; &#125; return result; &#125; alert(arr.sum()); alert(arr2.sum());&lt;/script&gt; 3.普通方法和原型方法的优先级比较123456789&lt;script type=\"text/javascript\"&gt; var arr = []; arr.number = 10; Array.prototype.number = 20; alert(arr.number); //result : 10 //从中我们可以看出，普通方法的优先级高于原型方法&lt;/script&gt;","tags":[{"name":"面向对象&组件开发","slug":"面向对象-组件开发","permalink":"http://ijiangnanbei.com/tags/面向对象-组件开发/"}]},{"title":"理解对象的引用","date":"2016-12-13T07:33:21.000Z","path":"2016/12/13/理解对象的引用/","text":"1.实例一123456789101112131415&lt;script type=\"text/javascript\"&gt; function CreatePerson(name)&#123; this.name=name; this.showName=function()&#123; alert(this.name); &#125; &#125; var p1 = new CreatePerson('xiaoming'); var p2 = new CreatePerson('xiaoqiang'); alert(p1.showName == p2.showName);//false //由于对对象的引用不同，所以这里的结果是 false&lt;/script&gt; 2.实列二1234567&lt;script type=\"text/javascript\"&gt; var a = [1,2,3]; var b = [1,2,3]; // they have the same value but different addresses alert(a == b);//false&lt;/script&gt; 3.实例三123456789&lt;script type=\"text/javascript\"&gt; var a = [1,2,3]; var b = a; b.push(4); alert(b);//[1,2,3,4] alert(a);//[1,2,3,4] alert(a == b);//ture--&gt;same address&lt;/script&gt; 4.实例四12345678&lt;script type=\"text/javascript\"&gt; var a = [1,2,3]; var b = a; //只要你重新声明了一个变量，在内存里就会有一块新的空间被创建 b = [1,2,3,4]; alert(b);//[1,2,3,4]; alert(a);//[1,2,3] &lt;/script&gt;","tags":[{"name":"面向对象&组件开发","slug":"面向对象-组件开发","permalink":"http://ijiangnanbei.com/tags/面向对象-组件开发/"}]},{"title":"构造函数模式","date":"2016-12-11T07:33:21.000Z","path":"2016/12/11/构造函数模式/","text":"1234567891011121314151617181920212223&lt;script type=\"text/javascript\"&gt; //构造函数首字母始终都应该以一个大写字母开头 //构造函数本身也是函数，只不过可以用来创建对象 function Person(name)&#123; //'this' 在这里代表着 p1 或 p2 this.name=name; this.showName=function()&#123; alert(this.name); &#125; &#125; // p1 和 p2 分别保存着 Person 的一个不同实列，这两个对象都有一个 constructor 属性，该属性指向 Person。 var p1 = new Person('xiaoming'); p1.showName(); var p2 = new Person('xiaoqiang'); p2.showName(); //创建自定义的构造函数意味着可以将他的实例标识为一种特定的类型 //而这正是构造函数模式胜过工厂模式的地方&lt;/script&gt; 构造函数模式虽然好用，但也并非没有缺点，使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍，即每个 person 实例都包含一个不同的 function 实例，因此不同实例上的同名函数是不相同的。 然而创建两个完成同样任务的 function 实例的确没有必要。于是，又出现了原型模式帮我们解决这个问题。","tags":[{"name":"面向对象&组件开发","slug":"面向对象-组件开发","permalink":"http://ijiangnanbei.com/tags/面向对象-组件开发/"}]},{"title":"工厂模式","date":"2016-12-10T07:33:21.000Z","path":"2016/12/10/工程模式/","text":"12345678910111213141516171819202122232425&lt;script type=\"text/javascript\"&gt; //工厂模式其实就是封装函数 //为什么我们要叫他工厂模式呢?答案在下面: function createPerson(name)&#123; //原料 var obj = new Object(); //制作加工 obj.name=name; obj.showName=function()&#123; alert(this.name); &#125; //产生结果 return obj; &#125; var p1 = createPerson('xiaoming'); p1.showName(); var p2 = createPerson('xiaoqiang'); p2.showName(); &lt;/script&gt; 工厂模式虽然解决了创建多个相似对象的问题,但是却没有解决对象识别的问题,即怎样知道一个对象的类型,于是又出现了构造函数模式。","tags":[{"name":"面向对象&组件开发","slug":"面向对象-组件开发","permalink":"http://ijiangnanbei.com/tags/面向对象-组件开发/"}]},{"title":"面向对象简介","date":"2016-12-09T07:30:27.000Z","path":"2016/12/09/面向对象简介/","text":"1.面向过程式写法123456&lt;script type=\"text/javascript\"&gt; //面向过程的写法 function test()&#123;&#125; for()&#123;&#125; if()&#123;&#125;&lt;/script&gt; 2.面向对象式写法123456789101112131415&lt;script type=\"text/javascript\"&gt; /** * we are always using obj,such as array and date. * this two guys are system obj. */ var arr = new Array(); var date = new Date(); //propertise and methods arr.length; arr.push(); arr.sort(); date.getDate();&lt;/script&gt; 3.面向对象的组成123456789101112131415&lt;script type=\"text/javascript\"&gt; var arr = []; //obj property arr.number=10; alert(arr.length); arr.test=function()&#123; alert(123); &#125; //obj method arr.test();&lt;/script&gt; 第一个面向对象程序1234567891011&lt;script type=\"text/javascript\"&gt; var obj = &#123;&#125; // this sentence is same as the above. var obj = new Object();//空对象 obj.name='xiaoming'; obj.showName=function()&#123; //the key of oop is to figure out \"this\" is what. alert(this.name); &#125; obj.showName();&lt;/script&gt;","tags":[{"name":"面向对象&组件开发","slug":"面向对象-组件开发","permalink":"http://ijiangnanbei.com/tags/面向对象-组件开发/"}]},{"title":"详解闭包","date":"2016-12-08T06:42:49.000Z","path":"2016/12/08/详解闭包/","text":"什么是闭包？简单点说，闭包就是函数嵌套函数，其中内部函数可以引用外部函数的参数和变量。 1234567891011function aaa(a)&#123; var b = 5; function bbb()&#123; alert(a); alert(b); &#125;&#125;var bbb = aaa(3);bbb();//result : 3 5 垃圾回收机制 垃圾回收机制：在闭包的情况下,参数 a 和 变量 b 是不会被垃圾回收机制回收的，因为内部的闭包还在引用着外部的变量。123456//js 中的垃圾回收机制function aaa()&#123; var a = 1;&#125;//当这个函数调用完了之后,函数里面的变量就会被垃圾回收机制回收aaa(); 123456789101112131415//垃圾回收机制测试function aaa()&#123; var a = 5; function bbb()&#123; alert(a); &#125; return bbb;&#125;// aaa 函数已经执行完毕了,这个时候 c 代表的是 bbb 这个函数var c = aaa();//这里执行的其实是bbb();c();// result : 5//由上述的结果可知：闭包内的变量并不会被垃圾回收机制回收 作用一：模块化代码闭包可以做到私有成员，私有方法，减少全局变量的污染来达到你想要的效果。123456789var a = 1;function aaa()&#123; a++; alert(a);&#125;aaa();//2aaa();//3//在这里 a 是全局变量所以我们可以在函数内部使其自增 12345678910//如果我们把 a 变成一个局部变量function aaa()&#123; var a = 1; a++; alert(a);&#125;aaa();//2aaa();//2//在这里 a 只是函数内部的一个局部变量，当我们调用函数的时候不能实现其自增。 如何做到让 a 既是局部变量同时我们在外部调用的时候让 a 又可以累加?这就是我们的闭包可以做到的。 写法一：12345678910111213function aaa()&#123; var a = 1; return function ()&#123; a++; alert(a); &#125;&#125;var c = aaa();c();//2c();//3//可以看到当我们在使用闭包的写法的时候，可以做到让 a 既是局//部变量同时在外部调用函数时，又可以实现其累加 写法二：(改写为函数声明)123456789//改写为函数声明(function ()&#123; var a = 1; return function ()&#123; a++; alert(a); &#125;&#125;)()(); 也可以像下面这样改写：1234567891011var aaa = function ()&#123; var a = 1; return function ()&#123; a++; alert(a); &#125;&#125;();aaa();//2aaa();//3//这就是模块化代码，通过减少全局变量的污染来达到想要的效果 模块化代码模型12345678910111213141516171819202122var aaa = function()&#123; //局部变量 var a = 1; //私有方法 function bbb()&#123; a++; alert(a); &#125; //私有方法 function ccc()&#123; a++; alert(a); &#125; return &#123; b : bbb, c : ccc &#125;&#125;();aaa.b();//2aaa.c();//3 作用二：在循环中直接找到对应元素的索引不需要再加索引12345678910111213141516171819&lt;ul&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt;&lt;/ul&gt;window.onload = function()&#123; var aLi = document.getElementsByTagName('li'); for(var i=0; i&lt;aLi.length; i++)&#123; aLi[i].onclick = function()&#123; alert(i);//3 //为什么这里会弹出3 因为当循环执行结束的时候,这个事件其实还没有执行,只有当我//们触发的时候,它才会执行,但是当我们去点的时候,这个 for 循环已经结束了,这个//时候 i 已经变成3了,所以不管你触发哪一个li最终弹出来的都是3 &#125; &#125; &#125; 用闭包来解决这个问题：(第一种写法)12345678910111213window.onload = function()&#123; var aLi = document.getElementsByTagName('li'); //第一种写法 for(var i=0; i&lt;aLi.length; i++)&#123; (function(i)&#123; aLi[i].onclick = function()&#123; alert(i); &#125; &#125;)(i); &#125; &#125; 用闭包来解决这个问题：(第二种写法)12345678910111213141516171819window.onload = function()&#123; var aLi = document.getElementsByTagName('li'); //第二种写法 for(var i=0; i&lt;aLi.length; i++)&#123; //当你点击的时候,我这个里面已经执行完毕了,所以这个 i 已经 //驻扎在内部了,所以点击的时候,你调用的 i 是内部的函数已经 //存在内存中的 i了,而不是外面的 i aLi[i].onclick = (function(i)&#123; return function()&#123; alert(i); &#125; &#125;)(i); &#125;&#125; 注意事项：内存泄漏在 ie 下使用闭包会引发内存泄漏。 引发内存泄漏的条件：当一个变量，这个变量是由获取一个 dom节点，或者是一个宿主对象的时候，他的一个属性，比如说 onclick 去引用一个内部函数,而这个内部函数又去引用外部的对象，这个时候就会造成内存泄漏。即 ie 下的 js互相引用会造成内存泄漏。123456789101112131415161718192021&lt;body&gt;&lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;script&gt;window.onload = function()&#123; var oDiv = document.getElementById('div1'); oDiv.onclick = function()&#123; alert(oDiv.id); &#125; //就是这个简单的程序可能会造成 ie 下的内存泄漏，如果内存泄漏的//话，当你页面跳转的时候，变量不会释放，一直存在于内存中,使你//的 cpu 在累加，大大降低了浏览器的性能，只有当你关闭浏览器的//情况下才能释放内存。&#125;&lt;/script&gt;&lt;/body&gt; 解决方法如下：123456789101112131415161718192021&lt;body&gt;&lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;window.onload = function()&#123; var oDiv = document.getElementById('div1'); oDiv.onclick = function()&#123; alert(oDiv.id); &#125; //解决方法: window.onunload = function()&#123; oDiv.onclick = null; &#125;&#125;&lt;/script&gt;&lt;/body&gt; 第二种解决方案：1234567891011121314151617181920212223&lt;body&gt;&lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var oDiv = document.getElementById('div1'); //第二种解决方法:在外部建一个变量引用一下 var id = oDiv.id; oDiv.onclick = function()&#123; alert(oDiv.id); &#125; //调用完之后还要把这个对象置空 oDiv = null; &#125;&lt;/script&gt;&lt;/body&gt;","tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://ijiangnanbei.com/tags/前端开发/"}]},{"title":"The tip point of programming","date":"2016-12-05T03:22:38.000Z","path":"2016/12/05/The-tip-point-of-programming/","text":"123456789101112131415161718192021222324if(0&lt;=i &amp;&amp; i&lt;=9)&#123; oLi[i].style.top='0px'; oLi[i].style.left=10+(i%10)*110+'px';&#125;if(10&lt;=i &amp;&amp; i&lt;=19)&#123; oLi[i].style.top='100px'; oLi[i].style.left=10+(i%10)*110+'px';&#125;if(20&lt;=i &amp;&amp; i&lt;=29)&#123; oLi[i].style.top='200px'; oLi[i].style.left=10+(i%10)*110+'px';&#125;if(30&lt;=i &amp;&amp; i&lt;=39)&#123; oLi[i].style.top='300px'; oLi[i].style.left=10+(i%10)*110+'px';&#125;if(40&lt;=i &amp;&amp; i&lt;=49)&#123; oLi[i].style.top='400px'; oLi[i].style.left=10+(i%10)*110+'px';&#125; 123456for(var j=0;j&lt;10;j++)&#123; if((j*10+0)&lt;=i &amp;&amp; i&lt;=(j*10+9))&#123; oLi[i].style.top=j*110+50+'px'; oLi[i].style.left=10+(i%10)*110+'px'; &#125; &#125; above is my track!!!wow, I get the point of programming, from easy to difficult,form clear to confusion,step by step, you can do it.escapeically, you can keep trying.","tags":[{"name":"编程思想","slug":"编程思想","permalink":"http://ijiangnanbei.com/tags/编程思想/"}]},{"title":"祸从口出","date":"2016-12-05T01:39:59.000Z","path":"2016/12/05/沉默是金/","text":"读书笔记：《世说新语》 有道是”沉默是金”，在谈怎么说话之前，我、先得谈怎么不说。因为祸从口出，常常不说要比说好得多。 举个我自己的例子，有一天我跟朋友约好中午碰面，因为办公室忙，出门晚了些，对方着急了，又不知道我的手机号码，就拨电话到办公室问。电话是我秘书接的，她挺聪明，说”刘先生早出门了，应该在路上，马上就到了。” 你说，她不是答得很好吗？偏偏她画蛇添足，又加一句：”刘先生很忙的！” 我那朋友一听就火了，回一句：”他忙？我不忙吗？”跟着就看我进门了，又把那火发到我头上：”你秘书说你忙，好像你迟到有理似的，你要知道我也忙耶！” 你说我那秘书笨不笨？我又倒霉不倒霉？ 事实上，我的秘书非常聪明。而在讲话的时候爱画蛇添足的人常常很聪明。 再举个大家常碰到或常犯的毛病。 你是职员，老板问你今天客户一共叫了几箱货。 常一天有一百多箱，那天特别少，只叫了十箱。你是不是很可能答：”报告老板，今天只叫了十箱耶！” 你现在想，一定觉得这样说没什么错。但我要很郑重地告诉你：如果你只是个小职员，小主管，你错了！除非你是合伙人、大主管、或老板娘，你最好不要说”今天”只”叫了十箱。”而应该讲”今天叫了十箱。甚至我得叮嘱你，就算你是大主管，或老板娘，你最好也说：”叫了十箱。” 为什么？因为你不是老板，你应该先客观的把事实数字告诉他，下面他要跳起来，或大吼：”什么？才叫十箱？怎么搞的？”都是他的事，你没有资格用你的主观去影响他。 ? 没错！你不能影响他！ 在心理学上有个实验──给许多人看一段车祸的影片，然后一个一个分开问他们那车祸的情況。当问的人用：”请您回忆一下那意外的情況。”或”请您回忆一下那车祸的情況。”又或者”请您回忆一下那惨剧的情況。”因为使用”意外”、”车祸”、”惨剧”的词的不同，会造成那些答话的人很不一样的形容。 连小孩都一样！我们都认为小孩最诚实了吧！但是据实验，如果你让一个陌生人在幼稚园教室里走一圈就出去。然后问小朋友对刚才那个”好可爱的叔叔”，或刚才那个”怪叔叔”的印象的时候，可能得到很不一样的答案。为什么？因为你给了引导。 同样的道理，当老板问你情況，你要先冷靜地、客观地答事情，不能先加入自己的好恶意见。平常客户一叫货就是一百箱，今天叫十箱，跳不跳起来，冒不冒火，或要不要哭，要不要开会检讨，是老板的事，你要交给老板去思考。 或许你说你就是老板，也有这样的职员，你不觉得不好，甚至觉得职员这么说，是跟公司一个鼻孔出气，是荣辱与共。 对不起！你错了。要知道，当小职员说”某某讨厌的客户今天来过。”或”某某分店今天才卖了三样东西”的时候，他显然是帮你这个老板反应，甚至要指导你反应，好像说完就要看你露出厌恶的表情或火冒三丈。 对一个有纪律的公司，对一个领道者，或对一个需要作出正确判断的领道阶层，作下属的都应该先提供客观的事实。 知道了这一些，如果你是职员、小主管，下次你老板问你情況，我建议你先冷靜地告诉他实情，千万别添油加醋，甚至火还没起，你就先加油。相对的，如果你是老板，碰上这种爱添油加醋的职员，你也要纠正，说”今天叫货叫的是多还是少，由我来判断，请你们以后不要添加这些形容词。","tags":[{"name":"貌似有知识","slug":"貌似有知识","permalink":"http://ijiangnanbei.com/tags/貌似有知识/"}]},{"title":"弱者的逻辑","date":"2016-12-01T23:47:40.000Z","path":"2016/12/02/弱者的逻辑/","text":"你刚来到城市，你跟那些大公司比，当然是它强你弱，但是你们之间不是博弈关系，你是拿自己的目标参与到它的事业里面去，如果你的目标只是每个月挣点钱，那好，你打一辈子工好了，你可能给了中国的大城市一辈子也买不起房，但是如果你参与到这个过程中，公司有公司的目标，你有你的目标，你们两个目标在一起博弈，我帮你公司实现业务的增长，你帮我实现个成长，我在这里学习业务，展示给整个市场看我的业务能力，渐渐地没准我的个人地位在社会上就成长了，没准将来我还创业呢。 人和人、国家和国家，本质上是目标的博弈，而不是力量博弈。 人和人、国家和国家的互动，是谁的目标好，谁的目标能够拆解为适宜的步骤，而且执行的好，谁赢！本质上说，这不是力量上的博弈，二是目标的博弈。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"jQuery入门","date":"2016-12-01T09:35:31.000Z","path":"2016/12/01/jQuery入门/","text":"选择元素原生选择符 1.标签选择符 $(&#39;p&#39;) 2.ID 选择符 $(&#39;#some-id&#39;) 3.类选择符 $(&#39;.some-class&#39;) 4.否定式伪类选择符 $(&#39;#some-id li:not(.some-class)&#39;) 5.属性选择符$(&#39;img[alt]&#39;),属性选择符使用一种从正则表达式借鉴来的通配符语法，以 ^ 表示值在字符串的开始位置，以 $ 表示值在字符串的结尾，用 * 号表示要匹配的值可以出现在字符串的任意位置，用叹号 ! 表示对值取反。 eg：$(&#39;a[href^=&quot;mailto:&quot;]&#39;)选中所有电子邮件的链接。$(&#39;a[href$=&quot;.pdf&quot;]&#39;)选中所有pdf文件的链接。 属性选择符也可以组合使用，例如，可以为 href属性以 http 开头且任意位置包含 henry 的所有链接 $(&#39;a[href^=&quot;http&quot;][href*=&quot;henry&quot;]&#39;) 自定义选择符jquery 中的多数自定义选择符都可以让我们从已经找到的元素中选出一个或多个元素。自定义选择符通常跟在一个 css 选择符的后面，基于已经选择的元素集的位置来查找元素。自定义选择符的语法与 css 中的伪类选择符语法相同，即选择符以冒号（:）开头。 例如。我们想要选取带 class 伪类的 div 集合中的 第2项，那么应该使用以下的代码：$(&#39;div.class:eq(1)&#39;) 注意：js 中的数组采用的是从 0 开始的编号方式，所以 eq(1) 取得是集合中的第二个元素。而 css 则是从 1 开始的，因此 css 选择符 $(&#39;div:nth-child(1)&#39;) 取得的是作为其父元素第一个子元素的所有 div 元素，nth-child() 可以接受 odd 或者是 even 为参数。eq() ,:odd和 :even 都使用js 内置从 0 开始的编号方式。所以如果你想选择一个表格中的所有偶数行可以这样写: $(&#39;tr:even&#39;)（注意，这里是 even 而不是 odd） 基于上下文的内容选择元素$(&#39;td:contains(hello)&#39;) 所有单元格中的 hello 字段都会被选中。 基于表单的选择符123456789:input 输入字段、文本区、选择列表和按钮元素:button 按钮元素或 type 属性值为 button 的输入元素:enabled 启用的表单元素:disabled 禁用的表单元素:checked 勾选的单选按钮或复选框:selected 选择的选项元素$('input[type=\"radio\"]:checked')$('input[type=\"password\"],input[type=\"text\"]:disabled') DOM方法DOM 遍历方法给所有的外部链接添加一个类123456$('a').filter(function()&#123; return this.hostname &amp;&amp; this.hostname != location.hostname;&#125;).addClass('class');// 我们可以利用 .filter() 方法，向其中传入筛选函数，利用// jquery的隐式迭代能力，得到我们想要的结果。 .next() 和 .nextAll().next() 方法只选择下一个最接近的同辈元素。.nextAll() 会选出后面所有的同辈元素。 这两者分别有一个对应的方法，即.pre() 和.preAll() .siblings().siblings() 能够选择处于相同dom 层次的所有其他元素，无论这些元素处于当前元素之前还是之后。 .addBack()$(&#39;.class&#39;).next().addBack(); 不仅可以包含当前元素还可以包含当前元素的下一个元素。 连缀1234567$('td:contains(hello)').parent().find('td:eq(1)').addClass('class').end() // 恢复到包含 hello 的单元格的父元素.find('td:eq(2)').addClass('class') 访问 dom 元素如果想知道带有 id=&quot;ele&quot; 属性的元素的标签名，可以使用下面的方法：$(&#39;#ele&#39;)[0].tagName;，可以在选择符后面直接使用方括号。 事件在页面加载后执行任务引用函数与调用函数将函数指定为事件处理程序时，如果带着圆括号，函数会被立即调用；没有圆括号，函数名就只是函数的标识符或函数引用，可以用于在将来在调用函数。 .ready()方法1一：$().ready()方法支持我们预定在dom加载完成之后调用某个函数，而不必等待页面中的图像加载。同时他为我们提供了很好的跨浏览器解决方案：1.尽可能使用浏览器的原生的 dom 实现就绪，并以 window.onload 事件处理程序作为后备。2.可以多次调用并按照调用他们的顺序执行3.即便是在浏览器事件发生之后把函数传给 $().ready() ，这些函数也会执行4.异步处理事件的约定，必要时脚本可以延迟执行5.通过重复检查一个几乎与 dom 同时可用的方法，在较早版本的浏览器中模拟 dom 就绪事件6.ready()方法的参数可以是一个已经定义好的函数的引用 $().ready(function(){ }) 这种匿名写作的函数在 jquery 中十分方便，特别适合传递那些不会被重用的函数。而且与此同时创建的闭包也是一种非常高级和强大的工具。但是，加入处理不当的话，闭包也会给我们带来意想不到的后果和内存占用问题。 什么是加载完成？一般来说使用$(document).ready()要优于使用onload 事件处理程序，但必须要明确的一点是，因为支持文件可能还没有加载完成，所以类似图像的高度和宽度这样的属性此时不一定会有效。如果需要访问这些属性，可能就得选择一个onload事件处理程序（或者是使用jquery为load事件设置处理程序）这两种机制能够和平共存。 避免$命名冲突由于很多库都使用$标识符，因此就需要一种方式来避免名称冲突。jquery提供了一种加jQuery.noConflict()方法，调用该方法可以把对$标识符的控制权让渡还给其他库。 123456&lt;script src=\"prototype.js\"&gt;&lt;/script&gt;&lt;script src=\"jquery.js\"&gt;&lt;/script&gt;&lt;script&gt;jQuery.noConflict();&lt;/script&gt;&lt;script src=\"myscript.js&gt;&lt;/script&gt; 调用jQuery.noConflict();，可以将控制权交还给最先包含的库（prototype.js），这样就可以在自定义脚本中使用两个库了，但是，在需要使用jquery方法时，必须要记住要用jQuery而不是用$来调用。 123jQuery(document).ready(function($)&#123;// 我们可以在函数内部将jQuery重命名为$，而不必担心造成冲突。&#125;); 样式转换器demo 2.事件传播1..hover()方法.hover() 接受两个函数参数，第一个函数会在鼠标指针进入被选择的元素时执行，而第二个函数会在鼠标指针离开该元素时触发。同时，使用.hover()一意味着可以避免js 中的事件传播导致的头痛问题。123$(document).ready(function()&#123; $('class').hover(function()&#123;&#125;,function()&#123;&#125;);&#125; 2.事件的旅程123456&lt;div&gt; &lt;span&gt; &lt;a&gt; &lt;/a&gt; &lt;/span&gt;&lt;/div&gt; 事件捕获：事件首先交给最外层的元素，接着在交给更具体的元素，即-&gt;-&gt; 事件冒泡：当事件发生时，首先交给最具体的元素，在这个元素获得响应机会之后，事件会向上冒泡到更一般的元素。即：-&gt;-&gt; 为了全包跨浏览器的一致性，而且也为了让人更容易理解，jquery会始终的事件的冒泡阶段注册事件处理程序。因此，我们总是可以假定最具体的元素会首先获得响应事件的机会。 3.事件冒泡的副作用事件冒泡可能会导致始料不及的行为，特别是在错误的元素响应mouseover或者mouseout事件的情况下。假设在我们这个例子中，为注册了一个mouseout事件处理程序，当用户的鼠标指针退出这个时，会按照预期运行mouseout事件处理程序。因为这个过程发生在顶层元素上，所以其他的元素不会取得这个事件。但是，当指针从元素上离开时，元素回取得一个mouseout事件。然后这个事件会向上冒泡到和，从而触发事件处理程序。这种冒泡序列不是我们所希望的。 mouseenter和moseleave事件，无论是单独绑定，还是在.hover()方法中组合绑定，都可以避免这些冒泡问题。","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://ijiangnanbei.com/tags/jQuery/"}]},{"title":"最高级的想象力是不自由的","date":"2016-11-30T23:44:24.000Z","path":"2016/12/01/最高级的想象力是不自由的/","text":"我想很多人对于想象力都有一个这样的认识：想象力和知识是天敌，人在获得知识的过程中，想象力会消失。 但是一个没有知识的人能够想象的出什么东西呢？看似自由的想象，背后都有其借鉴的根源，而这个“根源”其实就是那些深深地扎在你的大脑中的知识。 玩过lol的人都知道，在这个游戏中你所赚到的钱的速度正好足够你购买相应等级的物品，否则就会出现“通货膨胀”或者“通货紧缩”。《英雄联盟》为此专门聘请了经济学家来进行设计，甚至必须实时的监视系统。 所以，最高级的想象力是不自由的！正是因为其不自由，它的难度才大！","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"}]},{"title":"老罗：我的奋斗","date":"2016-11-29T23:34:58.000Z","path":"2016/11/30/老罗：我的奋斗/","text":"很多时候你生在一个小镇，没有受过良好的教育，也没有什么背景，也没有什么钱，走进社会也没有什么人帮你，所以你可能会感觉你什么都做不了。 但是你有所坚持，不相信前辈们跟你讲的“如果你要怎么样就要怎么样”这些恶心的东西，你坚持做你年轻时候认为是正确的东西，很多时候也会得到一个非常好的结果。 有的鸟来到世间是为了做他该做的事，不是来躲枪子的。很多长辈不断地告诉年轻人说枪打出头鸟，如果他这个忠告有意义，那就是假定所有的鸟都怕被枪打，我们不热衷于被枪杀，但是如果做你正确的事情注定被枪杀，你只能接受这个事实。 所以我就跟他们讲，有的鸟来到世间不是为了躲枪子的，你们是职业躲枪子的，你们这帮傻鸟来到世间就是为了躲枪子的，我呢是为了做我该做的事。如果注定挨枪子就认了，如果不挨枪子我也很高兴，就是这样。 我一直想跟同学们讲的就是，年轻的时候，我们走进这个恶心社会之前，很多人或者说绝大多数人都是正直的，因为这个世界很奇怪，即使是坏人教育孩子的时候也会教育他，长大了要做一个好人。 我就没有见过一个坏蛋教育孩子说你长大了一定要当一个臭流氓，他们做好人咱们做流氓，咱们家就发了。没有见过这么教育孩子的，都是教育孩子要做一个正直的人做一个好人，但是你带着这种想法，年轻的时候每个人都认为自己能改变这个世界，你问他们长大了想做什么，想做飞行员的，想做宇航员的，想做外交官的，都是充满着这种远大的理想主义的志向，很少有人说我想掏大粪我想耍流氓我想办证我想卖壮阳药我想贴电线杆，没有这样的。 但是二十多岁走进社会，越是正直、耿直越是有才华的就会发现，由于自己的耿直20多岁到30岁一事无成，在今天这个普遍恶心的中国社会里，成年人的社会非常的恶心，尽管你有能力有才华一事无成，因为你不会算计不会拍马屁不会见人说人话见鬼说鬼话，而那些狡猾的圆滑世故的年纪轻轻就圆滑世故的让人感到可怕的那帮孩子二十多岁走进社会开始钻营，到了三十岁，过得非常好，家里要什么有什么，二奶奶有六个，就是这样。所以，对于正直的人如果他不是足够坚强是很难坚持下去的，所以我的很多同龄人老朋友老同学到了三十岁一直在挣扎是做一个流氓还是做一个好人挺不下去了，一狠心做了一个流氓。做了一个流氓，如果他们充满了负罪感，我估计过不了多久我还挺乐观的，结果这帮流氓呢一旦产生幻觉，觉得这就是成熟，于是他跟年轻人说，我年轻的时候也像你这样，后来意识到这是不对的，幼稚的。 （他们）就这样毒害下一代，我看了无数这种例子，所以每年我回去的时候，那些大小在一起长大的那种感情和这帮流氓生意人流氓政客，我一回去就很热情，张罗一起吃个饭啊什么的，我就问他们，你们不是娘请的时候都相信能改变世界吗，怎么现在变成这个样子了？然后他们就很尴尬地笑了笑，什么改变世界，那不是小孩的想法吗，别扯了，我们谁也改变不了世界。 我有的时候会忍，有的时候激动了就撕破脸皮和他们说，我说别客气了，你还是改变了世界。你看你看你三十多岁成了一个恶心人，成了这个社会芸芸众生的那些操蛋的人中的一个，你怎么能够说你没有改变世界呢？你已经把世界变得恶心了一点点，因为地球上又多了一个恶心人。 如果你的一生没有做任何伟大的事业，没有赚到钱，也没有出名，但是一生耿直刚正不阿，一辈子没有成就伟大的事业，但是拼着老命把自己老婆孩子家人勉强照顾好了，你的一生有没有改变世界？如果你这样活到了七八十岁没有成就任何伟大事业梗着脖子去世了，有没有改变世界啊，还是有的，因为这个世界又多了一个好人，所以因为你让这个世界变得美好了一点点。 听懂了吗，每一个生命来到时间，都注定会有改变世界的宿命，你别无选择。有的人不服气，说MD我自杀，看我改变不改变世界，你自杀也把这个世界的自杀率提高了一点点，还是改变了世界。 每个人来到世间都注定改变世界没有一个人例外。 如果你一辈子做一个好人，你把世界变得美好了一点点，可能你没有成就伟大的事业；如果你变成了一个恶心的小官僚。你说啊我也没有把世界变得很惨吗，我又不像希特勒杀了那么多人，但你还是把世界改变了，变得恶心了一点点。 我们每一个人来到世间都能改变世界，要相信自己能做出点事情总能够做出来。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"}]},{"title":"冒泡排序","date":"2016-11-29T09:20:05.000Z","path":"2016/11/29/冒泡排序/","text":"思想：每次比较相邻的两个元素,如果他们的顺序错误,就把他们交换一下。 比如你要给 2 3 8 4 6这五个数字从打到小排序，首先第一个数字和第二个数字比较,如果第一个数字小于第二个数字则交换位置，然后第二个数字和第三个数字比较,如果第二个数字比第三个数字小则交换位置。以此类推,如此一遍循环下来,最小的一个数字已经到了最后一个位置。然后开始第二遍从第一个元素开始的相邻的两个元素的比较… 如果有n个数字则我们只需要比较n-1遍即可. 代码：123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(void)&#123; int a[5] = &#123;2,3,8,4,6&#125;; int t; for(int j=0;j&lt;4;j++)&#123; for(int i=0;i&lt;4-1;i++) &#123; if(a[i]&lt;a[i+1]) &#123; t=a[i]; a[i]=a[i+1]; a[i+1]=t; &#125; &#125; &#125; for(int i=0;i&lt;5;i++) &#123; printf(\"%d\\n\", a[i]); &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"对员工的年龄进行排序","date":"2016-11-28T09:07:59.000Z","path":"2016/11/28/对员工的年龄进行排序/","text":"问题描述实现一个排序算法,其时间效率为O(N),需要排序的数字为员工的年龄,总共有几万个,并且可以使用辅助内存。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;void SortAge(int ages[],int length)&#123; if(ages == NULL || length &lt;0) return; const int oldestAge = 99; int timesOfAge[oldestAge + 1]; for(int i=0; i &lt;= oldestAge; i++) timesOfAge[i] = 0; for(int i=0; i &lt; length; i++) &#123; int age = ages[i]; if(age &lt; 0 || age &gt; oldestAge) cout &lt;&lt; \"age out of range\"; ++timesOfAge[age]; &#125; int index = 0; for(int i=0; i &lt;= oldestAge; i++) &#123; for(int j=0; j &lt; timesOfAge[i]; j++) &#123; ages[index] = i; ++index; &#125; &#125; for(int i=0; i&lt;length; i++) &#123; cout &lt;&lt; \" \" &lt;&lt; ages[i]; &#125;&#125;int main()&#123; int data[5] = &#123;1,12,65,2,5&#125;; SortAge(data,5);&#125; 总结：分类方法用长度为100的整数数组做为辅助空间换来了o(n)的时间效率。","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"前端SEO","date":"2016-11-27T08:59:08.000Z","path":"2016/11/27/前端SEO/","text":"在前端开发中，SEO 也是非常重要的一块，那我们如何写出好的 SEO 代码呢？ 要点如下： 合理的 title、description、keywords：搜索对这三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面title要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可。 重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取。 重要内容不要用 js 输出：爬虫不会执行 js 获取内容。 少用iframe：搜索引擎不会抓取iframe中的内容。 非装饰性图片必须加 alt。 提高网站速度：网站速度是搜索引擎排序的一个重要指标。","tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://ijiangnanbei.com/tags/前端开发/"}]},{"title":"如何阻止浏览器的默认行为？","date":"2016-11-26T08:52:24.000Z","path":"2016/11/26/如何阻止浏览器的默认行为？/","text":"1234567891011function stopDefault(e)&#123; //如果提供了事件对象，则这是一个非 ie 浏览器 if(e &amp;&amp; e.preventDefault)&#123; //阻止浏览器的默认动作 e.preventDefault(); &#125;else&#123; //ie 中阻止函数默认动作的方式 window.event.returnValue = false; &#125; return false;&#125;","tags":[{"name":"BOM","slug":"BOM","permalink":"http://ijiangnanbei.com/tags/BOM/"}]},{"title":"前端工作流","date":"2016-11-26T08:44:46.000Z","path":"2016/11/26/前端工作流/","text":"随着 web 应用越来越复杂，项目的结构和代码量也变的愈加庞大，前端人员越来越需要在工程化的层面提高开发效率，前端开发是一个飞速发展的领域，市面上现在有各种各样的工具来辅助我们开发，比如说我们在开发过程中就可能会用到下面这些工具： 1.包管理器 npm我们在开发项目的过程中，会引入各种各样的依赖，比如说： JS 框架：react CSS 框架：Semantic-UI,Bootstrap 如果你的代码风格偏向函数式编程，你可能会用到 Lodash 或者 underscore 如果你的项目涉及到数据交互，你还需要 Axios 来帮你发起ajax 或者 http 请求 如果这些依赖在开发的过程中一个一个的去网站下载一定会很麻烦，所以我们需要一个工具来帮助我们安装这些依赖，这个工具就是包管理器。 管理器在帮助我们安装项目依赖的时候，也会帮助我们安装包的依赖，比如说包管理器在安装 Semantic-UI 的时候，发现 Semantic-UI 使用到了 jQuery，那么包管理器就会帮助我们安装 jQuery 。我们会使用到的包管理器是 npm。 npm不仅可以帮助我们安装包，也能够帮助我们更新、卸载和分析包。 2.任务流工具Grunt 和 Gulp但是仅有包管理器还是不够的，比如你在项目开展的过程中要进行代码检查，编译SCSS文件，合并Sprite图片，压缩合并代码，这些一个一个的动作我们叫做任务，这些任务是一个接着一个执行的，我们把它叫做任务流，帮我们做任务流的工具，我们叫做任务流工具。 Grunt 和 Gulp就是任务流工具，但是任务流工具没办法帮助我们支撑模块化开发，随着 commonJS 和 ES6 的出现，模块化开发在前端有了越来越多的实践。 3.模块打包器 webpack但是在目前浏览器环境代码滑块化还是无法使用，所以如果有一个工具能够让我们在开发的时候使用标准的模块化语法，而上线的时候有帮助我们对代码进行编译转换合并成单个文件让浏览器来运行，这个工具我们把它叫做模块打包器。 事实上 webpack 不仅仅帮助我们打包文件，他还会做一些任务流工具做的工作，比如说编译文件，代码检查。 4.生产依赖和开发依赖生产依赖 JS 框架：react CSS 框架：Semantic-UI,Bootstrap 如果你的代码风格偏向函数式编程，你可能会用到 Lodash 或者 underscore 如果你的项目涉及到数据交互，你还需要 Axios 来帮你发起ajax 或者 http 请求 开发依赖 模块打包器 webpack 任务流工具 gulp 如何区分开发依赖和生产依赖？当你的项目放到浏览器端去运行的时候你还需要它吗？如果需要那它就是生产依赖，反之则是开发依赖。","tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://ijiangnanbei.com/tags/前端开发/"}]},{"title":"前端面试指南HTML5篇","date":"2016-11-25T05:24:04.000Z","path":"2016/11/25/前端面试指南HTML5篇-一）/","text":"1.介绍一下你对浏览器内核的理解？主要分成两部分：渲染引擎和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。 浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS 引擎则：解析和执行 javascript 来实现网页的动态效果。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 2.常见的浏览器内核有哪些？Trident 内核：IE ,MaxThon ,TT ,The World ,360, 搜狗浏览器等。[又称 MSHTML ]。 Gecko内核：Netscape6 及以上版本，FF, MozillaSuite / SeaMonkey等。 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit 内核：Safari,Chrome等。 [ Chrome 的：Blink（WebKit的分支）] 3.简述一下你对HTML语义化的理解？用正确的标签做正确的事情。 html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 4.html5 有哪些新特性、移除了那些元素？如何处理 HTML5 新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 绘画 canvas;用于媒介回放的 video 和 audio 元素;本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;sessionStorage 的数据在浏览器关闭后自动删除; 语意化更好的内容元素，比如 article、footer、header、nav、section;表单控件，calendar、date、time、email、url、search; 新的技术webworker, websocket, Geolocation; 支持 HTML5 新标签：IE8/IE7/IE6 支持通过document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。当然也可以直接使用成熟的框架、比如html5shim 方法一：1234&lt;!–[if lt IE9]&gt; &lt;scriptsrc=\"html5.js\"&gt;&lt;/script&gt; &lt;![endif]–&gt; --&gt; 方法二：123/*css代码，将新标签的样式变成块级元素*/article,aside,dialog,footer,header,section,footer,nav,figure,menu&#123;display:block;&#125; 1234567891011121314//js代码，创建新元素(function() &#123; if (!0) return; var e = \"abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video\".split(', '); var i= e.length; while (i--)&#123; document.createElement(e[i]); &#125; &#125;)(); 移除的元素：纯表现的元素：basefont，big，center，font, s，strike，tt，u;对可用性产生负面影响的元素：frame，frameset，noframes； 如何区分HTML5： DOCTYPE 声明\\新增的结构元素\\功能元素","tags":[{"name":"面试指南","slug":"面试指南","permalink":"http://ijiangnanbei.com/tags/面试指南/"},{"name":"HTML5","slug":"HTML5","permalink":"http://ijiangnanbei.com/tags/HTML5/"}]},{"title":"前端面试指南HTML5篇","date":"2016-11-25T05:24:04.000Z","path":"2016/11/25/前端面试指南HTML5篇/","text":"1.介绍一下你对浏览器内核的理解？主要分成两部分：渲染引擎和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。 浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS 引擎则：解析和执行 javascript 来实现网页的动态效果。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 2.常见的浏览器内核有哪些？Trident 内核：IE ,MaxThon ,TT ,The World ,360, 搜狗浏览器等。[又称 MSHTML ]。 Gecko内核：Netscape6 及以上版本，FF, MozillaSuite / SeaMonkey等。 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit 内核：Safari,Chrome等。 [ Chrome 的：Blink（WebKit的分支）] 3.简述一下你对HTML语义化的理解？用正确的标签做正确的事情。 html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 4.html5 有哪些新特性、移除了那些元素？如何处理 HTML5 新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 绘画 canvas;用于媒介回放的 video 和 audio 元素;本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;sessionStorage 的数据在浏览器关闭后自动删除; 语意化更好的内容元素，比如 article、footer、header、nav、section;表单控件，calendar、date、time、email、url、search; 新的技术webworker, websocket, Geolocation; 支持 HTML5 新标签：IE8/IE7/IE6 支持通过document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。当然也可以直接使用成熟的框架、比如html5shim 方法一：1234&lt;!–[if lt IE9]&gt; &lt;scriptsrc=\"html5.js\"&gt;&lt;/script&gt; &lt;![endif]–&gt; --&gt; 方法二：123/*css代码，将新标签的样式变成块级元素*/article,aside,dialog,footer,header,section,footer,nav,figure,menu&#123;display:block;&#125; 1234567891011121314//js代码，创建新元素(function() &#123; if (!0) return; var e = \"abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video\".split(', '); var i= e.length; while (i--)&#123; document.createElement(e[i]); &#125; &#125;)(); 移除的元素：纯表现的元素：basefont，big，center，font, s，strike，tt，u;对可用性产生负面影响的元素：frame，frameset，noframes； 如何区分HTML5： DOCTYPE 声明\\新增的结构元素\\功能元素 5.什么是渐进增强？渐进增强是指在 web 设计时强调可访问性、语义化 HTML 标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能，同时为高级浏览器和高带宽用户提供更好的用户体验。 核心原则如下: 所有浏览器都必须能访问基本内容 所有浏览器都必须能使用基本功能 所有内容都包含在语义化标签中 通过外部CSS提供增强的布局 通过非侵入式、外部javascript提供增强功能 end-user web browser preferences are respected 6.什么是 web 语义化？有什么好处？web 语义化是指通过 HTML 标记表示页面包含的信息，包含了 HTML 标签的语义化和 CSS 命名的语义化。 HTML 标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构 。 CSS 命名的语义化是指：为 HTML 标签添加有意义的class，id 补充未表达的语义。 为什么需要语义化？ 去掉样式后页面呈现清晰的结构 盲人使用读屏器更好地阅读 搜索引擎更好地理解页面，有利于收录 便团队项目的可持续运作及维护","tags":[{"name":"面试指南","slug":"面试指南","permalink":"http://ijiangnanbei.com/tags/面试指南/"},{"name":"HTML5","slug":"HTML5","permalink":"http://ijiangnanbei.com/tags/HTML5/"}]},{"title":"npm 简单使用","date":"2016-11-24T08:43:05.000Z","path":"2016/11/24/npm-简单使用/","text":"我们使用 npm 来管理我们的项目依赖，但是在这之前我们需要一样东西来描述我们的项目是什么样子的，这个就是 package.json 文件。 有了 package.json 文件之后，npm通过查看 package.json 就能够知道我们的项目大概是一个什么样子，所以我们要做的第一件事情就是在我们的项目中建一个 package.json 的文件。 下面是几个使用 npm 的命令：-npm install 包名 安装包-npm install --save 包名 安装包，并在 package.json 记录为生产依赖-npm install --save-dev 包名安装包，并在 package.json 中记录为开发依赖 -npm uninstall 包名 卸载包-npm uninstall --save 包名 卸载包，并在 package.json中删除记录-npm uninstall --save-div 包名 卸载包，并在 package.json 中删除记录","tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://ijiangnanbei.com/tags/前端开发/"}]},{"title":"Babel 简单介绍","date":"2016-11-24T08:41:55.000Z","path":"2016/11/24/Babel-简单介绍/","text":"Babel 是一个 js 编译器，他可以把其它的东西编译成 js，比如说把 es6 的代码编译成 es5 的代码，使用 Babel 其实并没有这么难，只要你明白了四个概念基本上就可以使用 Babel 了。 1.第一个概念 babel-corebabel-core 就是 babel 的核心，就像一个空白的操作系统一样，里面没有安装任何软件，babel-core 就相当于 babel运行的底层。 2.第二个概念 pluginsbabel 是基于各种插件来运行的，但是如果在你使用的过程中要安装各种插件是非常麻烦的，所以 babel 给我们的解决方案是 presets（预设）。 3.第三个概念 presetspresets（预设），他就像一个插件集，它把一些相关的插件打包在一起然后当你下载某一个预设的时候，里面就会包含非常非多的插件。 4.第四个概念 .babelrc.babelrc 是一个配置文件，你需要在配置文件里面指明你需要用到什么 presets 或者是什么 plugins 。","tags":[{"name":"ES6","slug":"ES6","permalink":"http://ijiangnanbei.com/tags/ES6/"}]},{"title":"C/C++杂记","date":"2016-11-22T09:20:12.000Z","path":"2016/11/22/C-C-杂记/","text":"string 与 string.h 和 cstring 的区别&lt;string.h&gt;是C版本的头文件，包含比如strcpy、strcat之类的字符串处理函数。 &lt;cstring&gt;在C++标准化(1998年)过程中，为了兼容以前，标准化组织将所有这些文件都进行了新的定义，加入到了标准库中，加入后的文件名就新增了一个”c”前缀并且去掉了.h的后缀名，所以string.h头文件成了cstring头文件。但是其实现却是相同的或是兼容以前的，这就是&lt;cstring&gt;的来源，不要觉得又多了一个东西。 &lt;string&gt;是C++标准定义的头文件，它定义了一个string的字符串类，里面包含了string类的各种操作，如s.size(), s.erase(), s.insert()等。但&lt;string&gt;又包含了老的C版本的字符串操作如strcpy、strcat等，这就相当于，在&lt;string&gt;的文件中除了定义自己的string类之外，还加了一个#include&lt;string.h&gt;一句包含了C版本的字符串操作。","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://ijiangnanbei.com/tags/C-C/"}]},{"title":"webpack 简单使用","date":"2016-11-22T08:40:04.000Z","path":"2016/11/22/webpack-简单使用/","text":"webpack 是一个模块打包器，原来我们在写页面的时候，我们会通过一个 script 标签引入一个 js 文件，当你引入模块化的概念之后， 一个 js 文件就是一个模块，如果各个功能合集独立的封装成一个模块，你会发现你的应用会拆分成非常非常多的模块，webpack 会通过一个入口文件，通过 import/require 静态的分析出你整个应用的模块之间依赖的情况，模块之间的依赖可能是非常混乱的，一个模块可能会被不同的模块引入，你没法直接的知道这些模块之间的依赖情况，当 webpack 静态的分析出整个依赖树的时候，他就会进行一个打包，默认打包输出的文件时 main.js。 我们最开是的时候，就应该先建立一个 package.js 文件， 在你开始写一个项目的时候，应该首先把一个项目的结构写好：一般 src 文件夹里面放的就是你的源文件，app.js 就是你程序的入口，dist 文件夹里面放的就是我们要打包的文件， （未完待续。。。）","tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://ijiangnanbei.com/tags/前端开发/"}]},{"title":"PHP杂记","date":"2016-11-21T09:13:45.000Z","path":"2016/11/21/PHP杂记/","text":"PHP数组下标的效率探讨1.对于整形的索引值不必加单双引号，如果你加了单双引号，还需要把其转换为整形，影响了效率。 2.字符串的下标要加上单双引号避免因常量的定义而产生错误。不加单双引号，在流程上他会先理解成常量，如果没有作有这个常量，再当成字符串来处理，其效率必然下降。 1234567$arr = array(1=&gt;'csdn',name=&gt;'jnb');//这个时候如果你定义了一个 name 的常量define('name','ansen');//此时 name 不加单双引号的输出就会报错echo $arr[name]; 3.加单引号还是双引号？单引号的解析速度远远快于双引号，所以需要加单引号。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://ijiangnanbei.com/tags/PHP/"}]},{"title":"跨浏览器的事件处理程序","date":"2016-11-21T08:38:37.000Z","path":"2016/11/21/跨浏览器的事件处理程序/","text":"要保证事件处理的代码在大多数浏览器下能够一致的运行，只需关注冒泡阶段即可。 第一个要创建的方法是 addHandler() ，它的职责是视情况分别使用 DOM0 级方法、DOM2 级方法或 IE 方法来添加事件。这个方法属于一个叫做 EventUtil 的对象，addHandler() 接受三个参数：要操作的元素、事件名称和事件处理程序函数。 与 addHandler() 方法相对应的是 removeHandler()，他也接收相同的参数。这个方法的职责是移除之前添加的事件处理程序，无论该事件处理程序是采取什么方式添加到元素中的，如果其他方法无效，默认采用 DOM0 级方法。 123456789101112131415161718192021222324252627282930var EventUtil = &#123; addHandler : function( element, type, handler ) &#123; if ( element.addEventListener ) &#123; element.addEventListener( type, handler, false); &#125; else if ( element.attachEvent ) &#123; element.attachEvent( \"on\" + type, handler ); &#125; else &#123; element[ \"on\" + type ] = handler; &#125; &#125;, removeHandler : function( element, type, handler ) &#123; if ( element.removeEventListener ) &#123; element.removeEventListener( type, handler, false); &#125; else if ( element.detachEvent ) &#123; element.detachEvent( \"on\" + type, handler ); &#125; else &#123; element[ \"on\" + type ] = null; &#125; &#125;&#125;&lt;!--more--&gt;//使用方法var oBtn = document.querySelector(\"#btn\");var handler = function() &#123; alert( \"haha\" );&#125;EventUtil.addHandler( oBtn, \"click\", handler );// EventUtil.removeHandler( oBtn, \"click\", handler ); 这两个方法首先都会检测传入的元素中是否存在 DOM2 级方法，如果存在该方法则使用该方法。 如果存在的是 IE 的方法，则使用第二种方案。注意，为了在 IE8 级更早的版本中运行，此时的事件类型必须加上 “on” 前缀。 最后一种可能就是使用 DOM0 级方法（在现代浏览器中应该不会执行这里的代码）。此时我们使用的是方括号语法来将属性名指定为事件处理程序。","tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://ijiangnanbei.com/tags/前端开发/"}]},{"title":"性能优化之DOM与JS","date":"2016-11-20T08:36:13.000Z","path":"2016/11/20/性能优化之DOM与JS/","text":"什么是 DOM？ DOM 就是用于操作 xml 和 html 文档的应用程序，浏览器会把 DOM 和 JS 独立实现。 JS 操作 DOM 就像是从一个岛到了另一个岛，岛与岛之间的桥，每次通过都是要收取过桥费的,所以我们要尽量减少过桥的次数，意思就是说能在独立的岛上去完成的，就在独立的岛上去做，避免跨“岛”操作。减少 DOM 与 JS 的交互，可以大大提高浏览器的性能。 1.使用缓存12345678910111213141516171819202122232425&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var oDiv = document.getElementById('div1'); var str = ''; //未使用缓存 console.time('hello'); for(var i=0; i&lt;5000; i++)&#123; oDiv.innerHTML += 'A'; &#125; console.timeEnd('hello'); //使用缓存 console.time('hello'); for(var i=0; i&lt;5000; i++)&#123; str += 'A'; &#125; oDiv.innerHTML = str; console.timeEnd('hello'); &#125;&lt;/script&gt; 通过测试可以发现：使用缓存可以大大提高浏览器的性能。 2.innerHTML 和 DOM 方法对比12345678910111213141516171819202122232425262728293031323334&lt;body&gt;&lt;ul id=\"ul1\"&gt;&lt;/ul&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var oDiv = document.getElementById('ul1'); var str = ''; //DOM 方法 console.time('hello'); for(var i=0; i&lt;5000; i++)&#123; var oLi = document.createElement('li'); oDiv.appendChild(oLi); &#125; console.timeEnd('hello'); //innerHTML 方法 console.time('hello'); for(var i=0; i&lt;5000; i++)&#123; str += '&lt;li&gt;&lt;/li&gt;'; &#125; oDiv.innerHTML = str; console.timeEnd('hello'); /** * chrome : ( */ &#125;&lt;/script&gt;&lt;/body&gt; 通过测试可以发现：webkit 内核的浏览器 DOM 方法要比 innerHTML 方法的性能要好，其他的浏览器则相反，所以这个时候你就要根据你的用户量有针对性的去做选择。 3.节点克隆12345678910111213141516171819202122232425262728293031323334&lt;body&gt;&lt;ul id=\"ul1\"&gt;&lt;/ul&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var oDiv = document.getElementById('ul1'); var str = ''; //未使用节点克隆 console.time('hello'); for(var i=0; i&lt;5000; i++)&#123; var oLi = document.createElement('li'); oLi.innerHTML = 'li'; oDiv.appendChild(oLi); &#125; console.timeEnd('hello'); //使用节点克隆 console.time('hello'); var oLi = document.createElement('li'); oLi.innerHTML = 'li'; for(var i=0; i&lt;5000; i++)&#123; var newLi = oLi.cloneNode(true); oDiv.appendChild(newLi); &#125; console.timeEnd('hello'); &#125;&lt;/script&gt;&lt;/body&gt; 通过测试可以发先：使用节点克隆可以大大提高浏览器的性能 4.访问元素集合尽量用局部变量1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt;&lt;ul id=\"ul1\"&gt; &lt;/ul&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var oUl = document.getElementById('ul1'); var aLi = oUl.getElementsByTagName('li'); for(var i=0; i&lt;5000; i++)&#123; var oLi = document.createElement('li'); oUl.appendChild(oLi); &#125; //未使用局部变量 console.time('hello'); //这个操作里面比较影响性能的就是 aLi.length 原因就 //是 for 循环的时候你每次都要重新获取其长度，这就是 //频繁的 DOM 操作,所以说我们要把它变成一个局部变量。 //对一个变量进行循环,不会涉及到多次的 DOM 操作,性能 //就会好一些 for(var i=0; i&lt;aLi.length; i++)&#123; aLi[i].innerHTML = i; &#125; console.timeEnd('hello'); //使用局部变量 console.time('hello'); var len = aLi.length; for(var i=0; i&lt;len; i++)&#123; aLi[i].innerHTML = i; &#125; console.timeEnd('hello'); &#125;&lt;/script&gt;&lt;/body&gt; 12345678910//未使用局部变量var oDiv = document.getElementById('');var oInput = document.getElementById('');var oUl = document.getElementById('');//使用局部变量var doc = document;var oDiv = doc.getElementById('');var oInput = doc.getElementById('');var oUl = doc.getElementById(''); 通过测试可以发现：使用局部变量比未使用局部变量性能要高很多。 5.尽量用只获取元素的节点方法12345childNodes;//不仅获取元素节点同时获取文本节点children;//只会获取到元素节点firstChild;//只会获取到元素节点firstElementChild;//只会获取到元素节点 尽量用只获元素节点的方法可以提高浏览器的性能 6.使用新选择器1234567891011121314151617181920212223&lt;body&gt; &lt;ul id=\"ul1\"&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;1111&lt;/li&gt; &lt;/ul&gt; &lt;script type=\"text/javascript\"&gt; var oUl = document.getElementById('ul1'); var aLi = document.getElementsByTagName('li'); //上面的两句话可以用下面的一句话代替 var aLi = document.querySelectorAll('#ul1 li'); // ie 8 以下的浏览器不支持该属性 for(var i=0; i&lt;aLi.length; i++)&#123; aLi[i].style.color = 'red'; &#125;&lt;/script&gt;&lt;/body&gt; 利用 querySelector ,querySelectorAll 这些新的选择器对性能的提升是很大的。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ijiangnanbei.com/tags/性能优化/"}]},{"title":"性能优化之DOM与浏览器","date":"2016-11-20T08:33:32.000Z","path":"2016/11/20/性能优化之DOM与浏览器/","text":"1.页面渲染机制重排：当你改变页面中元素大小的时候，浏览器在加载页面的时候就会发生重排。 重绘：当浏览器显示的内容改变的时候就会发生重绘。 2.添加顺序1234567891011121314151617181920212223242526272829303132333435&lt;body&gt;&lt;ul id=\"ul1\"&gt;&lt;/ul&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var oUl = document.getElementById('ul1'); //添加操作在 appendChild 后，降低了性能 console.time('hello'); for(var i=0; i&lt;5000; i++)&#123; var aLi = document.createElement('li'); oUl.appendChild(aLi); aLi.innerHTML = 'LI'; &#125; console.timeEnd('hello'); //添加操作在 appendChild 前，提供了性能 console.time('hello'); for(var i=0; i&lt;5000; i++)&#123; var aLi = document.createElement('li'); aLi.innerHTML = 'LI'; //当你在 append 之前添加的时候,减少了重排重绘 //的过程,提高了性能,我们尽量把一些操作放在添加的 //前面进行 oUl.appendChild(aLi); &#125; console.timeEnd('hello'); &#125;&lt;/script&gt;&lt;/body&gt; 3.cssText利用 cssText 合并 DOM 操作，可以提高浏览器的性能。12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt;&lt;ul id=\"ul1\"&gt;&lt;/ul&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var oUl = document.getElementById('ul1'); //没有进行合并 console.time('hello'); for(var i=0; i&lt;5000; i++)&#123; var aLi = document.createElement('li'); aLi.style.width = \"100px\"; aLi.style.height = \"20px\"; aLi.style.backgroundColor = 'red'; oUl.appendChild(aLi); &#125; console.timeEnd('hello'); //进行了合并 console.time('hello'); for(var i=0; i&lt;5000; i++)&#123; var aLi = document.createElement('li'); aLi.style.cssText='width:100px;height:20px;background:red;'; oUl.appendChild(aLi); &#125; console.timeEnd('hello'); &#125;&lt;/script&gt;&lt;/body&gt; 4.缓存布局信息1234567891011121314151617181920&lt;body&gt;&lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; var oDiv = document.getElementById('div1'); //这里就是缓存布局信息的方式 var L = oDiv.offsetLeft; var T = oDiv.offsetTop; //如果在函数中每次都要获取 offsetLeft 和 offsetTop //就会非常影响性能 setInterval(function()&#123; L++; T++; oDiv.style.left = L + 'px'; oDiv.style.top = T + 'px'; &#125;,30); &#125; &lt;/script&gt;&lt;/body&gt; 5.使用文档碎片1234567891011121314151617181920212223&lt;body&gt;&lt;ul id=\"ul1\"&gt;&lt;/ul&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; console.time('hello'); var oUl = document.getElementById('ul1'); //创建一个文档碎片 var oFrag = document.createDocumentFragment(); for(var i=0; i&lt;5000; i++)&#123; var aLi = document.createElement('li'); //每次循环的时候都会向页面添加,就相当于 5000 次 //的重排和重绘的过程，所以我们在每次循环的时候, //把所有的东西都放到文档里面,然后一次性添加 oFrag.appendChild(aLi); &#125; //使用文档碎片一次性添加 oUl.appendChild(oFrag); console.timeEnd('hello'); &#125;&lt;/script&gt;&lt;/body&gt;","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ijiangnanbei.com/tags/性能优化/"}]},{"title":"性能优化之Dome与前端模板","date":"2016-11-20T08:32:00.000Z","path":"2016/11/20/性能优化之Dome与前端模板/","text":"利用前端模板来对逻辑和视图进行更好的分离，页面的渲染和你的 JS 是分开进行的,这对大型的架构非常好。前端模板是 MVC 架构的基础。 （待补充）","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ijiangnanbei.com/tags/性能优化/"}]},{"title":"性能优化之Demo与事件","date":"2016-11-20T08:30:32.000Z","path":"2016/11/20/性能优化之Demo与事件/","text":"（待补充…）","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://ijiangnanbei.com/tags/性能优化/"}]},{"title":"前端面试指南JS篇","date":"2016-11-20T05:21:08.000Z","path":"2016/11/20/前端面试指南JS篇（一）/","text":"1.null 和 undefined 的区别? 对为初始化的变量执行 typeof 操作符会返回 undefined 值，而对未声明的变量执行 typeof 操作符同样也会返回 undefined 值，所以我们在编写代码的过程中应该显示的初始化变量，那么当 typeof 返回 undefined 的时候，我们就知道被检测的变量还没有被声明而不是还没有初始化。、 undefined 值是派生自 null 值的，他们的相等性测试要返回 true 12alert(null == undefined);//truealert(null === undefined);//false null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值会返回 “object” 的原因。 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null，而不是其他值，这样一来，只要直接检查 `null`` 值就可以知道相应的变量是否已经保存了一个对象的引用。 123if (car != null)&#123; //对 car 对象执行某些操作&#125; 无论在什么情况下都没有必要把一个变量的值显示的设置为 undefined，可以同样的规则对 null 却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确的让该变量保存 null 值。这样做不仅可以体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。 2.XML 和 JSON 的区别？ 数据体积方面 ： JSON 相对于 XML 来讲，数据的体积小，传递的速度更快些。 数据交互方面：JSON 与 JavaScript 的交互更加方便，更容易解析处理，更好的数据交互。 数据描述方面：JSON 对数据的描述性比 XML 较差。 传输速度方面：JSON 的速度要远远快于 XML。","tags":[{"name":"JS","slug":"JS","permalink":"http://ijiangnanbei.com/tags/JS/"},{"name":"面试指南","slug":"面试指南","permalink":"http://ijiangnanbei.com/tags/面试指南/"}]},{"title":"前端初级小Demo集合","date":"2016-11-17T08:28:50.000Z","path":"2016/11/17/前端初级小Demo集合/","text":"控制 div 属性 —-&gt;源代码 水平垂直居中一个 div—-&gt;源代码","tags":[{"name":"Demo","slug":"Demo","permalink":"http://ijiangnanbei.com/tags/Demo/"}]},{"title":"Ajax小Demo集合","date":"2016-11-15T08:26:55.000Z","path":"2016/11/15/Ajax小Demo集合/","text":"1.用Ajax实现验证登录12345678910111213141516171819var username=document.getElementById(\"name\").value;var password=document.getElementById(\"pwd\").value;var xhr=null;xhr=new XMLHttpRequest();//新建一个XMLHttpRequest对象xhr.open(\"get\",'./check.php',true);//初始化请求xhr.onreadystatechange=function () &#123;//定义数据返回后的回调函数 if(xhr.readyState==4)&#123; if(xhr.status===200)&#123; var data=xhr.responseText; if(data==1)&#123; result.innerText=\"登录成功\"; &#125; else if(data===2)&#123; result.innerText=\"登录失败\"; &#125; &#125; &#125;&#125;;xhr.send(null);//xhr.send(null); 2.jquery 中的 ajax如果使用原生的 js 发送请求，你需要这么写：1234567891011var xhr=null;xhr=new XMLHttpRequest();xhr.open(\"get\",url,true);xhr.send(null);xhr.onreadystatechange=function () &#123; if(xhr.readyState===4)&#123; if(xhr.status===200)&#123; dosomething(); &#125; &#125;&#125;; 但是如果使用jquery发送 ajax 请求的话，只要一行代码就可以了：1$.ajax(&#123;url:\"test.js\",dataType:\"json\"&#125;);","tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://ijiangnanbei.com/tags/Ajax/"},{"name":"Demo","slug":"Demo","permalink":"http://ijiangnanbei.com/tags/Demo/"}]},{"title":"IFE任务之JS篇","date":"2016-11-15T08:24:51.000Z","path":"2016/11/15/IFE任务之JS篇/","text":"1. 任务一：零基础JavaScript编码（一）2.任务二：零基础JavaScript编码（二）(代码简洁优美)3.任务三：零基础JavaScript编码（三）4.任务四：基础JavaScript练习（一）5.任务五：基础JavaScript练习（二）6.任务六：基础JavaScript练习（三）–&gt;源代码&amp;&amp;效果展示","tags":[{"name":"Demo","slug":"Demo","permalink":"http://ijiangnanbei.com/tags/Demo/"}]},{"title":"JS实现字符串反转","date":"2016-11-14T08:20:21.000Z","path":"2016/11/14/JS实现字符串反转/","text":"第一种方法：12var str = 'abc';alert(str.split(\"\").reverse().join(\"\"));//cba 第二种方法：12345var str = 'abc';var len = str.length;for(var i=len-1; i&gt;=0; i--)&#123; alert(str.charAt(i));&#125; 第三种方法：123456789var str = 'abc';var str2 = [];var str3 = null;var len = str.length;for(var i=len-1; i&gt;=0; i--)&#123; str2.push(str[i]);&#125;str3 = str2.join(\"\");alert(str3);//cba","tags":[{"name":"JS","slug":"JS","permalink":"http://ijiangnanbei.com/tags/JS/"},{"name":"面试指南","slug":"面试指南","permalink":"http://ijiangnanbei.com/tags/面试指南/"}]},{"title":"递归实现斐波那契数列","date":"2016-11-13T08:15:59.000Z","path":"2016/11/13/递归实现斐波那契数列/","text":"用递归实现斐波那契数列：123456789101112 function fobi(n)&#123; if(n == 0 || n == 1)&#123; return 1; &#125; return fobi(n-1)+fobi(n-2); &#125;var result = fobi(3);alert(result);//3","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"},{"name":"JS","slug":"JS","permalink":"http://ijiangnanbei.com/tags/JS/"}]},{"title":"六道JS面试题","date":"2016-11-13T08:15:59.000Z","path":"2016/11/13/六道JS面试题/","text":"1.创建JS对象的两种方法?var o1 = {}; var o2 = new object; 2.如何创建数组?var a1 = []; var a2 = new Array; 3.什么是变量提升?无论在哪一个范围内,哪个位置声明的变量,JS引擎都会将这个声明移 动到作用域范围的顶部. 例子: var a = 0; function foo(){ if(false){ var a = 2; } console.log(a);//undefined } 这段代码等于: var a = 0; function foo(){ var a; if(false){ a = 2; } console.log(a); } 4.全局变量有什么风险,以及如何保护代码不受干扰?风险是:污染命名空间,也就是说其他人或者自己可能创建相同名称的变量,然后覆盖了正在使用的变量. 预防方法: i.使用命名空间 var namespace = {}; namespace.myVariable = &apos;abc&apos;; ii.使用立即执行函数进行封装 (function(){ var a = &apos;abc&apos;; })(); 5.如何通过JS对象中的成员变量迭代for(var property in obj){ if(obj.hasOwnProperty(property)){ //do something here } } 6.什么是闭包?闭包是有权限访问另外一个函数作用域变量的函数.闭包可以保持值的状态,比如说一些迭代值的当前值. function foo(){ var result = [],i; for(i = 0; i &lt; 3; i++){ result[i] = function(){ return i; } } return result; } var result = foo(); result[0]();//3 result[1]();//3 result[2]();//3","tags":[{"name":"JS","slug":"JS","permalink":"http://ijiangnanbei.com/tags/JS/"},{"name":"面试指南","slug":"面试指南","permalink":"http://ijiangnanbei.com/tags/面试指南/"}]},{"title":"字符串和数组的相互转换","date":"2016-11-13T08:13:06.000Z","path":"2016/11/13/字符串和数组的相互转换/","text":"数组转换为字符串解法一：1234567var data = [1,2,3,4];var str = '';for(var i=0; i&lt;data.length; i++)&#123; str += data[i];&#125;alert(typeof str);//string//（不知此方法是否正确，还望高手指教） 解法二：123var data = [1,2,3,4];var str = data.join(\",\");alert(typeof str);//string 解法三：12var data = [1,2,3,4];alert(typeof String(data));//string 解法四：12var data = [1,2,3,4];alert(data.toString());//string 解法五：12345678&lt;script type=\"text/javascript\" src=\"json2.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var data = [1,2,3,4]; //json2.js 里面的 JSON.stringify 方法会把对象转为字符串 var str = JSON.stringify(data); alert(typeof str);//string&lt;/script&gt; 字符串转换为数组解法一：1234var str = \"aaa,bbb,ccc\";// 在每个逗号(,)处进行分解。var data = str.split(\",\");alert(typeof data);//object 解法二：1234567&lt;script type=\"text/javascript\" src=\"json2.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var str = '[1,2,3,4]'; //json2.js 里面的 JSON.parse 方法可以把字符串转为对象 var data = JSON.parse(str); alert(typeof data);//array&lt;/script&gt;","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"},{"name":"JS","slug":"JS","permalink":"http://ijiangnanbei.com/tags/JS/"}]},{"title":"前端面试HTTP篇","date":"2016-11-12T05:18:43.000Z","path":"2016/11/12/前端面试HTTP篇/","text":"TCP 传输的三次握手四次挥手策略三次握手 为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。用 TCP 协议把数据包送出去后，TCP 不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志： SYN 和 ACK。 发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。 最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。 四次挥手 第一次挥手：主动关闭方发送一个 FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在 fin 包之前发送出去的数据，如果没有收到对应的 ack 确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到 FIN 包后，发送一个 ACK 给对方，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号）。 第三次挥手：被动关闭方发送一个 FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到 FIN 后，发送一个 ACK 给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 HTTP 缓存机制？缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。 即使存在缓存，也会因客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，代理服务器会再次从源服务器上获取“新”资源。 （待补充） 响应首部字段 ETag首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。另外，当资源更新时，ETag 值也会随之更新。 资源的 URI 虽没有变，但是当资源更新后，ETag 值会随之改变。 强 ETag 值，不论实体发生多么细微的变化都会改变其值。 弱 ETag 值，只用于提示资源是否相同，ETag : usagi-1234。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值开始处附加 W/，ETag : W/&#39;usagi-1234&#39;。 没有 ETag 还能拿什么验证？（待补充） Cache-Control 通用首部字段具体内容Cache-Control 能够操作缓存的工作机制，指令的参数是可选的，多个指令之间通过“，”分隔。 Cache-Control : private, max-age=0, no-cache 缓存请求指令 指令 参数 说明 no-cache 无 强制向源服务器再次验证 no-store 无 不缓存请求或响应的任何内容 max-age = [秒] 必需 响应的最大 Age 值 max-stale(=[秒]) 可省略 接收已过期的响应 min-fresh=[秒] 必需 期望在指定时间内响应仍然有效 no-transform 无 代理不可更改媒体类型 only-if-cached 无 从缓存获取资源 cache-extension 新指令标记(token) 缓存响应指令 指令 参数 说明 public 无 可向任意方提供响应的缓存 private 可省略 仅向特定用户返回响应 no-cache 可省略 缓存前必须要确认其有效性 no-store 无 不缓存请求或响应的任何内容 no-transform 无 代理不可更改媒体类型 must-revalidate 无 可缓存但必须再向源服务器进行确认 proxy-revalidate 无 要求中间缓存服务器对缓存的响应有效性在进行确认 max-age = [秒] 必需 响应的最大 Age 值 s-maxage=[秒] 必需 公共缓存服务器响应的最大 Age 值 cache-extension 新指令标记(token) 如何用 JS 删除某条 Cookie？直接设置过期时间就可以了。","tags":[{"name":"面试指南","slug":"面试指南","permalink":"http://ijiangnanbei.com/tags/面试指南/"},{"name":"HTTP","slug":"HTTP","permalink":"http://ijiangnanbei.com/tags/HTTP/"}]},{"title":"正则表达式简明教程","date":"2016-11-12T05:14:13.000Z","path":"2016/11/12/正则表达式简明教程/","text":"1.认识正则正则其实就是字符串规则表达式。来看一个栗子：1234$str = 'hi,this is his history';$patt = '/hi/';preg_match_all($patt,$str,$matches);print_r($matches); ^ 匹配字符串的开始 $ 匹配字符串的结尾 \\b 匹配单词的开始和结尾（边界） \\B 匹配单词的非边界 2.常用字符簇 簇 代表 .（点） 任意字符，不含换行 \\w [a-z A-Z 0-9_ ] \\W \\w 的补集 \\s 空白符，包括\\n\\r\\t\\v等 \\S 非空白符 \\d [0-9] \\D 非数字 3.单词匹配1234567891011// 把字符串的 hi 单词找出来$patt = '/\\bhi\\b/';$str = 'hi, this is some history book';preg_match_all($patt, $str, $res);print_r($res);// 把包含在单词内部的 hi 找出来$patt = '/\\Bhi\\B/';$str = 'hi, this is some history book';preg_match_all($patt, $str, $res);print_r($res); 4.集合与补集示例12345678910// 找出手机号，必须由[0,1,2,3,5,6,8,9]组成，长度为11$patt = '/^[01235689]&#123;11&#125;$/';$patt = '/^[^47]&#123;11&#125;$/';$arr = array('13800138000','13426060134','170235','18289881234568782');foreach($arr as $v) &#123; preg_match_all($patt, $v, $res); print_r($res);&#125; 5.字符范围123456// 找出纯字母组成的单词$str = 'o2o, b2b, hello,world, that';$patt = '/\\b[a-zA-Z]&#123;1,&#125;\\b/'; //&#123;1,&#125;最少一个字母$patt = '/\\b[a-zA-Z]+\\b/';preg_match_all($patt, $str, $res);print_r($res); 6.字符簇字符簇就是系统规定好的表示方法。12345678910// 把单词拆开$str = 'tommorw is another day , o2o , you dont bird me i dont bird you';$patt = '/\\W&#123;1,&#125;/'; // \\W-&gt;\\w[a-zA-Z0-9]的补集print_r(preg_split($patt, $str));//把多个空格或制表换成一个空格$str = 'a b heloo world'; // 'a b hello world';$patt = '/\\s&#123;1,&#125;/'; //\\s空白符，包括\\n\\r\\t\\v等//preg_replace — 执行一个正则表达式的搜索和替换echo preg_replace($patt, ' ', $str); 7.找几个 *匹配前面的子表达式零次或多次","tags":[{"name":"编程","slug":"编程","permalink":"http://ijiangnanbei.com/tags/编程/"}]},{"title":"影响软件性能的因素","date":"2016-11-10T05:11:38.000Z","path":"2016/11/10/影响软件性能的因素/","text":"软件性能是软件的一种非功能特性，它关注的不是软件是否能够完成特定的功能，而是在完成该功能时展示出来的及时性。由于感受软件性能的主体是人，不同的人对于同样的软件能有不同的主观感受，而且不同的人对于软件性能关心的视角也不同。 目前，大部分系统都是为多用户、跨地域、多部门机构提供服务的，目前一般中小企业的员工人数也有几十号人，实际并发数量比较小，在软件性能方面影响不大，但是对于中大型企业、大型国企或跨国跨区域的集团企业，公司的员工有几千人，甚至几万人，而且一般一套系统都要运行很多年，这样存量数据也非常惊人，对于软件系统的性能表现影响巨大。 影响性能的主要因素包括：硬件设施、网络、操作系统、并发用户数、系统积累的数据量、中间件等。如果系统中哪一个环节出现了性能瓶颈，都会严重影响系统的正常运行。 硬件是决定一套系统性能的关键因素之一，主要包括服务器的CPU、内存、磁盘I/O使用情况，如果系统并发用户数增大而内存不足，会导致CPU和磁盘使用压力。在高性能的服务器配置情况下，可以大大提高系统性能，在单实例服务器配置的硬件条件无法满足现有性能需求的情况下，可以考虑使用多台服务器以集群模式部署，配备负载均衡器进行负载均衡处理。","tags":[{"name":"编程","slug":"编程","permalink":"http://ijiangnanbei.com/tags/编程/"}]},{"title":"创业早期必须要重视的问题有哪些？","date":"2016-11-08T18:30:49.000Z","path":"2016/11/09/创业早期必须要重视的问题有哪些？/","text":"创业的过程，或让创业者不堪重负，或让创业者激进向前。是人都会犯错，但创业的路上没人能够提醒你应该注意重视哪些问题，往往当你重视的时候问题已经发生了。 1.创业要顺势而为。一定要找到一个足够大、快速增长、相对处于早期的大方向，太小太窄，太早太晚的都不合适。 找个你真正熟悉了解信任的人搭伙建团队。 创业是个艰难的过程，才认识一两天的人，哪怕相谈甚欢，也最好先花足够长的时间加深了解，建立信任，再搭伙建团队。一个人创业是个孤独的过程，两个人无论在精神、技能，还是分工上往往有更好的效果。 2.找到一个好的产品切入点你的产品是为谁服务的，有没有可以一句话清晰描述的明确用户群？“所有上网用户”不是答案，对于一个早期产品，最好找到一群最需要它的核心用户，试图满足越多的用户，你的产品往往会越复杂，越不能让所有人满意。 有没有可以一句话说清楚的产品核心需求和核心功能。 如果这两点不能用两句话说清楚，就不是一个好的切入点。另外不要把你自己的假定和需求当作用户的需求。 选择切入点的时候不要over fancy（独特过头）。不是一定要做没人做过的东西，借鉴已有的应用和模式做增量创新或整合式创新其实也是一条好的路子，起码是验证过的用户需求和商业模式，只要你做出好的区隔点。可是如果你做全新的需求，最好确定这个需求一年内有明显的量，再远一点儿，最好能找到一个一年内会出现的一个中间过渡需求点。 在开始之前，还要想清楚如何推广和接触你定义的核心用户，有没有低成本的用户和流量获取渠道，根据产品不同，这个渠道可能是好的用户传播机制，SEO、SNS、API合作、用户数据库群发、论坛、下载站、网吧、网址站、捆绑、预置、网盟，以及App Store应用商店和朋友帮忙等。尽量利用各种开放平台。如果没有早期的低成本的用户获取或推广渠道，那除非你的产品早期可以赚钱，否则就不要做。 创业像游戏里面的练级打怪一样，有很多的选择，很多的挑战，每往上走一步，你都要有一个自我的提升，很多公司都死在这个升级的路上。所以在进入游戏之前，你们需要先找一个练习场，先从一些成功的公司和成功的创业者那里汲取营养。 你可以一直保持创业的心态，在资源缺乏的时候，可以先和别人合作，可以先加入别人的公司，利用别人公司的资源来把事情做成功。我把这称为广义上的“创业”。 机遇永远属于有准备的人。如果这几年你通过这种广义的创业，有了更多的经验和商业积累，未来你真正自己出去单干的那一天，你能更快迎来自己的成功。 好的产品不是一个灵光一闪的一蹴而就，要不断把握用户需要，不断与时俱进，小步快跑、不断打磨。所以你要有韧性，要懂得如何把握用户的需求。 有了好的产品，还要有好的运营。我觉得“皇帝的女儿不愁嫁”、“酒香不怕巷子深”并不正确。你要想办法把产品推广出去，所以，光有产品和技术是不够的，要懂市场。 创业最开始只要哥儿几个，搞几台电脑就能干活。但随着你事业的进一步做大，你需要去融资。如何和VC、金融大鳄打交道，拿到融资？你还要熟悉资本运作。 你成功拿到1000万，这个钱该怎么花？三个人的时候干得热火朝天，但公司有了200人却几乎没有人干活了。管理对你又是一个很大的挑战。 没有学会这些，就直接去创业，就是揠苗助长。","tags":[]},{"title":"盈利模式对初创企业重要吗？","date":"2016-11-08T18:26:37.000Z","path":"2016/11/09/盈利模式对初创企业重要吗？/","text":"赢利模式或者商业模式重不重要、有多重要，这个问题一定能让很多人打架。一个成熟的公司肯定都会有自己的赢利模式，那么对于一个创业型的公司、创业型的项目，赢利模式重要吗？体现在哪些方面？ 赚钱，必须的。赚钱是任何企业天经地义的义务、任务、必须工作。 不赚钱的企业是没有存在价值的。这一点，所有创业的人都必须记在心中。什么阶段要赚钱？ VC 在投资初期不要求赚钱，甚至不要求有赢利模式，是因为 VC 和创业者相信这个创业公司的产品和方向在未来可以赚到钱。如果没有这个相信，没有人会白白地给钱的。 互联网创业的第一个阶段，也就是大约第一个12个月，主要是做产品、找客户、增加黏性，迅速积累客户到市场的前三名。这个时候，大家看的是产品和用户数字，而不是赢利模式。 第二阶段，有了用户数了，就必须开始试验各种赢利的方式和方法了。这个对于技术出身的互联网创业者是一个门槛、挑战。而且，做不好还容易丢失用户。这个试错过程，可能持续1~2年，但是必须最终找到一个可行的赢利模式。这个阶段的考核指标是，挣钱，而且是比较稳定的现金流。不过这个阶段的大部分互联网公司依旧是亏损的。不要紧，只要这个赢利模式是可以持续的，VC 会愿意继续追加投资的，目的是让创业者把市场做大、把自己做强。 第三阶段，就是发展壮大已经找到的赚钱模式。用效率压低成本，用多样化开拓挣钱途径，用强大的攻势挤走对手，例如现在的京东，依旧亏钱，但是投资人还在支持，因为这个模式一定赚钱，不过需要一定的投入和条件，例如挤走大的竞争对手，树立定价权。 第四阶段，真的赢利了，有利润了，需要再次扩张，或者需要兑现投资人的利益，那就可以考虑上市了。 暂时看不见不代表可以没有，任何人都不质疑赢利模式的重要性。","tags":[]},{"title":"最伟大的演讲家要具备的能力","date":"2016-11-07T07:38:44.000Z","path":"2016/11/07/最伟大的演讲家要具备的能力/","text":"最伟大的演说家都具备这样的能力：从专业或日常的产品中创造出某种有意义的事物的能力。 星巴克的首席执行官霍华德·舒尔茨卖的不是咖啡，而是办公室和住所之外的“第三空间”。财务专家苏茜·欧曼售卖的不是信托和共同基金，而是财务自由的梦想。 与此类似，乔布斯卖的也不是电脑，而是释放人类潜能的工具。你要不断问自己这个问题：“我真正出售的究竟是什么？” 记住，你的新产品本身并不能改变顾客的观念。你要向别人展示这个产品如何能够让生活变得更加美好。做到这一点，你就赢得了顾客。如果你还能用有趣的方式做到这一点，你就能拥有忠实的粉丝，他们会义务为你工作，替你宣传，帮你推销。","tags":[{"name":"商业技巧","slug":"商业技巧","permalink":"http://ijiangnanbei.com/tags/商业技巧/"}]},{"title":"知行合一","date":"2016-11-06T18:24:09.000Z","path":"2016/11/07/知行合一/","text":"这句话的真正意思是：要想实现崇高伟大的志向，必须有符合实际、脚踏实地的方法。 这不仅仅是一句话，而是一种高深的处事和生活智慧，足以使人受用终生，所以它看起来很容易明白，实际上很不容易明白。 曾经，有两个人先后看到了这句话，一个人看懂了，另一个人没有看懂。 看懂的那个叫张居正，没有看懂的那个叫海瑞。 四百年后，有一个年轻人看到了这句话，佩服的五体投地，以此作为自己终生的行为准则，并据此改名–陶行知！","tags":[]},{"title":"如何选择创业方向？","date":"2016-11-05T07:33:55.000Z","path":"2016/11/05/如何选择创业方向？/","text":"判断大趋势、进行SWOT分析、寻找切入口，这些当然需要做，但创业不是择业，这些只是外因。而内因，不是方法，是种本能。 真正的创业者，不管他在做的事情我听没听过，只要听他讲，就会觉得总有机会，他热情万丈，内心燃火，谈到“那个方向”，他会两眼发光，非干不可，还要拉你入伙。我认为一个人在一段时间里，只会在一件事上进入这种状态。 你想要的，一定让你奇痒难耐，去说服家人，拉人入伙。如果根本没这状态，外因分析得再透彻，也是别人的创业。问自己，动力是什么。有了那个强大如风、把自己吹得站不稳、必须往前跑的动力，答案就不是一道选择题了。人生积累处寻方向：你的创业方向离不开你决定创业那一刻之前的人生积累，尤其是你的职业生涯的积累。 如果你的积累是工程师，选择从解决问题的角度去创业是比较合适的。这个问题也应该是你自己本身需要解决的。更重要的是，你要多跟那些已经在创业的、创业小有所成的、创业失败的人去聊天。聊他们的项目，他们的产品，他们从0到1是怎么过来的。如果你足够有悟性，相信你能够从中找到你的创业方向的。","tags":[]},{"title":"真需求还是伪需求","date":"2016-11-01T05:06:02.000Z","path":"2016/11/01/真需求还是伪需求/","text":"还要明确一点，客户的需求是无限的，而你的资源是有限的，你要做的不是调查所有目标市场客户的需求，并从中作出遴选。恰恰相反，你要用你有限的资源尽快找到突破口和卖点，找到一个值得深耕的市场。 第一步要做的是，按照你们创业的想法，用最快的方法做出一个非常粗糙的原型。这个原型甚至只是一个没有功能的空壳（软件用户界面或者纸板搭出来的硬件原型），让你们的团队自己用用看，把自己放在非常苛刻的客户的角度，看看是否会接受（不是接受界面本身，而是所表达的功能）。同时，用快速迭代来改进设计，比如在线募资网站Kickstarter上一个基于安卓操作系统的很有名气的游戏平台OUYA，他们的游戏手柄，就是先用木头做快速原型，在内部试用。目的是什么？在初期用尽可能小的代价，发现产品的不足，错误和不足发现得越晚，改正的代价就越昂贵。 第二步要做的是，找出具有创新意识、愿意和你一起玩的几个非典型客户，做出一个只有简单核心功能的原型请他们试用。能找到这种客户并不容易，可以有各种方式，比如向他们许诺第一批产品出来以后免费赠送给他们。但首先这些客户一定是非典型的极端客户。比如OUYA就会请一些游戏高手来试玩，OUYA的创始人就陪着一个游戏玩家一起玩游戏。 这些客户是极其宝贵的，他们不仅会指出很多你没有考虑到的地方，帮你拓展思路，甚至会帮你打翻原有的设计。在这一过程中你要注意观察这些极端客户的行为，不仅听他们说，还要琢磨他们为什么这么做。在这基础上你可以发现很多新的需求，甚至产品的独到卖点，因为很多客户需求是客户自己都没有意识到的。第三步，根据上面的需求分析，再反馈回来，做新的改进，并进一步完善产品。也就是说重复第一步和第二步。直到非常确信这就是客户想要的东西，而且产品也可以做公众测试了（可以想见，你找的那些陪你走这一程的极端用户是多么宝贵）。这时候基本功能就稳定了，但是还有很多bug（缺陷），没有关系，因为你下一步要做的是寻找更多客户验证需求，而不是debug（解决缺陷）。 第四步时，可以寻找更广泛的友好测试用户群体，通过观察和倾听，了解更多的需求。这时候大部分需求都是比较细微的，比如“那个颜色的遥控器我不喜欢”等，若有重大的需求改变，就需要做出取舍，因为这时候做改进已经非常昂贵了。向他们提问的时候多问开放型的问题，比如以why（为什么）、what（什么）、where（哪儿）、which（哪个）和how（如何）等开头的问题，而不要仅仅问“你喜欢吗”这样弱智的问题。 第五步，才是真正把产品做稳定，以及安排市场推广等常规的流程。 整个流程的思路就是先针对一群极端用户，通过看得见、摸得着的原型，渐进式地深挖用户需求，找到产品卖点和新的市场需求，在这过程中尽量把重大改进往早放；而不是针对大众市场，做一个大家都能想到的产品。 这对中国的创业公司更有挑战，因为中国人不喜欢表达自己的思想，所以更需要通过观察和提出开放型的问题来理解客户需求。 上面的做法对绝大多数创业者都是适用的，即使你原来就做这一行，也千万别自以为是，认为自己已经充分理解用户需求了。 要尽早接触客户，在产品还没有做出来的时候就要厚着脸皮见客户，和他讲你们的愿景和产品规划，谦虚地从他们那里学习，他们会告诉你很多有意思的信息。","tags":[]},{"title":"一个好的计划书","date":"2016-10-31T04:37:12.000Z","path":"2016/10/31/一个好的计划书/","text":"1. 市场机会首先，潜在市场机会要大，而“不要太大”。 “不要太大”的意思是说这个市场最好是有经验和洞察的创始人在大多数人还没看到之前，就发现了。巨大但是众所周知的市场可能会带来过度的投资、恶性的竞争和产业整体不良发展。这也是个市场时机的问题。 其次，公司的增长最好来自市场本身的增长，而非抢夺竞争对手的份额。 再次，公司有机会成为市场中具有支配地位的第一或第二。第三和第四一般不具备市场控制力、定价能力，因而利润等方面会大幅下降。 有人说，特别是在中国做，我的公司只要在一个巨大的市场里获得2%或3%的份额就有非常不错的收入和利润了。这话可能不错，公司也是好公司。但是不一定适合风险投资。没有支配地位的公司一般难于保持风险投资所要求的高利润率、资金效率和高回报率。 2.竞争优势 第一，一个最简单的思考竞争优势的框架： 1. 用户愿意为你的产品或服务付的价格。 2. 成本。 一个公司要么能够让用户为类似的服务付更多的钱，要么能以更低的成本满足需求。能做到一点就很好，能做到两点的公司少之又少。竞争优势可以写一本书，因此这里不展开讲了。创业的朋友可以仔细从这两个角度深入思考一下你熟悉的成功企业，你们的竞争优势都可以归为这两点或两点的结合。如果想多了解，可以看看迈克尔·波特那些经典的有关竞争优势的文章。 第二，竞争优势能否持续。这样公司可以在一段相当的时间内，获得超额的利润和回报。 3.商业模型第一，有几个收入来源、各个来源的发生时间点、收入规模和增长率、影响收入的关键要素。 第二，主要成本，哪些可变、哪些固定、成本发生的时间点和决定成本的要素。 第三，需要多少资金投入才能获得正的现金流，何时能发生，working capital（营运资本）的需求如何，何时能开始盈利。 第四，找到商业模型中最关键的那几个点，它们如何影响收入和盈利。哪些点最难于执行等。 4.团队团队在要做的方向上是有相关和相当的积累的。 5.融资相关首先包括公司有一个仔细思考过的业务和产品发展计划步骤。达到每个目标需要什么样的资源和多长时间。这样团队可以以最少的稀释获得发展所需的资源。同时，也表明了团队对执行细节的把握和理解；其次要有合理的估值；最后还包括对投资人退出机制的考虑等。","tags":[{"name":"商业技巧","slug":"商业技巧","permalink":"http://ijiangnanbei.com/tags/商业技巧/"},{"name":"商业","slug":"商业","permalink":"http://ijiangnanbei.com/tags/商业/"}]},{"title":"由《战略》到人生的战略","date":"2016-10-27T04:28:08.000Z","path":"2016/10/27/由《战略》到人生的战略/","text":"从当下的均衡，你努力推动它向下一个均衡转化，你摆脱了当下的怪圈，财富，力量，所有你追逐的东西才能对你有用，如果你不能打破你当下生活的怪圈，换句话说，就是从这个均衡向下一个均衡转化的话，给你再多你想要的东西也没有用，这就叫人生的战略。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"生物学的思维方式","date":"2016-10-25T04:22:36.000Z","path":"2016/10/25/生物学的思维方式/","text":"把时间这个维度带入到思考当中。根据环境、变量、一点点的变化，在每一个点上都追逐最佳策略。 一旦切换到生物学的视角来看问题，一时间的强弱胜负就变得不那么重要了。诸多环境变量相互叠加、作用和驯化、最终的游戏结局也许将出人意料。因此，一个生物，应该在每一个时间节点上都关注环境的变化，并找到最佳的生存策略，而不是什么终极解决方案。这就是生物学的思维方式。 我们今天谈商业，用的就是生物学的思维方式。 所谓生物学的思维方式，虽然是一个复杂的话题，但也不用讲的那么玄乎。简单说，就是把时间这个维度带到思考当中。不是按照既定的蓝图、目标、计划、策略去施工，而是根据环境、变量、一点点的变化，在每一个点上都追逐最佳策略！","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"价值？估值？","date":"2016-10-22T04:20:21.000Z","path":"2016/10/22/价值？估值？/","text":"不要让自己的估值过分的超过自己的价值。如果交易只有一次，那么，估值越高越好。可是注定要交易多次，那么情况就不同了。路很长，交易很多，甚至，大多数交易算不上里程碑，只不过是慢慢长路上的鸡毛蒜皮，于是，每次都想与大于价值的估值交易实际上是完全不可能的。 更为重要的，是另一方面。因为当你在意估值的时候，你就会忘记自己的价值，你就会不由自主去做那些提高你估值的事情，而不是去想办法提高你的价值。 长期来看，估值是虚幻的，虽有波动，却实际上锚定在价值上，价值不增长，长期来看估值一定上不去，而且既然有极度高估，那么就不但随时有低估，还随时有极度低估！—忘记价值，追求估值，这肯定是极度愚蠢的。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"创新是落后者的权利","date":"2016-10-20T04:12:25.000Z","path":"2016/10/20/创新是落后者的权利/","text":"关于创新有一个广泛存在的错误看法，那就是让领先者去领导时代潮流，而落后者则应该把注意力放在向别人学习上。如果你的企业甘于落后那么这中思想就是正确的，反之，那么这种思想就是完全错误的。 这里所说的创新是那种改变游戏规则，改变商业模式，“根本性”的创新。这种创新往往具有历史意义，你一旦成功，会有很多后来者向你学习。你不是创新图存，而是引领风气之先。这样的创新最大的特点，不是“开放的头脑”之类的优秀品质，而是风险！ 如果你是一个有心的领导者，你每时每刻都可以接触到各种号称可以改变世界，至少可以改变你们公司的“新思想”。这些思想逻辑上都是无懈可击，但实施过程是有风险的。对于领先的企业，没有必要冒这种风险。只有落后者，光脚不怕穿鞋的，反而可以冒这个险。冒险只要还有赢得机会，不冒险就输定了。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"},{"name":"商业技巧","slug":"商业技巧","permalink":"http://ijiangnanbei.com/tags/商业技巧/"}]},{"title":"你有经历过王阳明时刻吗？","date":"2016-10-17T04:08:13.000Z","path":"2016/10/17/你有经历过王阳明时刻吗？/","text":"所有对世道人心有起码智慧的人，他的人生当中都会有这么一个叫“王阳明时刻”，就是他突然意识到，我要想过的更好，我要达到更高的人格和事业目标，那不是向外求的，你要学会向内求，你自己才是一切问题的根源。 吴伯凡老师说过一句话：说远方过来一个人，那是个人吗？不是！那是一个认知模式！一个人的本质就在于他的认知模式，他跟世界的关系，是跟他理解这个世界的方式有关的，和他占有的资源是没有什么关系的。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"从哪里发现用户的需求？","date":"2016-10-14T10:47:55.000Z","path":"2016/10/14/从哪里发现用户的需求？/","text":"商业价值来自需求的满足。源源不断地发现需求并满足这些需求，就会源源不断地产生商业价值。但是发现需求的过程中往往伴随着很多陷阱。真需求，假需求，强需求，弱需求……一旦掉入陷阱，就会浪费大量的时间成本。 1.找极端用户，渐进式深挖需求首先明确的一点是：调查问卷是不会帮你发现需求的。因为所有的调查问卷都是基于当前的技术和当前的市场做的，这对于洗发水之类的成熟行业很合适，而对于大部分有创新业务特别是破坏性创新（disruptive innovation）的创业公司来讲则并不适用，因为客户并不熟悉你的技术和想法，他们甚至无法理解你的意图。 2.改变生活的产品，来源于真实的生活如何找到靠谱的用户需求，不让设计、开发资源浪费，就是回归“真实”的生活。 要找到需求，就观察人们现在的行为。欲望像洪水，会疯狂冲破阻拦它的一切。它会寻找堤坝最薄弱的地方，喷涌而出。所以，人们已经表现出的行为才是最能体现内心需求的。人类已经存在了几十万年，需求基本是不变的，只是行为会越来越高效。对于每一个时代而言，某种需求都会选择最便利的解决方案。人们会日复一日地使用它，以至于它太平常了，就在日常生活中，吸引不了那些梦想着用完美的创新颠覆世界的创业者。有种需求叫“我想告诉你件事儿”，它经历了吼、喇叭、飞鸽传书、驿站、邮局、电报、电话、QQ打字、视频聊天等一系列解决方案，现在流行的是微信，那再过10年是什么呢？这个需求太平常了，平常到就是地铁上旁边那个拿着手机在打电话的人。如果你希望你的产品成为下一个时代每个人都会用的东西，就要观察在这个时代每一个人在最平常的生活里会用什么。 3.竞争对手是最好的老师讲到竞争对手，实际上他们是你最好的老师。他们已经做过一轮甚至几轮市场调查，用他们的产品前仆后继地蹚出了一条血路。你一定要把市面上主要竞争对手的产品都拿来分析一下，把你自己放在用户的角度，看你能不能说服你自己，你的产品是有竞争力、有卖点的。如果连你自己都说服不了自己，那还是慎重考虑创业——别说你没有竞争对手，客户没有替代方案！你一定是在自欺欺人！如果创业还处在这个状态，真的是“盲人骑瞎马，夜半临深池”。","tags":[{"name":"商业技巧","slug":"商业技巧","permalink":"http://ijiangnanbei.com/tags/商业技巧/"}]},{"title":"如何判断市场是否值得进入？","date":"2016-10-11T10:43:04.000Z","path":"2016/10/11/如何判断市场是否值得进入？/","text":"进入市场前已经有很多竞争者了，如何判断是否还值得进入？ 在创业初期一定要慎重选择一个有成长空间的项目。行业前景很好的时候，创业者更容易把事做成，建立起信心。但大家往往都不是第一个进入市场的，大多数情况下市场已经存在不少的竞争者了。这时候该如何评估自己的实力以及该市场是否还值得进入呢？ 1.创业的第一步是创新我们做的事情是不是足够创新？是不是一片蓝海？如果已经有很多竞争者，要非常慎重地考虑你的差异化。新创造的价值是否足够显性，足够有说服力让竞争者的用户或者客户来选择你的产品。不要只是好一点儿，而是颠覆式的创新。 竞争者有没有做大？如果都没有做大，要好好地慎重思考是什么原因。有时候可能不一定是团队的原因，极有可能是市场的原因，一方面是市场的需求没有那么大，可能只是小众的需求；另一方面是时机还没有真正到来，如果贸然进入，也不会得到市场的认可。比如中国的Pinterest（品趣志）模式图片社交分享网站，虽然进入这个领域的资本很多，团队也很优秀，但是大家都没有做大。原因到底是什么？要慎重思考。 如果到了一个有竞争者做大，尤其是形成寡头的局面下，你若想进入，就要看你的模式有没有形成独特的竞争优势和竞争柔道。假设对手也会改变，执行力还很强，钱又很多，你进入时就要想得很清楚。 2.靠细分市场立足当市场成熟之后就会出现个性化需求，尤其是在这个个性化的年代。 比如说在视频网站这种基本靠烧钱活下来的市场里面，不仅活下了优酷、土豆，而且还有搜狐视频、爱奇艺、乐视。市场确实只容得下一个优酷，容不下另一个土豆，但是市场还容得下一个主打美剧的，还容得下一个主打高清的，还会有通过买版权活下来的，所以这就是一个永久的矛盾，一只大象总想大而全地“一揽子”解决问题，但总有蚂蚁来解决大象看不见的地方。而且谁能保证蚂蚁不会变成下一个大象？会跳舞的大象毕竟不多见。","tags":[{"name":"商业技巧","slug":"商业技巧","permalink":"http://ijiangnanbei.com/tags/商业技巧/"}]},{"title":"如何修筑壁垒？","date":"2016-10-10T10:30:32.000Z","path":"2016/10/10/如何修筑壁垒？/","text":"对于早期创业团队，产品推出后很容易被复制，如何建立自己的竞争壁垒？ 在一个巨大的市场中，往往可以有很多公司互相竞争。早期创业者在资金劣势、人才劣势、技术劣势的情况下，定位出自己的竞争差异尤为关键。想为用户提供产品和服务，首先就要知道市场在哪、用户在哪、自己的竞争力在哪。 一旦确认早期的用户需求，有了不错的增长之后，创业者就一定要考虑如何建立壁垒和竞争优势。 可以建立壁垒的地方有： 团队人力优势 产品功能优势 核心技术优势 内容优势 资源优势 渠道优势 口碑品牌优势 商务运营优势 用户优势：用户数、关系网络，或数据 生态系统优势 要分析所有潜在对手的优势和位置，对比自己的团队、用户群、资源和产品，来确立自己适合在哪里集中资源，建立壁垒。当然人人都想要9和10。但早期团队往往只能从1、2、3、4起步，向5、6、7、8发展，最后到达9和10。 一般早期团队最少要做到产品在功能和技术上比竞争对手快4~6个月，团队能力上比对手强。 建立壁垒往往可以和用户需求与技术结合，从没有壁垒的地方创造出壁垒。如何修筑壁垒——论一个“砖瓦匠”的自我修养。这里的“自我修养”，包括你了解自身的缺陷，知道如何发挥自我优势，熟知敌我关系，知己知彼。技术是基础，那这种“自我修养”就该是上层建筑。基础决定壁垒能否建立起来，上层建筑决定你能否发展壮大。","tags":[{"name":"商业技巧","slug":"商业技巧","permalink":"http://ijiangnanbei.com/tags/商业技巧/"}]},{"title":"你错失了哪些创业机会？","date":"2016-10-07T10:25:46.000Z","path":"2016/10/07/你错失了哪些创业机会？/","text":"创业的过程仿佛就是不断看到机会、错失机会的过程，看到Facebook的时候想，哎呀自己怎么没想到呢。但其实机会有的是，有了Fackbook以后还能有 Twitter，有了 Twitter 以后照样还能诞生照片分享软件Instagram。每次觉得痛失某个创业机会的时候，下一个机会可能正在面前走过。所以不用太过担心，摆正心态，不断累积不断尝试，为下一个机会做好准备。当机会来临的时候，所有的付出都会得到回报，就像我们2010年遇到网页游戏的机会时那样。 回顾历史，学学古人的智慧 先抛开这个问题，让我们回头看看 。每个时代都有每个时代独特的机会，都出现在自己独特的领域。像赵佗那样建个南越国是根本没有可能的，但是其他领域的机会却多如牛毛。三皇五帝，唐尧虞舜，靠教化百姓、种地打鱼、兴修水利，就能成就天下圣王；商汤周武，靠武力争夺天下；到了春秋战国，普通士人的机会，则在于在思想文化上开创新的学术流派。 所以不要那么多地去听周围的声音，什么职业是好的，你该成为什么样的人，而要更多地去思考我擅长做什么，我爱做什么。一个成功的公司，它的CEO做的一定是他擅长的事，并且是他爱做的事。","tags":[{"name":"商业","slug":"商业","permalink":"http://ijiangnanbei.com/tags/商业/"}]},{"title":"一个有效的新产品上线策略应考虑哪些因素？","date":"2016-10-05T10:09:58.000Z","path":"2016/10/05/一个有效的新产品上线策略应考虑哪些因素？/","text":"和线下的传统商务不一样的是，互联网这条商业街上并没有现成的精准用户。产品的推出只是最基础的工作，通过哪些策略去获取正确的用户，是产品上线后面临的第一个问题。 1.精准精准再精准。首先要分析谁是你的目标用户、核心用户。 2.低调低调再低调。如果你的第一批目标用户是非IT群体，建议可以尽量在IT圈保持低调，不然有这么几点坏处：第一是吸引了非目标群体的用户，这些用户基本是本着调研产品的心态来的，会影响产品的数据，得不到正确的反馈；第二是会在行业内引起很多人的注意，过早让自己的产品暴露在全中国产品经理的雷达下，提前引入很多竞争对手。 3.简单简单再简单。 产品一定要简单，把核心功能打磨得非常锋利，其他非核心功能可以不做，让产品在发布的时候非常有冲击力。首先用核心功能来试验市场，如果核心功能能够打动市场，再安排人力、时间来开发二级功能。如果核心功能不能打动市场，二级功能做得再好，也不能打动市场。而且领先于对手第一个推出产品，最好的用户都被吸引过来，会有先发优势。 “精准”、“低调”和“简单”。“精准”告诉你要找准目标用户，找到发力点；“低调”可以帮助你减少不正确的反馈和不必要的竞争；“简单”让你的产品变得非常尖锐，开辟市场，发挥优势。","tags":[{"name":"商业技巧","slug":"商业技巧","permalink":"http://ijiangnanbei.com/tags/商业技巧/"}]},{"title":"变数","date":"2016-10-03T23:00:24.000Z","path":"2016/10/04/变数/","text":"问题描述： 输入两个整数 m 和 n，计算需要改变 m 的二进制表示中多少位才可以得到 n。比如 10 的二进制表示为 1010，13 的二进制表示为 1101，需要改变 1010 中的三位才能到的 1101。 思路： 我们可以分为两步解决这个问题：第一步求这两个数的异或，第二部统计异或结果中 1 的个数。 代码： 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int Timesof2(int m, int n)&#123; int r = m^n; int count = 0; while(r) &#123; ++ count; r = (r-1) &amp; r; &#125; return count;&#125; int main()&#123; int m = 10, n = 13; cout &lt;&lt; Timesof2(m,n) &lt;&lt; endl;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"新产品上线策略","date":"2016-10-03T08:35:35.000Z","path":"2016/10/03/新产品上线策略/","text":"一个新产品上线策略主要可以从以下几个方面来考虑： 1. 商业。一个公司的所有商业行为都是为了商业目标服务的，发布、运营一个新产品也是如此。目标用户和市场情况如何，产品如何到达目标用户和市场；产品和商业模式如何运转并形成竞争力，产品如何与市场上的各利益相关方形成有效的合作关系，产品和配套的服务如何为公司创造可持续的经济利益。只有商业问题想清楚了，后续的具体做法才有坚实的目标和依据。 2.产品。弄清此次新产品上线的目的是什么，是要大张旗鼓的营销，还是悄悄进行的测试。 检验产品前端（直接面对用户的界面）能为目标用户提供怎样的使用体验，以及产品后端（服务器、CDN等）能支撑多少用户并发、稳定、流畅的访问，为产品正式上线做准备。 在产品中如何布局数据采集点，建立分析模型，为产品上线后的快速迭代、持续改进做准备。 建立用户反馈收集和处理机制，如何及时应对用户反馈、利用用户反馈进行产品改进做准备。 3.营销。选择专业公司合作还是自主进行，使用什么辅助工具。 针对目标人群进行营销方案的策划，包含策略制定、创意制定、渠道选择、效果评估等。 营销导来的用户，到达产品的过程中体验如何，产品如何最高效的吸收这些用户。 如何让用户自发的产生二次营销，产品和运营在其中如何支持。 最后，一定要注意上线前的测试。缺乏测试，直接让新产品公开上线、推广，可能在这重要的初次亮相中不仅无法收集到有效的用户和产品数据，无法获得积极的营销效果；甚至造成恶劣的影响，让产品以后都无法获得用户和市场的认同。上线前测试的目标，就是在可控的环境中模拟产品正式上线可能遇到的各种问题，以便及时改进产品、并让各团队做好产品上线的准备。","tags":[{"name":"商业技巧","slug":"商业技巧","permalink":"http://ijiangnanbei.com/tags/商业技巧/"}]},{"title":"2的整数次方","date":"2016-10-02T23:00:24.000Z","path":"2016/10/03/2的整数次方/","text":"问题描述： 用一条语句判断一个数是不是 2 的整数次方。 思路： 一个数如果是 2 的整数次方，那么它的二进制表示中有且只有一位是 1，而其他所有位都是 0。所以，把这个数减去 1 之后再和它自己做与运算，这个整数中唯一的 1 就会变成 0。 代码实现： 1result = n-1 &amp; n ? \"false\" : \"true\";","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"二进制中1的个数","date":"2016-10-01T23:00:24.000Z","path":"2016/10/02/二进制中1的个数/","text":"问题描述： 请实现一个函数，输入一个整数，输出该数二进制表示中一的个数。例如把 9 变成二进制是 1001 ，有 2 位是 1 。因此如果输入 9 则该函数输出 2。 思路： 把一个整数减去1，再和原来的整数做与运算，会把该整数最右边一个1变成0，那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作，基于这个思路我们可以写出如下的代码： 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int Numberof1(int n)&#123; int count = 0; while(n) &#123; ++ count; n = n-1 &amp; n; &#125; return count;&#125; int main()&#123; int n = 9; cout &lt;&lt; Numberof1(n) &lt;&lt; endl;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"二进制中 1 的个数","date":"2016-10-01T15:54:21.000Z","path":"2016/10/01/二进制中-1-的个数/","text":"问题描述： 请实现一个函数，输入一个整数，输出该数二进制表示中一的个数。例如把 9 变成二进制是 1001 ，有 2 位是 1 。因此如果输入 9 则该函数输出 2。 思路： 首先把输入的数字 i 和 1 做与运算，判断 i 的最低位是不是 1。接着把 1 左移一位得到 2 ，再和 i 做与运算，就能判断 i 的次低位是不是1… 这样反复的左移，每次都能判断 i 的其中一位是不是 1。 */ 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int count(int n)&#123; int count = 0; unsigned int flag = 1; while(flag) &#123; if(n&amp;flag) count++; flag = flag &lt;&lt; 1; &#125; return count;&#125;int main()&#123; int num = 9; cout &lt;&lt; count(num) &lt;&lt; endl;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"用最土的办法获得用户","date":"2016-10-01T08:28:16.000Z","path":"2016/10/01/用最土的办法获得用户/","text":"一个产品，三分设计、七分运营，冷启动是考验运营的基本功。 第一步：搞清楚你的目标用户，千万别铺大平台，现在不缺平台，缺的是扎实解决小量用户垂直需求的精品。听人说过一句话：只做1厘米宽，100米深的事情。搞清楚你所服务的那一小撮人是谁。 如果一旦不幸，你做了个平台，恭喜你，你得想清楚你的运营策略，先抓住某类用户，比如你的平台是C2C，那么你先服务好商家还是用户？这时候听听有经验的人怎么说吧，答案很简单——商家。 第二步：用最土的办法、低成本获得用户，搞清楚目标用户后，80%的情境就是你知道去哪里找用户了。比如你就为中学生服务，那就去中学生扎堆的地方吧，发传单，设咨询台，找校方做赞助，做宣讲，总之别在家里待着。让那些鼓励你去买百度关键词、去分众买广告、去CCTV砸钱的人一边儿待着吧。 第三步：让第一批用户用得爽。我们只讨论运营层面，所以假定你的产品设计和体验是OK的，这时候爽不爽全在用户的心理感受，不同产品爽点不同，社交产品得热闹，工具产品得高效，内容产品得有料，如果没有咋办？好吧，你自己每天穿50个马甲不断激励你社交产品的种子用户，工具类产品就来人工智能，至于内容产品，你每天熬到深夜精选内容传上来再用 Photoshop（图片处理软件）美化一下，发布吧。 第四步：持续第一至三步。运营就好比夏天吹空调，你面对的永远是个老旧空调，热得要死的时候，打开空调没啥感觉，耐心等待，慢慢地温度就降下来了，爽点要在很久以后。而那些一开空调就冷气十足的永远是别人家产品，所以，坚持、等待，你会让你的产品不再冷的。创业团队早期是怎样快速尝试和快速改进的？ 产品上线后，看起来再完美的方案，也会因为一些细节没有被考虑充分而需要调整产品。快速尝试和开发的能力对效率而言非常重要。掌握正确的方法，在现有的方案上稍加调整，就可以解决大部分问题，而且成本更低。","tags":[{"name":"商业技巧","slug":"商业技巧","permalink":"http://ijiangnanbei.com/tags/商业技巧/"}]},{"title":"《经济学通识》","date":"2016-09-26T08:18:02.000Z","path":"2016/09/26/《经济学通识》/","text":"这本书断断续续读到现在还没有读完，先占个坑。 《经济学通识》，薛兆丰老师在序里这样说：用什么养的眼光，就有什么样的世界。随着阅读和思考的深化，你将逐渐学会把“愿望”和“结果”分开来衡量；你知道不仅要看“局部”还要看“全部”；你不仅能看见“别人看的见的”，还能看见“别人看不见的”；你会发现“事实是什么”比“别人怎么形容”更重要；你还会觉得不少过去看来理所当然的因果关系其实颠倒过来才对。 改造“世界”，非经济学所长；但改造“世界观”，却是经济学的强项。阅读本书的后果，就是“世界观”的转变。","tags":[{"name":"经济学","slug":"经济学","permalink":"http://ijiangnanbei.com/tags/经济学/"}]},{"title":"创业的修炼","date":"2016-09-25T08:15:26.000Z","path":"2016/09/25/创业的修炼/","text":"创业不是突然迸发的，她是有过程的： 第一：你的心态是不是一直在磨练自己，让自己成为一个有心的人 第二：你是不是到了第一线，你是不是踏实的为这个结果和目标负责任 第三：等待机会","tags":[{"name":"商业","slug":"商业","permalink":"http://ijiangnanbei.com/tags/商业/"}]},{"title":"如何让潜意识帮助你思考？","date":"2016-09-22T05:06:43.000Z","path":"2016/09/22/如何让潜意识帮助你思考？/","text":"潜意识会帮助我们思考，即使我们不主动去想一个问题时，他也会非常“勤奋”的为我们工作。更有意思的是，潜意识不会被我们的条条框框限制住，他就像不羁的游侠，游走在我们思考疆域的角角落落。 那么，怎样才能让潜意识为我们工作呢？在讨论创意思维的经典之作《创意的生成》一书中，介绍了其中的奥秘： 1.尽可能地搜集原始资料 2.重复“咀嚼”原始资料，构思初始创意 3.终止有意识的思考，启动潜意识思考 4.随时准备迎接“灵光乍现”的时刻降临 5.加以改造、完善，使之切实可用 总之，你要记住，如果你想让潜意识为你工作，就首先必须向潜意识“投喂”足够多的“养料”，有了这些“养料”之后，潜意识用它们不断进行重新组合的试验，直至最好的想法出现。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"}]},{"title":"产业阴谋链结语","date":"2016-09-20T04:47:51.000Z","path":"2016/09/20/《产业阴谋链：笔记六-结语》/","text":"《产业阴谋链：笔记六 》 由于我们已经进入了前所未有的产业链战争的新时代，因此政府推动的产业政策就格外的重要。 过去中国的企业犯了很多错误，例如市场换技术，结果市场丢了，技术也没换来。这两年很多地方政府呼吁企业搞产业升级和品牌战略，这又是一个误区。所谓的产业升级，不应该仍然在6+1的1上面搞升级，而应该从1升级到6的环节。因此我们不能倒果为因。政策的转变必然牵扯到思维转变的先行，只有政府，企业，都发挥思维的创新，进一步理解中国产业链没有来得及打造的闭环，理解中国企业受阻的瓶颈（这个瓶子是倒着放的）即如何从1过渡到6，进而打造属于中国特色企业的产业链，才能真正地走出低谷。","tags":[{"name":"经济学","slug":"经济学","permalink":"http://ijiangnanbei.com/tags/经济学/"}]},{"title":"法制化规则的缺乏助长金融战","date":"2016-09-17T04:46:06.000Z","path":"2016/09/17/《产业阴谋链：笔记五-法制化游戏规则的缺乏助长金融战》/","text":"《产业阴谋链：笔记五 》 书中举了这么一个例子：农民灌溉的流程是，在打开水闸之前要先挖沟渠，然后打开水闸灌溉农田。要是你忘了挖沟渠怎么办呢？结果就是水闸一开，洪水马上淹没了良田。我们今天的国际化包括头上的两只秃鹰，就是打开水闸之后，忘了挖沟渠了，洪水漫流大地，把我们内资企业的良田美地都淹没了。 那么什么是沟渠？那就是你一定要指定一个严刑峻法的法治化游戏规则，这个规则是要控制这个国家的所有个体包括政府包括国有企业包括百姓。如果缺乏一个严刑峻法的法治化游戏规则，而盲目的引进外资，这两只秃鹰将会像洪水一样席卷大地，把良田都淹没，如此未来的格局一定是大欺小，强欺弱。 产业资本和金融资本在这种无沟渠的环境下，他们对我们企业的掠夺简直让我们国内工厂欲哭无泪。举例而言，德国施奈德想要收购正泰，而正泰不想卖，结果施奈德到处控告正泰抄袭仿冒，到处打官司，把正泰搞烦了，他说不定就卖了。为什么这些产业资本这么嚣张呢？因为这就是一个没有挖过沟渠的中国，他们可以用这种不正当的手段大欺小强欺弱。 产业链阴谋下中国企业的战略出路：产业链高效整合。面对重重危机，中国企业的出路在哪里呢？郎教授举了这么一个例子：世界知名的服装品牌西班牙的飒拉（Zara），系统地解答这一问题。飒拉的成功简单的讲就在于整条产业链6+1的高效整合。我国服装制造业其实也有6+1的部门，但大多数分属于不同的企业，更重要的是缺乏“高效”的整合。什么叫做高效整合，简单的讲，我国服装业者走完整条6+1的流程需要180天，而飒拉走完整个流程只需要12天，也就是他们整条产业链的整合速度是我国服装业者的15倍。 飒拉怎么做产业链的高效整合呢？飒拉为了加快运输的速度，他们在物流基地挖了200公里的地下隧道，用高压空气运输，速度奇快无比。此外，为了加快运输速度，他们用飞机而不是轮船从西班牙将成品运送到上海或香港，虽然飞机运费很高，但是高效整合更重要，成本会更低。 飒拉透过产业链的高效整合大幅压缩成本，而同时透过高效整合作市场的快速反应者，因此他们的衣服总是最新潮，最受市场喜爱。飒拉的产业链高效整合思维应该对我们的企业非常有启发，因为这才是我们企业的未来战略出路。","tags":[{"name":"经济学","slug":"经济学","permalink":"http://ijiangnanbei.com/tags/经济学/"}]},{"title":"产业链阴谋与两只秃鹰的金融超限战","date":"2016-09-15T04:44:25.000Z","path":"2016/09/15/《产业阴谋链：笔记四-产业链阴谋与两只秃鹰的金融超限战》/","text":"《产业阴谋链：笔记四 》 简单解释一下标题：“产业阴谋链与两只秃鹰的金融超限站”，即产业资本和金融资本这两只秃鹰利用中国企业产业链定位悲剧，今天的中国是一个以1（1即加工制造）为主而不是以6（6：产品设计，原料采购，物流运输，订单处理，批发经营，终端零售）为主的产业链结构，从中攫取利益。 安海斯-布希公司就是头上翱翔的第一只秃鹰，他叫做产业资本。产业资本对中国企业的掠夺，其可怕程度大家必须要清醒知道。 那么二只秃鹰是谁？举一个例子，徐工是重工业领域，美国的凯雷基金想收购徐工，假设徐工以100块的价格被卖掉，凯雷基金将可能会以十倍的价格，将它分拆转卖掉，到时候他就会赚大头。或者凯雷将徐工整合进入整条产业链而获取整合的巨大收益。凯雷基金是谁，凯雷基金就是天上翱翔的第二只秃鹰，它叫做金融资本。 很多人可能就会有个疑问：我们企业家这么努力的工作都不能赚钱，老外凭什么能赚钱,郎教授在书中告诉我们,我们不赚钱，老外也不一定能赚钱，但是这一块钱制造业赔不赔钱不重要，假设最多赔一美金，但是整条产业链却能创造出十美金价值，因此制造业赔多少钱都无所谓，因为可以从6+1的6把1的亏损全部赚回来.因此对于两只秃鹰而言，它们并不是看制造业能不能创造利润，而是看能不能把制造业融入到产业链当中，这就是头上的两只秃鹰的产业链战略。秃鹰仍然会把制造业继续放在中国，为什么呢？因为他们要继续浪费我们的资源，破坏我们的环境，剥削我们的劳动，这就是所谓的“国际分工”。目前外资对我国企业的收购就像井喷一样，书中有这样一组数据,我国利用外资占GDP的比重已超过40%，外资企业占全国进出口总值的55.48%，外资企业占高科技产品出口的87%。","tags":[{"name":"经济学","slug":"经济学","permalink":"http://ijiangnanbei.com/tags/经济学/"}]},{"title":"二元经济引发通货膨胀","date":"2016-09-12T04:41:38.000Z","path":"2016/09/12/《产业阴谋链：笔记三-二元经济引发通货膨胀》/","text":"《产业阴谋链：笔记三 》 猪肉价格怎么上涨了?原因很简单，郎教授在书中告诉我们是由二元经济现象造成的。养猪肉的民营企业家跟其它行业企业家是一样的，他们所面临的投资营商环境也是急速恶化。原因就是进口饲料价格大涨，还有猪瘟。按照二元经济理论他们就不养猪了，而把应该投资买小猪的钱不买了，去炒楼炒股了。 我记得上高中的时候政治老师说过供求关系决定产品的价格, 在书中郎教授告诉我们现在有些商品的价格显然不是由供求关系所决定的，比如说石油，比如说粮食,原因就是我们进入了一个前所未有的金融战时代,产品定价权不再由供需决定，而是由国际金融炒家所决定，我们已经进入了一个前所未有的金融超限战争的年代。 为什么金融炒家进入大宗物资的期货市场呢？炒期货的成败，有一个必备的原则，那就是经济基本面一定要配合你的炒作方向，比如我今天赌这个股票会涨，你就要肯定未来一定有人会买这个股票，比如说你认为大米会涨，你就一定要确认一定有一个国家去大买大米。你一定要掌控基本面才能炒期货，否则容易失败。 国际金融炒家是怎么想问题的?他们一下子就看到了中国，中国在资本市场上的影响力是不容小觑的,我们石油价格才涨了13%左右，全世界期货市场的石油价格当天一下子大涨，因为中国人买什么东西，什么东西价格上涨，中国人太多了。就以国际金融炒家的立场来看问题，中国人买什么东西，什么东西就大涨，这不就是基本面吗？因此在中国人买什么东西之前先买，比如从一百块炒到三百块，再卖给中国人，国际炒家就赚两百块。生产者没赚到好处，我们大亏，这就是国际金融炒家的阴谋。金融超限战的原则就是取得定价权,国际金融炒家为了取得产品定价权就开始选品种，首先他挑到了大米。为什么是大米？而不选小麦，这就是水平。因为喜欢吃大米的国家相对吃小麦国家而言，一般而言都是比较贫穷的。这些贫穷国家的老百姓吃大米，如果买不到大米怎么办？就饿死了，但是不是简单的饿死就算了，这会造成政局的动荡！所以，把大米价格一炒高以后，这些吃大米国家的政府立刻面临倒台的危机，稻米的定价权由过去的供需双方决定，改成了国际金融炒家的定价，也就是国际金融炒家取得了最终定价权。由于是国际炒家取得了最终定价权，所以供需不重要，世界大米供过于求，石油供过于求，价格却不跌反涨，大宗物资价格是由国际金融炒家决定的，他们说几块钱就是几块钱。 书有这么一个小故事,韩国总统李明博要进口美国牛肉，韩国民众为什么这么激动要冲击韩国政府呢？！不是因为韩国人好斗, 是因为他们从亚洲金融危机学来的经验就是韩国一旦成功了进口美国牛肉以后，美国牛肉特别的便宜，他将席卷全韩国牛肉户，把全韩国养牛户淘汰，到最后，韩国牛肉价格将被国际金融炒家掌控！ 只有自己生产，才不会被别人所控制，就这么简单！ 我们今天大米价格为什么这么低，而国际价格是我们国内价格的四倍，因为是我们自己生产的。同理石油价格我们还可以抗一下,但我们扛不久，因为造成大量的浪费。","tags":[{"name":"经济学","slug":"经济学","permalink":"http://ijiangnanbei.com/tags/经济学/"}]},{"title":"产业阴谋链与二元经济的形成","date":"2016-09-09T04:04:42.000Z","path":"2016/09/09/《产业阴谋链：笔记二-产业阴谋链与二元经济的形成》/","text":"《产业阴谋链：笔记二 》 我国超过一半的GDP都是固定资产投资，而欧美日本的固定资产投资只有我们的一半。固定资产投资就是读者到处可以看到的高架，桥梁，地铁，地产等等。这些过度的投资带动了经济的成长。所以我国经济就是一个畸形扭曲的“二元经济”，一方面是由于产业链定位错误苦苦挣扎的制造业，另外一方面是极其火爆以拉动GDP为主导的建设工程包括了钢铁，水泥，政绩工程，形象工程，大型国企，替他们融资的银行等等。 这种二元经济就是中国的特色，但是最近几年由于政府政策的错误，使得二元经济现象更加严峻。 第一个错误就是以拉动GDP为主导的经济发展政策，无疑的造成投资过多，而消费过少的局面,我们工厂生产出这么多的产品由于国内消费不足，只有出口卖给外国人消费，因而必定造成所谓“出口创汇”的现实情况，因此外汇迅速积累,大量外汇给了欧美各国极好的借口压迫人民币升值。 第二个错误就是劳动合同法的不当推出，劳动合同法本身它的意义是重大的，问题是这么重大的法案，竟然没有经过反复的讨论论证，更严重的是，没有经过任何的试点就全面的推出。第三个错误就是宏观调控的错误，政府看到了股市和地产的过热就持续加强了宏观调控的力度。前两年，深圳的房地产市场非常的火爆，那时候媒体都报道说，老百姓对我们经济发展更有信心了，深圳地区经济发展更成功了,本质上，深圳地区房地产之所以火爆是因为深圳的经济发展更衰退了！因为企业家更不想继续经营实业了，他们决定不投资了，而拿出来炒楼，如果中国企业过热，企业家的日子不会这么难过！如果你现在从事的恰好是制造业的话，那么你此刻所感受到的是不折不扣的萧条而不是过热。如果你因为不切身从事而还没感觉到，那么你可以去看看大量出口型企业现在的困境。","tags":[{"name":"经济学","slug":"经济学","permalink":"http://ijiangnanbei.com/tags/经济学/"}]},{"title":"一场没有硝烟的战争","date":"2016-09-07T04:00:34.000Z","path":"2016/09/07/《产业阴谋链：笔记一-一场没有硝烟的战争》/","text":"《产业阴谋链：笔记一 》 中国是制造业大国吗？今天的国际竞争已经不是企业的竞争，已经不是产品的竞争，而是进入到了一个前所未有的，一个全新的产业链的战争市场。 1.产业链6+1我们的制造业工厂，对外拖欠原料和组件货款，对内延长劳动时间等等，真可谓不择手段，在最不赚钱的领域不停压榨！ 实际上，任何行业的产业链，除了加工制造，还有六大环节：产品设计，原料采购，物流运输，订单处理，批发经营，终端零售。正是这六大环节创造出了九美金的价值，不过在现在的全球竞争格局下，这些环节中最关键最赚钱的环节，几乎都不是我们中国企业所控制 那些没有觉醒的企业，大多数在国际分工之下，都被分到附加值最低的，浪费资源的，破坏环境的，不得不剥削劳动的——制造环节。而其他有价值的环节基本上全部掌控在欧美各国的手中。也就是说，当我们破坏环境、浪费资源、剥削劳动创造出一块钱血淋淋的产品之后，我们同时就替美国创造出九倍的价值。当我们创造出一万美元的价值之后，我们就同时替美国创造出九万美元的价值。因此中国越制造，美国越富裕。 2.从产业链分工看大学生就业困难。 产业链跟我们大学生就业难有什么关系。六加一的环节里面，真正需要大学生的是六而不是一。 今天的中国是一个什么样的产业结构，是一个以一为主而不是一个以六为主的产业结构。我国的产业现状不足以支持这么样的大学生比例，这就是大学生找工作难的原因。 产业链定位悲剧。今天中国企业所面临的问题，已经不是国企和民企哪个更有效率的问题，而是在这种国际产业链分工之下，如果国企和民企不能急起直追的话，有可能双双被淘汰，事情就是如此之严峻！","tags":[{"name":"经济学","slug":"经济学","permalink":"http://ijiangnanbei.com/tags/经济学/"}]},{"title":"那些屡试不爽的谈判技巧","date":"2016-09-05T15:10:57.000Z","path":"2016/09/05/那些屡试不爽的谈判技巧/","text":"1.第一招要藏锋芒，针针不见血，做好防守姿势，引诱对方步步紧逼，捕捉两种错误——事实错误（所谓硬伤）、逻辑错误。 在对方攻势渐缓时，以对方之前表述中的两种错误为「武器」，优雅地扔回去。只需几针，见血就收。 人和人打交道，尤其部分中国人，「面子」和「规矩」是个有趣的东西，当你挑出他的两种错误，摆出来晾晒，他会让步的，一定会！而随后的形势，会向你的方向逆转。 2.第二招纠结于细节，不如营造气势。对方的所有表述，可以不做任何表态，听着……只要能找到一、两个突破点，质疑、质问，然后全盘否定。不需多言，对方自己会否定自己的一切表述，重新来过，甚至会主动让步，说瞎话被你识破，害臊了！其实他说了一百句，只有三句是瞎话，但被你揪住了。 2.第三招一针见血的分析方法缺乏普遍意义！而是要采用「全面的肤浅」策略，尝试诱导对方的思维路径。在交流中，发现对方的「痛点」，用你的相对优势与其匹配，告诉他，这个问题很关键，我们更善于解决这个问题。","tags":[{"name":"商业技巧","slug":"商业技巧","permalink":"http://ijiangnanbei.com/tags/商业技巧/"}]},{"title":"不信...如果...","date":"2016-09-03T12:40:31.000Z","path":"2016/09/03/不信-如果/","text":"我一直认为从古至今很多人的一生都被两个词所左右，一个词是“不信”，一个词是“如果”，有的人的一生平平庸庸无所作为因为他相信了前者忽视了后者，有的人的一生注定改变世界因为他坚信后者，坚信。 乔布斯想“如果”手机能做的再简单一点该有多好，于是有了 iphone 美得令人窒息的设计，莱特兄弟像“如果”人能够在天上飞该有多好，于是有了飞机。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"},{"name":"商业技巧","slug":"商业技巧","permalink":"http://ijiangnanbei.com/tags/商业技巧/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"操作单链表","date":"2016-09-03T11:52:19.000Z","path":"2016/09/03/操作单链表/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node&#123; int data; struct Node * pNext;&#125;NODE, * PNODE;PNODE create_list(void);void traverse_list(PNODE pHead);//可以把删除的节点放到第三个参数里面bool delete_list(PNODE pHead, int pos, int * pVal);bool is_empty(PNODE pHead);int length_list(PNODE pHead);bool insert_list(PNODE pHead, int pos, int val);void sort_list(PNODE pHead);int main(void)&#123; int val,pos; PNODE pHead = NULL; //在一个函数里面分配很多的内存,并把第一个内存复制给PHead pHead = create_list();//创建一个单链表并把该链表的头结点的地址赋值给pHead // printf(\"please input the position of the number you want to delete:\"); // scanf(\"%d\",&amp;pos); // delete_list(pHead,3,&amp;val); // traverse_list(pHead); // int len = length_list(pHead); // printf(\"the length of list is:\",len); // sort_list(pHead); // if(insert_list(pHead,1,123)) // &#123; // traverse_list(pHead); // &#125; if(delete_list(pHead,4,&amp;val)) &#123; printf(\"delete successful!\\n\"); &#125; else &#123; printf(\"delete failed\\n\"); &#125; traverse_list(pHead); &#125;PNODE create_list(void)&#123; int len;//用来存放有效节点的个数 int i; int val;//用来存放用户输入节点的值 //注意这个头结点只是一个局部变量,和main里面的头结点不是同一个东西 //只不过最后你会把这个结点赋值给main函数里面的pHead PNODE pHead = (PNODE)malloc(sizeof(NODE));//生成头节点 //定义尾节点,在此时只有一个节点的情况下,让pTail指向pHead PNODE pTail = pHead; //如果一个节点都没有,则此时尾节点的指针域为空 pTail-&gt;pNext = NULL; //如果内存分配失败,则退出程序的执行 if(NULL == pHead) &#123; printf(\"distribution failed, program break down!\\n\"); exit(-1); &#125; printf(\"please input the length of your list, len =\"); scanf(\"%d\",&amp;len); for(i=0;i&lt;len;i++) &#123; printf(\"please input the value of %dth:\", i+1); scanf(\"%d\",&amp;val); //每循环一次就生成一个新的结点 PNODE pNew = (PNODE)malloc(sizeof(NODE)); if(NULL == pNew) &#123; printf(\"distribution failed, program break down!\\n\"); exit(-1); &#125; pNew-&gt;data = val; //把新生成的结点挂载到尾节点的后面 pTail-&gt;pNext = pNew; //清空临时结点的指针域,因为这个时候临时结点已经变成最后一个节点了 pNew-&gt;pNext = NULL; //把尾节点指向新节点,这样pTail每次指向的都是最后一个节点. pTail = pNew; &#125; return pHead;&#125;void traverse_list(PNODE pHead)&#123; int i; PNODE p = pHead-&gt;pNext; while(p != NULL) &#123; printf(\"%d \",p-&gt;data ); p = p-&gt;pNext; &#125; printf(\"\\n\");&#125;bool delete_list(PNODE pHead,int pos, int * pVal)&#123; // int i=1; // PNODE p = pHead; // while(p-&gt;pNext != NULL) // &#123; // if(i == pos) // &#123; // p-&gt;pNext = p-&gt;pNext-&gt;pNext; // break; // &#125; // i++; // p = p-&gt;pNext; // &#125; int i = 0; int len = length_list(pHead); PNODE p = pHead; while(NULL != p-&gt;pNext &amp;&amp; i&lt;pos-1) &#123; p = p-&gt;pNext; i++; &#125; if(i&gt;pos-1 || NULL == p-&gt;pNext) return false; PNODE q = p-&gt;pNext; *pVal = q-&gt;data; p-&gt;pNext = p-&gt;pNext-&gt;pNext; free(q); q = NULL; return true;&#125;bool is_empty(PNODE pHead)&#123; if(pHead-&gt;pNext != NULL) &#123; return false; &#125; else &#123; return true; &#125;&#125;int length_list(PNODE pHead)&#123; int i=0; PNODE p = pHead-&gt;pNext; while(p != NULL) &#123; i++; p = p-&gt;pNext; &#125; printf(\"%d\\n\", i);&#125;void sort_list(PNODE pHead)&#123; int len = length_list(pHead); int i,j,t; PNODE p,q; for(i=0, p = pHead-&gt;pNext; i&lt;len-1; i++, p = p-&gt;pNext) &#123; for(j=i+1, q = p-&gt;pNext; j&lt;len; j++, q = q-&gt;pNext) &#123; if(p-&gt;data &gt; q-&gt;data) &#123; t = p-&gt;data; p-&gt;data = q-&gt;data; q-&gt;data = t; &#125; &#125; &#125; return;&#125;bool insert_list(PNODE pHead, int pos, int val)&#123; // PNODE q; // q-&gt;data = val; // PNODE p = pHead; // int len = length_list(pHead); // for(int i=0; i&lt;=len; i++) // &#123; // if(pos &gt; len || pos &lt;0) // &#123; // printf(\"wrong!\\n\"); // &#125; // else if(i == pos) // &#123; // q-&gt;pNext = p-&gt;pNext; // p-&gt;pNext = q; // &#125; // p = p-&gt;pNext; // &#125; // return true; int i = 0; int len = length_list(pHead); PNODE p = pHead; while(NULL != p &amp;&amp; i&lt;pos-1) &#123; p = p-&gt;pNext; i++; &#125; if(i&gt;pos-1 || NULL == p) return false; PNODE pNew = (PNODE)malloc(sizeof(NODE)); if(NULL == pNew) &#123; printf(\"distribution failed!\\n\"); exit(-1); &#125; pNew-&gt;data = val; PNODE q = p-&gt;pNext; p-&gt;pNext = pNew; pNew-&gt;pNext = q; return true;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"链表","date":"2016-09-02T11:45:13.000Z","path":"2016/09/02/链表/","text":"链表的定义n 个结点离散分配，彼此通过指针相连，每个节点只有一个前驱和一个后继。 关于链表你需要明白的几个概念1.首节点 2.尾节点 3.头结点：我们会在首节点前面加一个叫头结点的东西，头结点里面没有数据，头结点里面也没有存放整个节点的个数，之所以要加一个头结点是为了方便我们对链表的操作，就是我们在进行增删改查的时候，可以简便我们对链表算法的操作。 4.头指针：指向头节点的指正变量。 5.尾指正：指向尾节点的指针变量 确定一个数组需要几个参数？确定一个数组我们只需要知道：首地址；数组长度；有效元素的个数。 确定一个链表需要几个参数？首先我们要知道头结点与后面的每一个节点的数据类型是一样的，如果后面的每一个数据都占据了 1000 个字节，那么头结点也同样占据了 1000 个字节。 确定一个链表我们只需要知道一个参数： 头指针。 每一个链表节点的数据类型如何表示？前一个节点可以通过指针找到后面一个数据的整体，不单单是数据或者指针 12345Typedef struct Nde&#123; Int data; Int Node * pNext;&#125;NODE,*PNODE; 链表的分类1.单链表 2.循环链表：能通过任何一个节点找到其他的所有节点 3.非循环链表","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"把批评当做一种信息对待","date":"2016-09-01T12:21:21.000Z","path":"2016/09/01/把批评当做一种信息对待/","text":"在精益创业中，拿出最小可行化产品还远远不够，这只是开始，之后的进程就是不断地获取反馈并在反馈中获得优化。如何处理外界的反馈也是一门艺术。 不喜欢听批评恐怕是人的一种天性。批评本身（很有可能）包含了有价值的信息，所以批评也可以理解为一种帮助。所以对待批评的合理态度是，把批评作为一种“信息”而不是一种“评价”来看待。当然“接收”并不等于“接受”，因为所有输入的信息都需要慎重的审视，只不过不要一开始就情绪化的加以排斥。很多时候，别人的批评并不正确，但思考和辨析这些批评本身对我们也是有益的。 本能的抗拒批评和经过深思熟虑之后反对批评是两回事，后者往往意味着更成熟的心智和更坚定的信念。 成熟心智的一个特点就是，他能不偏不倚的、公正的对待自己和他人的意见，即不固步自封也不附和盲从。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"}]},{"title":"typedef 的用法","date":"2016-09-01T11:05:11.000Z","path":"2016/09/01/typedef-的用法/","text":"12345678910111213141516#inclue &lt;stdio.h&gt;//为 struct Student 这个数据结构重新起了一个名字叫 STtypedef struct Student &#123; int sid; char name[100]; char sex;&#125;ST;int main()&#123; struct Student st;//此时这句话就等价于 ST st; struct Student *ps = &amp;st; // 此时这句话等价于 ST * ps = &amp;st; &#125; 12345678910111213141516#inclue &lt;stdio.h&gt;//注意：此时 ST 前面多了一个 *，此时 ST 代表了一个指针，等价于 typedef struct Student * ST;此时 ST 是 struct Student * 类型&#123; int sid; char name[100]; char sex;&#125;*ST;int main()&#123; struct Student st; ST ps = &amp;st; ps-&gt;sid = 99; printf(\"%d\\n\",ps-&gt;sid);&#125; 1234567891011121314#inclue &lt;stdio.h&gt;//注意：此时 PST 代表了 struct Student * ，而 ST 代表了 struct Student，我们一般写成大写，这样别人一看就知道是一个数据类型的别名&#123; int sid; char name[100]; char sex;&#125;*PST,ST;int main()&#123; ST st；//相当于 struct Student st PST pst；//相当于 struct Student * pst&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"动态分配内存和跨函数使用内存","date":"2016-08-31T14:19:03.000Z","path":"2016/08/31/动态分配内存和跨函数使用内存/","text":"malloc 动态分配内存概述Int * Parr = (int *)malloc(sizeof(int) * len); 我们这里为什么需要进行强制类型转换？我们有 4*len 个字节，但是第一个字节没有实际含义，所以 (int*) 就是告诉我们编译器我们把第一个字节的地址当成了一个整形的地址，所谓整形地址就是说第一个字节的地址代表的是四个字节的地址，那么 parr+1 就是指向后四个，如果你把 int 改成 double 类型，此时就意味着第一个字节的地址代表了 8 个字节的地址，parr+1 那就指向后八个，就是这个意思。 跨函数使用内存A aa = new A();java 的内部就是下面这样子来写的：A *pa = (A*)malloc(sizeof(A)); 要想跨函数使用内存只能动态的来实现。","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"我们应该如何去反思？","date":"2016-08-30T12:15:36.000Z","path":"2016/08/30/我们应该如何去反思？/","text":"在做完一件事情之后,我们可以怎样去反思呢?至少可以从以下几个方面来进行: 1.信息:在做这件事时我利用了哪些信息?其中哪些信息是最关键的?这些信息是从哪些渠道中得来的?哪些渠道被证明是很有价值的?我可能遗漏了哪些信息?这些信息可以怎么得到? 2.预期:在做事之前,是否对事情的过程和结果形成了正确的预期?我为什么会形成这样的预期?是什么造成了预期和事实之间的偏差?我的预期是否促成或阻碍了事情的进程?今后应该如何管理自己的预期? 3.结果:怎样描述这件事情的结果?怎样评价这件事的结果?在描述和评价这件事的时候我用了哪些指标?这些指标是否需要改进?结果需要哪些改进?如何改进?4.进度:事件的进度合适吗,是太快了还是太慢了?什么因素导致了这样的结果?当进度出现问题时使用了哪些手段进行干预?效果如何?为什么效果理想或者不理想? 5.工具:在完成这件事的过程中使用了哪些工具?哪些工具起到了重要的促进作用?那些工具起到了阻碍作用?如何改进现有的工具使其发挥更好的功效? 6.情绪:在做这件事的过程中我的情绪状态是怎样的?是否出现过情绪失控的情况?是什么引发的?我是否有意识的调整自己的情绪?在这期间使用了什么方法?是否需要改进? 7.阻碍:在做事个过程中我遇到了那些阻碍?其中重大的阻碍是什么?我是如何应对这些阻碍的?取得了什么效果?这些阻碍中那些会长期存在?我需要通过什么持续的努力来减少这些阻碍?8.优势:在做事的过程中我发挥了什么优势?是否有什么优势还没有利用和发挥的?在做事的过程中我的主要收获有哪些?我的哪些知识和能力得到了提升?我可以向做同类事情的其他人学习什么?他们有哪些优势是我不具备的? 9.缺憾:在做事的过程中我的遗憾有哪些?最大的遗憾是什么?是什么原因造成了这个遗憾?在做事的过程中我暴露了那些缺点?其中哪些缺点是必须且迫切需要改正的?关于这件事别人对我有什么批评和评价?他们的批评有哪些可取之处? 10.意义:这件事对我来说最大的意义是什么?对我的短期生活和长期生活分别有什么影响?这件事对周围人对社会的意义是什么?我发现了哪些意想不到的意义? 你可以从这些问题示范之中找出你所需要的,然后及时反思,及时梳理.","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"}]},{"title":"结构体使用概述","date":"2016-08-30T11:27:16.000Z","path":"2016/08/30/结构体使用概述/","text":"结构体与我们面向对象里面的‘类’是类似的，只不过结构体里面没有‘方法’,只有成员，结构体是类的一个过渡。 结构体是用户根据自己的需求自己定义的复合数据类型，java 里面类也是一个数据类型。 12345678910111213141516171819#include &lt;stdio.h&gt;struct Student&#123; int sid; char name[200]; int age;&#125;int main(void)&#123; struct Student st = &#123;1000,'jiang',20&#125;; //st.sid = 99;这是第一种方式，不过我们常用第二种方式 struct Student * pst; pst = &amp;st; //pst-&gt;sid 等价于 (*pst).sid 等价于 st.sid pst-&gt;sid = 99;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"如何通过函数修改实参的值？","date":"2016-08-29T11:27:16.000Z","path":"2016/08/29/如何通过函数修改实参的值？/","text":"要修改一个变量的值同时被调函数没有返回值，那你只能通过传递地址的方式来进行修改。 123456789101112131415161718192021#include &lt;stdio.h&gt;void f(int *q);int main(void)&#123; int i = 9; int *p = &amp;i; //%p 表示以16进制的方式输出 printf(\"%p\\n\",p); f(p);//虽然 p==&amp;i,但这里传入p是错的 printf(\"%p\\n\",p);&#125;void f(int *q)&#123; q = (int *)0xFFFFFF;&#125;//输出结果：0060FF08 0060FF08//两次输出的结果相同，可见把p当做参数传入时没有效果 12345678910111213141516171819202122#include &lt;stdio.h&gt;void f(int **q);int main(void)&#123; int i = 9; int *p = &amp;i; printf(\"%p\\n\",p); //p是（int*）类型，那么&amp;p就是（int**）类型，这个叫做指针的指针 //我们这么做的目的只有一个，无论这个十个什么类型的变量，想要改写 //它的值，你只需要发送它的地址就可以了 f(&amp;p); printf(\"%p\\n\",p);&#125;void f(int **q)&#123; *q = (int *)0xFFFFFF;&#125;//两次输出的结果相同，可见把&amp;p当做参数传入时有效果","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"学习编程的秘诀","date":"2016-08-29T09:13:33.000Z","path":"2016/08/29/学习编程的秘诀/","text":"学习编程的秘诀自然是学习解决问题的秘诀,那就拿编程中比较让人蛋疼的数据结构开始吧. 1.判断一个数字是否为素数?2.判断一个数字是否是回文数?3.编程实现求一个十进制数字的二进制形式….4……. 买到任何一本与数据结构有关的书籍,你总会看到无数的这种题,然后你就想啊想啊,想啊想啊,到最后你就是想不出来,然后你就痛苦,然后看下一道题你还是搞不定…到最后你竟然发现没有一道题你可以搞定的,然后你就开始怀疑你的智商,最后你就开始怀疑自己适不适合搞计算机,最终你竟然愚蠢的相信了自己不适合搞计算机…%&gt;_&lt;% 真相是数据结构与算法的题大部分人都是想不出来的,所以如果你想不出来,你不要觉得很痛苦,你去看答案,先看懂,然后去修改,看看改一下会有什么反应,多敲,这时候你对程序的理解就会慢慢加深,积累的多了你自然就学会了. 如果你实在看不懂,那你就用最”聪明”的方法–把它背下来.没错,其实这就是最聪明的方法.真正体验过的人就会知道,当一个很难很难的知识一直待在你的脑子里,然后你还时不时的拿出来想一想,最后你会发现一个神奇的现象,你竟然会了,而且你竟然不知道你为什么会了,恩,会的不需要理由,甚至于当有人问你为什么是这样的时候,你才发现自己也不知道为什么,就好像这个难题这样去解决是理所当然的事 对一些小算法的程序,尝试自己编程去解决它(大部分人都无法自己解决),如果解决不了就看答案,关键是把答案看懂,这个要花很大的精力,也是我们学习的重点.看懂之后尝试自己去修改程序,并且知道修改之后程序的不同输出结果含义.然后自己不看答案独立做出来. 如果程序无法彻底理解就把它背出来. 过几天回顾一次,再敲一次. 周而复始,总有一天你不加思考就敲出来了. 恩,其实大神就是这么走过来的,不过他没告诉你…","tags":[{"name":"编程思想","slug":"编程思想","permalink":"http://ijiangnanbei.com/tags/编程思想/"}]},{"title":"心智随笔","date":"2016-08-29T04:27:43.000Z","path":"2016/08/29/心智随笔（一）/","text":"我学会了查理. 芒格所说的用不同的专业的思维去思考一个问题。我现在能用的就是不同的思维：经济学，数学（概率论，从《万万没想到》里面学到的），心理学，工程学（我的专业），程序，设计。","tags":[{"name":"心智","slug":"心智","permalink":"http://ijiangnanbei.com/tags/心智/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]},{"title":"如何编写出更有价值的程序？","date":"2016-08-28T15:19:19.000Z","path":"2016/08/28/如何编写出更有价值的程序？/","text":"如何写出更有保存价值和使用价值的程序呢？其实很简单，你只需要在你的程序中写上这五点即可： 1.写上编写此程序的时间。 2.写上编写此程序的功能。 3.写上此程序输出的结果。 4.写上编写此程序的目的。 5.写上自己的总结，写上你从中学到的东西。 如果你通过一个程序明白了很多道理，那你就应该这样去写程序，如果你这样做了，那么在任何时候你打开任何一个程序，一看就知道你为什么编写这个程序，当时的你是怎么想的，你从这个程序中学到了什么。","tags":[{"name":"编程思想","slug":"编程思想","permalink":"http://ijiangnanbei.com/tags/编程思想/"}]},{"title":"数组和指针","date":"2016-08-28T11:27:16.000Z","path":"2016/08/28/数组和指针/","text":"12345678910#include &lt;stdio.h&gt;int main() &#123; int a[3] = &#123;1,2,3&#125;; printf(\"%p\\n\",a); //0060FEF4 printf(\"%p\\n\",a+1); //0060FEF8 printf(\"%p\\n\",a+2); //0060FEFC&#125; 由以上程序我们知道，数组的地址是连续的，而且数组名是数组的首地址。 12345678910include &lt;stdio.h&gt;int main()&#123; int a[3] = &#123;1,2,3&#125;; printf(\"%d\\n\",*a+2);//*a+2 等价于 a[0]+2 //结果：3&#125; 1234567891011121314#include &lt;stdio.h&gt;void show(int *p,int len)&#123; //这样是可以修改 a[0] 的，此时p[0]==*(p+0)==*(a+0) p[0] = 100;&#125;int main()&#123; int a[3] = &#123;1,2,3&#125;; show(a,3); printf(\"%d\\n\",a[0]);//100&#125; a[5]={1,2,3}; a 指向的是第一个字节,所以 (a+1) 代表的就是 a 加上 1 乘以 a 所代表的字节数。 a[i] == *(a+i); 所以这样子写也是对的:3[a] == *(3+a) == a[3]。 所有指针变量只占四个字节，(我们的地址总线总共有32根)，一个指针变量无论它所指向的变量占几个字节，它本身的大小都是固定的。 double x = 66.6; p = &amp;x; x 是八个字节,一个字节是 8 位,1 个字节一个地址。 p 里面只存放了一个地址,通常就是我们第一个字节的地址,我们用第一个字节的地址表示整体的地址.","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"创业从做产品开始","date":"2016-08-27T15:52:55.000Z","path":"2016/08/27/创业从做产品开始/","text":"我一直认为，如果你要去创业，那么首先也是最重要的就是你得有自己的产品。就像你在经营自己的人生一样，其实你自己就是一个产品，你需要对她进行“包装”、“宣传”、“营销”、“上市”……这个产品可以不完美，但是你一定要有。 今天我想从产品的角度来谈一下创业，在我看来，现在的创业产品可以分为两大类，第一类：互联网产品，第二类；传统行业产品。 你可以用做互联网产品的思维来做传统产品，你也可以用借鉴传统行业产品的经验来做你的互联网产品，今天我们不谈做产品的思维，我们就谈一下做这两种不同的产品，我们需要抓住的那个最基本的点是什么。 做互联网产品一定是“速度为王”，所以你要想尽一切办法让你的产品快速上市，极速迭代。在这个过程中不断地去有选择的接受用户的反馈，不断地去试错，一点一点地去完善你的产品。在这个过程中，你所服务的用户中一定会有那么一小撮人一直追随着你，如果你在用心的做着这个为他们服务的产品，他们一定会陪伴着你把它做到极致，做到完美。在这个过程中，你一要稳重求快，稳中求胜，抓住这一个点把它做到极致，万万不可自我膨胀，这个产品还没有做好就想去做更多的产品，很多的创业者死就死在这里，死就死在自我膨胀。 做传统行业产品，你所要抓住的基本点是：产品不做到完美绝不上市。一个不完美的产品虽然决定不了你现在的生死，但是它注定了你以后的生死。你需要对产品进行长期的内测，包括消费者的满意的、物流、供应链、营销、竞争力、能不能大规模生产、采购….最关键的是消费者接触的第一次，如果你不能快速让消费者产生共鸣，这款产品很难再有第二次了。所以你一定要把最好的一个产品拿出来，记住是最好的一个产品，一招制敌，第一次就要将其提升到一个高度，否则你就没有第二次机会了。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"},{"name":"创业","slug":"创业","permalink":"http://ijiangnanbei.com/tags/创业/"}]},{"title":"预备知识：指针","date":"2016-08-27T11:27:16.000Z","path":"2016/08/27/预备知识：指针/","text":"指针的重要性学好了指针你才能在程序越写越大的时候明白程序之间的来回调用 指针是C语言的灵魂 如果你不明白C语言的指针,你就不会明白面向对象语言里面的引用 指针的概念地址就是指针 指针就是地址 指针变量是存放内存单元地址的变量 指针的本质是一个操作受限的非负整数 12345678910111213141516include &lt;stdio.h&gt;int main()&#123;//p 是变量名，‘int *’表示p只能存放整形地址的变量 int *p; int i = 10; int j; p = &amp;i;// *p = i j = *p;// j = i printf(\"i = %d,j = %d,*p = %d\",i,j,*p);//10 10 10 return 0;&#125; 由上图可知变量不一定是连续分配的。p 保存了 i 的地址，所以我们说 p 指向了 i，但 p 不是 i ，i 不是 p，修改这两个值中的任何一个不会影响另一个。如果 p 指向 i ，*p 就代表了 i，不能说它是 i 的值，它就是 i 本身， *p 和 i 就是同一个东西。 地址 内存单元的编号；从零开始的非负整数；范围:0----FFFFFFFF[0-4G-1]。 内存是 cpu 唯一可以直接访问的大容量的存储设备，cpu 不能访问硬盘，所以你必须要把硬盘的数据先导入内存。 内存分很多很多的小格子,这些小格子从零开始编号，一直到 4G-1 结束，地址其实就是内存的编号（在图中就是格子的编号）。 地址线:可以确定你对哪一个编号的单元进行操作(因为地址线是32位的,刚好能控制2的32次方个单元,所以内存的最大只能是4G) 控制线:表示是读还是写,还是只读,还是只写。 数据线:传递数据，表示最终你是把 32 个数据发送到 cpu 内部执行还 cpu 把执行的结果写到内存里面。 为什么学习数据结构要用C语言因为我们数据结构里面一个最基本的知识就是链表，我们后面所学到的无论是树还是图，都是以我们的链表为基础的。 我们学C语言的目的之一是你首先能看懂下面的那行代码: 12345678//aa本质上是一个指针,它保存了后面在堆里面的这个对象的地址A aa = new A();//这句话就相当于把aa的地址赋值给aa2A aa2 = aa;这时aa就代表他所指向的那个对象了aa.f();","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"递归思想解读","date":"2016-08-26T15:32:59.000Z","path":"2016/08/26/递归思想解读/","text":"递归：这两个字面的意思就非常形象化，递 就是传递，你把一个东西一层一层的传递下去；归 就是从最后一层，比如说你去故宫走过了一个门又一个门，然后等你走到头之后，你就要返回，所以说 归 就是 回，回到之前的位置。 所以递归要遵循两个原则： 函数自身调用自身，执行 递 的动作 最后一次判断一个终止条件，执行 归 的动作12345//先进入函数n，然后进入函数n-1...知道最后进入函数1function(n)--&gt;function(n-1)....function(1)//然后又从函数1，一直返回到函数nfunction(1)...function(n-1)--&gt;function(n) 举一个栗子：（用JS求阶乘）1234567891011function factorial(n)&#123; if(n == 1) &#123; console.trace();//跟踪递归调用的过程 return 1;//终止条件--&gt;“归” &#125; return n * factorial(n-1);//自身调用自身--&gt;“递”&#125;alert(factorial(5));//120 我们感觉使用递归算法有点没头没脑，其实我们就是假设它已经成功了，然后我们找到 递 和 归 ，然后就让它自己去求解。 这种算法虽然效率比较低下，但是掌握之后我们用这种方法来编程我们会少思考很多东西，只要我们每一步的思路是正确的,那它跟着结果走就肯定会得到答案。","tags":[{"name":"编程思想","slug":"编程思想","permalink":"http://ijiangnanbei.com/tags/编程思想/"}]},{"title":"狭义算法和广义算法","date":"2016-08-26T11:57:20.000Z","path":"2016/08/26/狭义算法和广义算法/","text":"狭义的算法是与数据的存储方式密切相关的。 广义的算法与数据的存储方式无关。广义算法为什么能够做到与存储方式无关呢？因为他利用某种技术达到了这种假象，也就是说不管数据是怎么存的，我用同样的算法都可以搞定，这个技术就是泛型。 泛型就是一种假象，只不过是牛人从内部都已经给你实现好了，你就不用考虑这些问题了，你想怎么用都可以，好像感觉就是一样的，实际上是不一样的。 泛型利用某种技术达到的效果就是：不同的存储方式，执行的操作是一样的。","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"数据结构概述","date":"2016-08-26T11:18:09.000Z","path":"2016/08/26/数据结构概述/","text":"什么是数据结构？数据结构里面，我们所谓的栈就是堆栈，数据结构里面是没有堆这么一个概念的，堆属于分配内存的一种方式，不属于存储数据的一种结构。 我们如何把现实中大量而复杂的问题以特定的数据类型(特定的数据类型指个体如何存储)和特定的存储结构(特定的存储结构指的是个体和个体的关系)保存到主存储器中(内存中)，以及在此基础上为实现某个功能(比如查找某个元，删除某个元素，对所有的元素进行排序)，而执行的相应操作，这个相应的操作叫做算法。 1234567数据结构 = 个体 + 个体的关系算法 = 对存储数据的操作广义算法:从广义来讲算法和存储是没有关系的狭义算法:从狭义上来讲存储方式不一样所执行的算法也不一样。你只有知道狭义的算法是什么，你才会理解泛型，泛型就是广义的算法。 数据结构的特点你在写代码的时候总是会遇到“栈”和“堆”，所谓栈内存和堆内存是指分配内存的算法不一样，如果是以压栈，出栈的方式分配的内存，这个就叫栈内存。而如果你是一种堆排序的方式分配的内存，这个就叫堆内存。 说到函数调用，你怎么去调用函数？你要想知道如何去调用一个函数里面真正运行的原理，你必须要去学栈，因为他是靠压栈和出栈来实现的。 同时学习操作系统你一定需要知道队列的知识。 如果你要学编译原理你会学到里面的语法树，它实际上就是我们数据结构里面的树。 数据库就是数据结构的简化版，只不过他考虑的问题更加简单了：字段-&gt;反映的是一个事物的属性；记录-&gt;表示的是一个整体的事物；表-&gt;同一类事物的集合，事物与事物之间的关系是通过外界来反映的。 程序:数据的存储+数据的操作+可以被计算机执行的语言 衡量算法的标准1.时间复杂度:大概程序要执行的次数(最关键的运行最多的那个步骤执行了多少次)，而非执行的时间。(不同的机器运行的时间一定是不一样的) 2.空间复杂度:算法执行过程中大概所占用的最大内存。 3.难易程度(要让别人都可以看懂) 4.健壮性","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"创业随笔","date":"2016-08-25T15:44:54.000Z","path":"2016/08/25/创业随笔（一）/","text":"1.节奏感真正要创业做的好，其实是要有很强的节奏感，以为着你对整个市场的把握，你对整个资本的把握，以及你对自己企业所处状态的一种判断。比如说：你在什么时候切入到这样一个市场，你在什么时候融资，你融资多大的规模，你对未来市场的预判，包括你未来如何去花钱，乃至于最后你在什么时候挣钱，如何赚多少钱。 如果你有一个很好的节奏感，在这个过程中你会发现你每一个阶段都有一个明确的目标，每一个阶段都把握的非常清楚，你知道了什么东西你要去做，什么东西你不能做，有所为有所不为。 2.顺势而为&amp;另辟蹊径整个互联网的商业模式实际上核心就是三个：最顶层的在上游的是流量入口，中间的是内容运营，底层的是商业经营。 如果你处在别人的生态体系里，比如说BAT，你就要学会顺势而为，借用他们的生态，借用他们打造的势能，然后思考如何成就自己。但是如果你不想遵循这个生态法则，那你就必须自己要去找 到一块新的土地，一个新的领域，或者说是另辟蹊径，比如说你到海外去，到BAT鞭长莫及的地方去。 3.产品没颜值，必死为什么中国的产品普遍没有颜值？第一点就是山寨，他只想着去解决温饱问题，所以他只能沿着山寨的道路走。第二点就是：老板喜欢画龙点睛，觉得自己是见识最多的，经验最足的，这个画龙点睛其实是狗尾续貂。第三点：就是即便你请了国外的大牌设计师因为不一定能够做出很好的产品。 最后我想说：只要你花足够多的时间和精力一定可以做出一款非常漂亮的产品。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"},{"name":"创业","slug":"创业","permalink":"http://ijiangnanbei.com/tags/创业/"}]},{"title":"位运算","date":"2016-08-24T08:36:16.000Z","path":"2016/08/24/位运算/","text":"理解位运算的第一步是理解二进制，其实二进制的位运算并不是很难掌握，因为位运算总共只有五种运算：与、或、异或、左移和右移。 Tables Are Cool Cool Cool 与（&amp;） 0 &amp; 0 = 0 1 &amp; 0 = 0 0 &amp; 1 = 0 1 &amp; 1 = 1 或 0 或 0 = 0 1 或 0 = 1 0 或 1 = 1 1 或 1 = 1 异或（^） 0 ^ 0 = 0 1 ^ 0 = 1 0 ^ 1 = 1 1 ^ 1 = 0 左移运算：左移运算符 m&lt;&lt;n ,表示把 m 左移 n 位。左移 n 位的时候，最左边的 n 位将被丢弃，同时在最右边补上 n 个 0。 右移运算符：左移运算符 m&gt;&gt;n ,表示把 m 右移 n 位。如果数字原先是一个正数，则右移之后在左边补 n 个 0；如果数字原先是个负数，则右移之后在最左边补 n 个 1。 高位和地位：用十进制数来比喻，百位数相对于十位数、个位数就是高位。更通俗讲，就是左边的数相对于右边的数来讲是高位。 移位运算与乘除法：把整数右移一位和把整数除以 2 在数学上是等价的，那我们可不可以把右移运算换成除以 2 呢？ 答案是否定的，因为除法的效率比移位运算要低的多，在实际的编程中应尽可能地用移位运算代替乘除法。","tags":[{"name":"算法","slug":"算法","permalink":"http://ijiangnanbei.com/tags/算法/"}]},{"title":"营销随笔","date":"0201-11-23T14:34:31.000Z","path":"0201/11/23/营销随笔/","text":"《特劳特营销十要》有感定位的本质是解决占有消费者心智资源的问题。品牌的本质是解决心智资源占有数量和质量的问题。从很大意义上来说，定位是因，品牌是果。定位之后的系统整合和一系列营销活动，实际上是在消费者的大脑里创建或强化一种心智模式，或者是重新改善对待品牌的心智模式。当这种心智资源被占有到一定程度（可用销量或市场占有率来衡量），或心智模式已在较大市场范围明确确立时，则形成了品牌力，而品牌力即构成了竞争力的核心，品牌战略则是有效延续和扩大核心竞争优势的方针性举措。","tags":[{"name":"营销","slug":"营销","permalink":"http://ijiangnanbei.com/tags/营销/"},{"name":"随笔","slug":"随笔","permalink":"http://ijiangnanbei.com/tags/随笔/"}]}]